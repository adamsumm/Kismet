# Generated from kismet.ebnv by ANTLR 4.7.2
# encoding: utf-8
from antlr4 import *
from io import StringIO
from typing.io import TextIO
import sys


def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3c")
        buf.write("\u02c3\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\4\23\t\23")
        buf.write("\4\24\t\24\4\25\t\25\4\26\t\26\4\27\t\27\4\30\t\30\4\31")
        buf.write("\t\31\4\32\t\32\4\33\t\33\4\34\t\34\4\35\t\35\4\36\t\36")
        buf.write("\4\37\t\37\4 \t \4!\t!\4\"\t\"\4#\t#\4$\t$\4%\t%\4&\t")
        buf.write("&\4\'\t\'\4(\t(\4)\t)\4*\t*\4+\t+\4,\t,\4-\t-\4.\t.\4")
        buf.write("/\t/\4\60\t\60\4\61\t\61\4\62\t\62\4\63\t\63\4\64\t\64")
        buf.write("\4\65\t\65\4\66\t\66\4\67\t\67\48\t8\49\t9\4:\t:\3\2\3")
        buf.write("\2\3\2\3\2\3\2\6\2z\n\2\r\2\16\2{\3\2\3\2\3\3\3\3\3\3")
        buf.write("\3\3\3\3\3\3\7\3\u0086\n\3\f\3\16\3\u0089\13\3\3\3\3\3")
        buf.write("\5\3\u008d\n\3\3\3\3\3\3\3\3\3\3\4\3\4\3\4\3\4\7\4\u0097")
        buf.write("\n\4\f\4\16\4\u009a\13\4\3\5\5\5\u009d\n\5\3\5\3\5\5\5")
        buf.write("\u00a1\n\5\3\5\3\5\3\5\7\5\u00a6\n\5\f\5\16\5\u00a9\13")
        buf.write("\5\3\5\3\5\3\5\3\5\7\5\u00af\n\5\f\5\16\5\u00b2\13\5\3")
        buf.write("\5\3\5\5\5\u00b6\n\5\3\5\3\5\5\5\u00ba\n\5\3\5\3\5\7\5")
        buf.write("\u00be\n\5\f\5\16\5\u00c1\13\5\3\5\3\5\3\6\3\6\3\7\3\7")
        buf.write("\3\b\3\b\3\t\3\t\5\t\u00cd\n\t\3\n\3\n\5\n\u00d1\n\n\3")
        buf.write("\13\3\13\3\13\3\13\3\13\7\13\u00d8\n\13\f\13\16\13\u00db")
        buf.write("\13\13\3\13\5\13\u00de\n\13\3\13\3\13\3\f\3\f\3\f\3\f")
        buf.write("\3\f\7\f\u00e7\n\f\f\f\16\f\u00ea\13\f\3\f\5\f\u00ed\n")
        buf.write("\f\3\f\3\f\3\f\3\f\3\f\3\f\3\f\5\f\u00f6\n\f\3\r\6\r\u00f9")
        buf.write("\n\r\r\r\16\r\u00fa\3\r\6\r\u00fe\n\r\r\r\16\r\u00ff\5")
        buf.write("\r\u0102\n\r\3\16\5\16\u0105\n\16\3\16\3\16\3\16\3\16")
        buf.write("\3\16\3\16\7\16\u010d\n\16\f\16\16\16\u0110\13\16\3\16")
        buf.write("\3\16\5\16\u0114\n\16\3\16\5\16\u0117\n\16\3\16\5\16\u011a")
        buf.write("\n\16\3\16\3\16\5\16\u011e\n\16\3\16\3\16\7\16\u0122\n")
        buf.write("\16\f\16\16\16\u0125\13\16\3\16\3\16\3\17\3\17\3\17\3")
        buf.write("\20\3\20\3\21\3\21\3\21\3\21\3\21\7\21\u0133\n\21\f\21")
        buf.write("\16\21\u0136\13\21\3\22\3\22\3\23\3\23\3\23\3\24\3\24")
        buf.write("\6\24\u013f\n\24\r\24\16\24\u0140\3\25\3\25\3\25\3\25")
        buf.write("\3\25\7\25\u0148\n\25\f\25\16\25\u014b\13\25\3\25\3\25")
        buf.write("\3\25\3\25\3\25\3\25\3\25\7\25\u0154\n\25\f\25\16\25\u0157")
        buf.write("\13\25\3\25\3\25\3\25\3\25\3\25\3\25\3\25\7\25\u0160\n")
        buf.write("\25\f\25\16\25\u0163\13\25\3\25\3\25\3\25\3\25\3\25\3")
        buf.write("\25\7\25\u016b\n\25\f\25\16\25\u016e\13\25\3\25\3\25\5")
        buf.write("\25\u0172\n\25\3\26\3\26\3\27\3\27\3\27\3\27\3\27\5\27")
        buf.write("\u017b\n\27\3\30\3\30\3\30\3\30\3\30\3\30\7\30\u0183\n")
        buf.write("\30\f\30\16\30\u0186\13\30\3\30\3\30\5\30\u018a\n\30\3")
        buf.write("\30\3\30\3\30\5\30\u018f\n\30\3\30\3\30\3\30\5\30\u0194")
        buf.write("\n\30\7\30\u0196\n\30\f\30\16\30\u0199\13\30\3\30\3\30")
        buf.write("\3\31\3\31\3\31\5\31\u01a0\n\31\3\31\3\31\3\31\3\31\7")
        buf.write("\31\u01a6\n\31\f\31\16\31\u01a9\13\31\3\31\3\31\3\32\3")
        buf.write("\32\3\32\3\33\5\33\u01b1\n\33\3\33\3\33\5\33\u01b5\n\33")
        buf.write("\3\33\3\33\3\33\3\33\3\33\5\33\u01bc\n\33\3\33\3\33\3")
        buf.write("\33\3\33\5\33\u01c2\n\33\3\34\3\34\3\35\3\35\3\36\3\36")
        buf.write("\3\36\3\36\3\36\7\36\u01cd\n\36\f\36\16\36\u01d0\13\36")
        buf.write("\3\37\3\37\3\37\3\37\7\37\u01d6\n\37\f\37\16\37\u01d9")
        buf.write("\13\37\3 \3 \3 \3 \3 \3 \3 \3 \3 \3 \3 \3 \3 \3 \3 \3")
        buf.write(" \3 \3 \3 \3 \3 \3 \3 \3 \3 \3 \3 \3 \3 \3 \3 \3 \3 \3")
        buf.write(" \3 \3 \3 \3 \3 \3 \5 \u0203\n \3!\3!\3!\3!\3!\3!\3!\3")
        buf.write("!\3!\3!\5!\u020f\n!\3\"\3\"\3\"\3\"\3\"\3\"\3#\3#\3#\3")
        buf.write("#\3$\3$\3$\3$\3%\3%\3%\3%\3%\3%\3&\3&\3&\3&\3&\3&\3&\3")
        buf.write("&\3\'\3\'\3\'\3\'\3\'\3\'\3\'\3\'\3(\3(\3)\3)\3)\3)\5")
        buf.write(")\u023b\n)\3)\3)\3)\3)\5)\u0241\n)\3)\3)\3)\5)\u0246\n")
        buf.write(")\3*\3*\5*\u024a\n*\3*\7*\u024d\n*\f*\16*\u0250\13*\3")
        buf.write("*\3*\7*\u0254\n*\f*\16*\u0257\13*\3*\3*\3*\3*\5*\u025d")
        buf.write("\n*\3+\3+\3+\3+\3+\3+\3,\3,\3,\3,\3,\7,\u026a\n,\f,\16")
        buf.write(",\u026d\13,\3,\3,\3-\3-\3.\3.\3/\3/\3/\3/\3/\3/\5/\u027b")
        buf.write("\n/\3/\3/\3/\3/\5/\u0281\n/\7/\u0283\n/\f/\16/\u0286\13")
        buf.write("/\3/\3/\3\60\3\60\3\60\3\60\3\61\3\61\3\61\3\61\7\61\u0292")
        buf.write("\n\61\f\61\16\61\u0295\13\61\3\62\3\62\3\63\3\63\3\63")
        buf.write("\3\63\3\63\7\63\u029e\n\63\f\63\16\63\u02a1\13\63\3\64")
        buf.write("\3\64\3\65\3\65\3\66\3\66\3\67\3\67\38\38\39\39\39\39")
        buf.write("\39\39\39\39\39\39\39\59\u02b8\n9\39\39\59\u02bc\n9\3")
        buf.write(":\6:\u02bf\n:\r:\16:\u02c0\3:\2\2;\2\4\6\b\n\f\16\20\22")
        buf.write("\24\26\30\32\34\36 \"$&(*,.\60\62\64\668:<>@BDFHJLNPR")
        buf.write("TVXZ\\^`bdfhjlnpr\2\r\3\2\f\r\3\2\7\b\4\2\20\20\34\37")
        buf.write("\3\2\65\66\3\2\67<\3\2AC\3\2DG\4\2CCHM\3\2Y[\5\2\34\34")
        buf.write("\37\37QU\6\2\b\b\35\35XXaa\2\u02f6\2y\3\2\2\2\4\177\3")
        buf.write("\2\2\2\6\u0092\3\2\2\2\b\u009c\3\2\2\2\n\u00c4\3\2\2\2")
        buf.write("\f\u00c6\3\2\2\2\16\u00c8\3\2\2\2\20\u00cc\3\2\2\2\22")
        buf.write("\u00d0\3\2\2\2\24\u00d2\3\2\2\2\26\u00f5\3\2\2\2\30\u0101")
        buf.write("\3\2\2\2\32\u0104\3\2\2\2\34\u0128\3\2\2\2\36\u012b\3")
        buf.write("\2\2\2 \u012d\3\2\2\2\"\u0137\3\2\2\2$\u0139\3\2\2\2&")
        buf.write("\u013c\3\2\2\2(\u0171\3\2\2\2*\u0173\3\2\2\2,\u017a\3")
        buf.write("\2\2\2.\u017c\3\2\2\2\60\u019c\3\2\2\2\62\u01ac\3\2\2")
        buf.write("\2\64\u01c1\3\2\2\2\66\u01c3\3\2\2\28\u01c5\3\2\2\2:\u01c7")
        buf.write("\3\2\2\2<\u01d1\3\2\2\2>\u0202\3\2\2\2@\u020e\3\2\2\2")
        buf.write("B\u0210\3\2\2\2D\u0216\3\2\2\2F\u021a\3\2\2\2H\u021e\3")
        buf.write("\2\2\2J\u0224\3\2\2\2L\u022c\3\2\2\2N\u0234\3\2\2\2P\u0236")
        buf.write("\3\2\2\2R\u0247\3\2\2\2T\u025e\3\2\2\2V\u0264\3\2\2\2")
        buf.write("X\u0270\3\2\2\2Z\u0272\3\2\2\2\\\u0274\3\2\2\2^\u0289")
        buf.write("\3\2\2\2`\u028d\3\2\2\2b\u0296\3\2\2\2d\u0298\3\2\2\2")
        buf.write("f\u02a2\3\2\2\2h\u02a4\3\2\2\2j\u02a6\3\2\2\2l\u02a8\3")
        buf.write("\2\2\2n\u02aa\3\2\2\2p\u02bb\3\2\2\2r\u02be\3\2\2\2tz")
        buf.write("\5\\/\2uz\5.\30\2vz\5\32\16\2wz\5\b\5\2xz\5\4\3\2yt\3")
        buf.write("\2\2\2yu\3\2\2\2yv\3\2\2\2yw\3\2\2\2yx\3\2\2\2z{\3\2\2")
        buf.write("\2{y\3\2\2\2{|\3\2\2\2|}\3\2\2\2}~\7\2\2\3~\3\3\2\2\2")
        buf.write("\177\u0080\7\3\2\2\u0080\u0081\5j\66\2\u0081\u0082\7\4")
        buf.write("\2\2\u0082\u0087\5\64\33\2\u0083\u0084\7\5\2\2\u0084\u0086")
        buf.write("\5\64\33\2\u0085\u0083\3\2\2\2\u0086\u0089\3\2\2\2\u0087")
        buf.write("\u0085\3\2\2\2\u0087\u0088\3\2\2\2\u0088\u008a\3\2\2\2")
        buf.write("\u0089\u0087\3\2\2\2\u008a\u008c\7\6\2\2\u008b\u008d\5")
        buf.write("b\62\2\u008c\u008b\3\2\2\2\u008c\u008d\3\2\2\2\u008d\u008e")
        buf.write("\3\2\2\2\u008e\u008f\7\7\2\2\u008f\u0090\5<\37\2\u0090")
        buf.write("\u0091\7\b\2\2\u0091\5\3\2\2\2\u0092\u0093\7\t\2\2\u0093")
        buf.write("\u0098\5j\66\2\u0094\u0095\7\n\2\2\u0095\u0097\5j\66\2")
        buf.write("\u0096\u0094\3\2\2\2\u0097\u009a\3\2\2\2\u0098\u0096\3")
        buf.write("\2\2\2\u0098\u0099\3\2\2\2\u0099\7\3\2\2\2\u009a\u0098")
        buf.write("\3\2\2\2\u009b\u009d\5\n\6\2\u009c\u009b\3\2\2\2\u009c")
        buf.write("\u009d\3\2\2\2\u009d\u009e\3\2\2\2\u009e\u00a0\5\f\7\2")
        buf.write("\u009f\u00a1\5\16\b\2\u00a0\u009f\3\2\2\2\u00a0\u00a1")
        buf.write("\3\2\2\2\u00a1\u00a2\3\2\2\2\u00a2\u00a7\5j\66\2\u00a3")
        buf.write("\u00a4\7\n\2\2\u00a4\u00a6\5j\66\2\u00a5\u00a3\3\2\2\2")
        buf.write("\u00a6\u00a9\3\2\2\2\u00a7\u00a5\3\2\2\2\u00a7\u00a8\3")
        buf.write("\2\2\2\u00a8\u00aa\3\2\2\2\u00a9\u00a7\3\2\2\2\u00aa\u00ab")
        buf.write("\7\4\2\2\u00ab\u00b0\5\64\33\2\u00ac\u00ad\7\5\2\2\u00ad")
        buf.write("\u00af\5\64\33\2\u00ae\u00ac\3\2\2\2\u00af\u00b2\3\2\2")
        buf.write("\2\u00b0\u00ae\3\2\2\2\u00b0\u00b1\3\2\2\2\u00b1\u00b3")
        buf.write("\3\2\2\2\u00b2\u00b0\3\2\2\2\u00b3\u00b5\7\6\2\2\u00b4")
        buf.write("\u00b6\5\6\4\2\u00b5\u00b4\3\2\2\2\u00b5\u00b6\3\2\2\2")
        buf.write("\u00b6\u00b7\3\2\2\2\u00b7\u00b9\7\7\2\2\u00b8\u00ba\5")
        buf.write("\20\t\2\u00b9\u00b8\3\2\2\2\u00b9\u00ba\3\2\2\2\u00ba")
        buf.write("\u00bf\3\2\2\2\u00bb\u00bc\7\5\2\2\u00bc\u00be\5\20\t")
        buf.write("\2\u00bd\u00bb\3\2\2\2\u00be\u00c1\3\2\2\2\u00bf\u00bd")
        buf.write("\3\2\2\2\u00bf\u00c0\3\2\2\2\u00c0\u00c2\3\2\2\2\u00c1")
        buf.write("\u00bf\3\2\2\2\u00c2\u00c3\7\b\2\2\u00c3\t\3\2\2\2\u00c4")
        buf.write("\u00c5\7\13\2\2\u00c5\13\3\2\2\2\u00c6\u00c7\t\2\2\2\u00c7")
        buf.write("\r\3\2\2\2\u00c8\u00c9\7\16\2\2\u00c9\17\3\2\2\2\u00ca")
        buf.write("\u00cd\5\24\13\2\u00cb\u00cd\5\26\f\2\u00cc\u00ca\3\2")
        buf.write("\2\2\u00cc\u00cb\3\2\2\2\u00cd\21\3\2\2\2\u00ce\u00d1")
        buf.write("\7\17\2\2\u00cf\u00d1\5j\66\2\u00d0\u00ce\3\2\2\2\u00d0")
        buf.write("\u00cf\3\2\2\2\u00d1\23\3\2\2\2\u00d2\u00d3\5\30\r\2\u00d3")
        buf.write("\u00d4\7\4\2\2\u00d4\u00d9\5\22\n\2\u00d5\u00d6\7\5\2")
        buf.write("\2\u00d6\u00d8\5\22\n\2\u00d7\u00d5\3\2\2\2\u00d8\u00db")
        buf.write("\3\2\2\2\u00d9\u00d7\3\2\2\2\u00d9\u00da\3\2\2\2\u00da")
        buf.write("\u00dd\3\2\2\2\u00db\u00d9\3\2\2\2\u00dc\u00de\5<\37\2")
        buf.write("\u00dd\u00dc\3\2\2\2\u00dd\u00de\3\2\2\2\u00de\u00df\3")
        buf.write("\2\2\2\u00df\u00e0\7\6\2\2\u00e0\25\3\2\2\2\u00e1\u00e2")
        buf.write("\5\30\r\2\u00e2\u00e3\7\20\2\2\u00e3\u00e8\5j\66\2\u00e4")
        buf.write("\u00e5\7\5\2\2\u00e5\u00e7\5j\66\2\u00e6\u00e4\3\2\2\2")
        buf.write("\u00e7\u00ea\3\2\2\2\u00e8\u00e6\3\2\2\2\u00e8\u00e9\3")
        buf.write("\2\2\2\u00e9\u00ec\3\2\2\2\u00ea\u00e8\3\2\2\2\u00eb\u00ed")
        buf.write("\5<\37\2\u00ec\u00eb\3\2\2\2\u00ec\u00ed\3\2\2\2\u00ed")
        buf.write("\u00ee\3\2\2\2\u00ee\u00ef\7\20\2\2\u00ef\u00f6\3\2\2")
        buf.write("\2\u00f0\u00f1\5\30\r\2\u00f1\u00f2\7\20\2\2\u00f2\u00f3")
        buf.write("\5<\37\2\u00f3\u00f4\7\20\2\2\u00f4\u00f6\3\2\2\2\u00f5")
        buf.write("\u00e1\3\2\2\2\u00f5\u00f0\3\2\2\2\u00f6\27\3\2\2\2\u00f7")
        buf.write("\u00f9\7\21\2\2\u00f8\u00f7\3\2\2\2\u00f9\u00fa\3\2\2")
        buf.write("\2\u00fa\u00f8\3\2\2\2\u00fa\u00fb\3\2\2\2\u00fb\u0102")
        buf.write("\3\2\2\2\u00fc\u00fe\7a\2\2\u00fd\u00fc\3\2\2\2\u00fe")
        buf.write("\u00ff\3\2\2\2\u00ff\u00fd\3\2\2\2\u00ff\u0100\3\2\2\2")
        buf.write("\u0100\u0102\3\2\2\2\u0101\u00f8\3\2\2\2\u0101\u00fd\3")
        buf.write("\2\2\2\u0102\31\3\2\2\2\u0103\u0105\5\36\20\2\u0104\u0103")
        buf.write("\3\2\2\2\u0104\u0105\3\2\2\2\u0105\u0106\3\2\2\2\u0106")
        buf.write("\u0107\7\22\2\2\u0107\u0108\5j\66\2\u0108\u0109\7\4\2")
        buf.write("\2\u0109\u010e\5\64\33\2\u010a\u010b\7\5\2\2\u010b\u010d")
        buf.write("\5\64\33\2\u010c\u010a\3\2\2\2\u010d\u0110\3\2\2\2\u010e")
        buf.write("\u010c\3\2\2\2\u010e\u010f\3\2\2\2\u010f\u0111\3\2\2\2")
        buf.write("\u0110\u010e\3\2\2\2\u0111\u0113\7\6\2\2\u0112\u0114\5")
        buf.write("\34\17\2\u0113\u0112\3\2\2\2\u0113\u0114\3\2\2\2\u0114")
        buf.write("\u0116\3\2\2\2\u0115\u0117\5\60\31\2\u0116\u0115\3\2\2")
        buf.write("\2\u0116\u0117\3\2\2\2\u0117\u0119\3\2\2\2\u0118\u011a")
        buf.write("\5b\62\2\u0119\u0118\3\2\2\2\u0119\u011a\3\2\2\2\u011a")
        buf.write("\u011b\3\2\2\2\u011b\u011d\7\7\2\2\u011c\u011e\5,\27\2")
        buf.write("\u011d\u011c\3\2\2\2\u011d\u011e\3\2\2\2\u011e\u0123\3")
        buf.write("\2\2\2\u011f\u0120\7\23\2\2\u0120\u0122\5,\27\2\u0121")
        buf.write("\u011f\3\2\2\2\u0122\u0125\3\2\2\2\u0123\u0121\3\2\2\2")
        buf.write("\u0123\u0124\3\2\2\2\u0124\u0126\3\2\2\2\u0125\u0123\3")
        buf.write("\2\2\2\u0126\u0127\7\b\2\2\u0127\33\3\2\2\2\u0128\u0129")
        buf.write("\7\24\2\2\u0129\u012a\5f\64\2\u012a\35\3\2\2\2\u012b\u012c")
        buf.write("\7\25\2\2\u012c\37\3\2\2\2\u012d\u012e\7\26\2\2\u012e")
        buf.write("\u012f\7\7\2\2\u012f\u0134\5\"\22\2\u0130\u0131\7\5\2")
        buf.write("\2\u0131\u0133\5\"\22\2\u0132\u0130\3\2\2\2\u0133\u0136")
        buf.write("\3\2\2\2\u0134\u0132\3\2\2\2\u0134\u0135\3\2\2\2\u0135")
        buf.write("!\3\2\2\2\u0136\u0134\3\2\2\2\u0137\u0138\5@!\2\u0138")
        buf.write("#\3\2\2\2\u0139\u013a\7\17\2\2\u013a\u013b\5\30\r\2\u013b")
        buf.write("%\3\2\2\2\u013c\u013e\7\27\2\2\u013d\u013f\5(\25\2\u013e")
        buf.write("\u013d\3\2\2\2\u013f\u0140\3\2\2\2\u0140\u013e\3\2\2\2")
        buf.write("\u0140\u0141\3\2\2\2\u0141\'\3\2\2\2\u0142\u0143\5l\67")
        buf.write("\2\u0143\u0144\7\4\2\2\u0144\u0149\5\64\33\2\u0145\u0146")
        buf.write("\7\5\2\2\u0146\u0148\5\64\33\2\u0147\u0145\3\2\2\2\u0148")
        buf.write("\u014b\3\2\2\2\u0149\u0147\3\2\2\2\u0149\u014a\3\2\2\2")
        buf.write("\u014a\u014c\3\2\2\2\u014b\u0149\3\2\2\2\u014c\u014d\7")
        buf.write("\6\2\2\u014d\u0172\3\2\2\2\u014e\u014f\5j\66\2\u014f\u0150")
        buf.write("\7\4\2\2\u0150\u0155\5\64\33\2\u0151\u0152\7\5\2\2\u0152")
        buf.write("\u0154\5\64\33\2\u0153\u0151\3\2\2\2\u0154\u0157\3\2\2")
        buf.write("\2\u0155\u0153\3\2\2\2\u0155\u0156\3\2\2\2\u0156\u0158")
        buf.write("\3\2\2\2\u0157\u0155\3\2\2\2\u0158\u0159\7\6\2\2\u0159")
        buf.write("\u0172\3\2\2\2\u015a\u015b\5*\26\2\u015b\u015c\7\4\2\2")
        buf.write("\u015c\u0161\5\64\33\2\u015d\u015e\7\5\2\2\u015e\u0160")
        buf.write("\5\64\33\2\u015f\u015d\3\2\2\2\u0160\u0163\3\2\2\2\u0161")
        buf.write("\u015f\3\2\2\2\u0161\u0162\3\2\2\2\u0162\u0164\3\2\2\2")
        buf.write("\u0163\u0161\3\2\2\2\u0164\u0165\7\6\2\2\u0165\u0172\3")
        buf.write("\2\2\2\u0166\u0167\7\4\2\2\u0167\u016c\5\64\33\2\u0168")
        buf.write("\u0169\7\5\2\2\u0169\u016b\5\64\33\2\u016a\u0168\3\2\2")
        buf.write("\2\u016b\u016e\3\2\2\2\u016c\u016a\3\2\2\2\u016c\u016d")
        buf.write("\3\2\2\2\u016d\u016f\3\2\2\2\u016e\u016c\3\2\2\2\u016f")
        buf.write("\u0170\7\6\2\2\u0170\u0172\3\2\2\2\u0171\u0142\3\2\2\2")
        buf.write("\u0171\u014e\3\2\2\2\u0171\u015a\3\2\2\2\u0171\u0166\3")
        buf.write("\2\2\2\u0172)\3\2\2\2\u0173\u0174\7\30\2\2\u0174+\3\2")
        buf.write("\2\2\u0175\u017b\5:\36\2\u0176\u017b\5<\37\2\u0177\u017b")
        buf.write("\5&\24\2\u0178\u017b\5 \21\2\u0179\u017b\5$\23\2\u017a")
        buf.write("\u0175\3\2\2\2\u017a\u0176\3\2\2\2\u017a\u0177\3\2\2\2")
        buf.write("\u017a\u0178\3\2\2\2\u017a\u0179\3\2\2\2\u017b-\3\2\2")
        buf.write("\2\u017c\u017d\7\31\2\2\u017d\u017e\5j\66\2\u017e\u017f")
        buf.write("\7\4\2\2\u017f\u0184\5\64\33\2\u0180\u0181\7\5\2\2\u0181")
        buf.write("\u0183\5\64\33\2\u0182\u0180\3\2\2\2\u0183\u0186\3\2\2")
        buf.write("\2\u0184\u0182\3\2\2\2\u0184\u0185\3\2\2\2\u0185\u0187")
        buf.write("\3\2\2\2\u0186\u0184\3\2\2\2\u0187\u0189\7\6\2\2\u0188")
        buf.write("\u018a\5\60\31\2\u0189\u0188\3\2\2\2\u0189\u018a\3\2\2")
        buf.write("\2\u018a\u018b\3\2\2\2\u018b\u018e\7\7\2\2\u018c\u018f")
        buf.write("\5:\36\2\u018d\u018f\5<\37\2\u018e\u018c\3\2\2\2\u018e")
        buf.write("\u018d\3\2\2\2\u018f\u0197\3\2\2\2\u0190\u0193\7\23\2")
        buf.write("\2\u0191\u0194\5:\36\2\u0192\u0194\5<\37\2\u0193\u0191")
        buf.write("\3\2\2\2\u0193\u0192\3\2\2\2\u0194\u0196\3\2\2\2\u0195")
        buf.write("\u0190\3\2\2\2\u0196\u0199\3\2\2\2\u0197\u0195\3\2\2\2")
        buf.write("\u0197\u0198\3\2\2\2\u0198\u019a\3\2\2\2\u0199\u0197\3")
        buf.write("\2\2\2\u019a\u019b\7\b\2\2\u019b/\3\2\2\2\u019c\u019f")
        buf.write("\7\32\2\2\u019d\u01a0\5\62\32\2\u019e\u01a0\5j\66\2\u019f")
        buf.write("\u019d\3\2\2\2\u019f\u019e\3\2\2\2\u01a0\u01a1\3\2\2\2")
        buf.write("\u01a1\u01a2\7\4\2\2\u01a2\u01a7\5\64\33\2\u01a3\u01a4")
        buf.write("\7\5\2\2\u01a4\u01a6\5\64\33\2\u01a5\u01a3\3\2\2\2\u01a6")
        buf.write("\u01a9\3\2\2\2\u01a7\u01a5\3\2\2\2\u01a7\u01a8\3\2\2\2")
        buf.write("\u01a8\u01aa\3\2\2\2\u01a9\u01a7\3\2\2\2\u01aa\u01ab\7")
        buf.write("\6\2\2\u01ab\61\3\2\2\2\u01ac\u01ad\7\33\2\2\u01ad\u01ae")
        buf.write("\5j\66\2\u01ae\63\3\2\2\2\u01af\u01b1\58\35\2\u01b0\u01af")
        buf.write("\3\2\2\2\u01b0\u01b1\3\2\2\2\u01b1\u01b2\3\2\2\2\u01b2")
        buf.write("\u01c2\5l\67\2\u01b3\u01b5\58\35\2\u01b4\u01b3\3\2\2\2")
        buf.write("\u01b4\u01b5\3\2\2\2\u01b5\u01b6\3\2\2\2\u01b6\u01b7\5")
        buf.write("l\67\2\u01b7\u01b8\5\66\34\2\u01b8\u01b9\5j\66\2\u01b9")
        buf.write("\u01c2\3\2\2\2\u01ba\u01bc\58\35\2\u01bb\u01ba\3\2\2\2")
        buf.write("\u01bb\u01bc\3\2\2\2\u01bc\u01bd\3\2\2\2\u01bd\u01be\5")
        buf.write("l\67\2\u01be\u01bf\5\66\34\2\u01bf\u01c0\5l\67\2\u01c0")
        buf.write("\u01c2\3\2\2\2\u01c1\u01b0\3\2\2\2\u01c1\u01b4\3\2\2\2")
        buf.write("\u01c1\u01bb\3\2\2\2\u01c2\65\3\2\2\2\u01c3\u01c4\t\3")
        buf.write("\2\2\u01c4\67\3\2\2\2\u01c5\u01c6\t\4\2\2\u01c69\3\2\2")
        buf.write("\2\u01c7\u01c8\7 \2\2\u01c8\u01c9\7\7\2\2\u01c9\u01ce")
        buf.write("\5j\66\2\u01ca\u01cb\7\5\2\2\u01cb\u01cd\5j\66\2\u01cc")
        buf.write("\u01ca\3\2\2\2\u01cd\u01d0\3\2\2\2\u01ce\u01cc\3\2\2\2")
        buf.write("\u01ce\u01cf\3\2\2\2\u01cf;\3\2\2\2\u01d0\u01ce\3\2\2")
        buf.write("\2\u01d1\u01d2\7!\2\2\u01d2\u01d7\5@!\2\u01d3\u01d4\7")
        buf.write("\5\2\2\u01d4\u01d6\5@!\2\u01d5\u01d3\3\2\2\2\u01d6\u01d9")
        buf.write("\3\2\2\2\u01d7\u01d5\3\2\2\2\u01d7\u01d8\3\2\2\2\u01d8")
        buf.write("=\3\2\2\2\u01d9\u01d7\3\2\2\2\u01da\u0203\7\"\2\2\u01db")
        buf.write("\u0203\7#\2\2\u01dc\u0203\7$\2\2\u01dd\u01de\7%\2\2\u01de")
        buf.write("\u01df\7&\2\2\u01df\u0203\7\'\2\2\u01e0\u01e1\7(\2\2\u01e1")
        buf.write("\u0203\7\'\2\2\u01e2\u01e3\7)\2\2\u01e3\u0203\7\'\2\2")
        buf.write("\u01e4\u01e5\7%\2\2\u01e5\u01e6\7&\2\2\u01e6\u0203\7*")
        buf.write("\2\2\u01e7\u01e8\7(\2\2\u01e8\u0203\7*\2\2\u01e9\u01ea")
        buf.write("\7)\2\2\u01ea\u0203\7*\2\2\u01eb\u01ec\7%\2\2\u01ec\u01ed")
        buf.write("\7&\2\2\u01ed\u0203\7+\2\2\u01ee\u01ef\7(\2\2\u01ef\u0203")
        buf.write("\7+\2\2\u01f0\u01f1\7)\2\2\u01f1\u0203\7+\2\2\u01f2\u01f3")
        buf.write("\7%\2\2\u01f3\u01f4\7&\2\2\u01f4\u0203\7,\2\2\u01f5\u01f6")
        buf.write("\7(\2\2\u01f6\u0203\7,\2\2\u01f7\u01f8\7)\2\2\u01f8\u0203")
        buf.write("\7,\2\2\u01f9\u0203\7-\2\2\u01fa\u0203\7.\2\2\u01fb\u0203")
        buf.write("\7/\2\2\u01fc\u0203\7\60\2\2\u01fd\u0203\7\61\2\2\u01fe")
        buf.write("\u0203\7\62\2\2\u01ff\u0203\7\63\2\2\u0200\u0203\7%\2")
        buf.write("\2\u0201\u0203\7\64\2\2\u0202\u01da\3\2\2\2\u0202\u01db")
        buf.write("\3\2\2\2\u0202\u01dc\3\2\2\2\u0202\u01dd\3\2\2\2\u0202")
        buf.write("\u01e0\3\2\2\2\u0202\u01e2\3\2\2\2\u0202\u01e4\3\2\2\2")
        buf.write("\u0202\u01e7\3\2\2\2\u0202\u01e9\3\2\2\2\u0202\u01eb\3")
        buf.write("\2\2\2\u0202\u01ee\3\2\2\2\u0202\u01f0\3\2\2\2\u0202\u01f2")
        buf.write("\3\2\2\2\u0202\u01f5\3\2\2\2\u0202\u01f7\3\2\2\2\u0202")
        buf.write("\u01f9\3\2\2\2\u0202\u01fa\3\2\2\2\u0202\u01fb\3\2\2\2")
        buf.write("\u0202\u01fc\3\2\2\2\u0202\u01fd\3\2\2\2\u0202\u01fe\3")
        buf.write("\2\2\2\u0202\u01ff\3\2\2\2\u0202\u0200\3\2\2\2\u0202\u0201")
        buf.write("\3\2\2\2\u0203?\3\2\2\2\u0204\u020f\5L\'\2\u0205\u020f")
        buf.write("\5J&\2\u0206\u020f\5B\"\2\u0207\u020f\5D#\2\u0208\u020f")
        buf.write("\5F$\2\u0209\u020f\5H%\2\u020a\u020f\5P)\2\u020b\u020f")
        buf.write("\5R*\2\u020c\u020f\5T+\2\u020d\u020f\5V,\2\u020e\u0204")
        buf.write("\3\2\2\2\u020e\u0205\3\2\2\2\u020e\u0206\3\2\2\2\u020e")
        buf.write("\u0207\3\2\2\2\u020e\u0208\3\2\2\2\u020e\u0209\3\2\2\2")
        buf.write("\u020e\u020a\3\2\2\2\u020e\u020b\3\2\2\2\u020e\u020c\3")
        buf.write("\2\2\2\u020e\u020d\3\2\2\2\u020fA\3\2\2\2\u0210\u0211")
        buf.write("\5\64\33\2\u0211\u0212\t\5\2\2\u0212\u0213\5j\66\2\u0213")
        buf.write("\u0214\5Z.\2\u0214\u0215\5f\64\2\u0215C\3\2\2\2\u0216")
        buf.write("\u0217\5\64\33\2\u0217\u0218\5> \2\u0218\u0219\5\64\33")
        buf.write("\2\u0219E\3\2\2\2\u021a\u021b\5\64\33\2\u021b\u021c\5")
        buf.write("X-\2\u021c\u021d\5j\66\2\u021dG\3\2\2\2\u021e\u021f\5")
        buf.write("\64\33\2\u021f\u0220\t\5\2\2\u0220\u0221\5j\66\2\u0221")
        buf.write("\u0222\5n8\2\u0222\u0223\5f\64\2\u0223I\3\2\2\2\u0224")
        buf.write("\u0225\5\64\33\2\u0225\u0226\t\5\2\2\u0226\u0227\5j\66")
        buf.write("\2\u0227\u0228\5n8\2\u0228\u0229\5\64\33\2\u0229\u022a")
        buf.write("\t\5\2\2\u022a\u022b\5j\66\2\u022bK\3\2\2\2\u022c\u022d")
        buf.write("\5\64\33\2\u022d\u022e\5j\66\2\u022e\u022f\5\64\33\2\u022f")
        buf.write("\u0230\5n8\2\u0230\u0231\5\64\33\2\u0231\u0232\5j\66\2")
        buf.write("\u0232\u0233\5\64\33\2\u0233M\3\2\2\2\u0234\u0235\t\6")
        buf.write("\2\2\u0235O\3\2\2\2\u0236\u0237\5\64\33\2\u0237\u0238")
        buf.write("\7=\2\2\u0238\u023a\5\64\33\2\u0239\u023b\5N(\2\u023a")
        buf.write("\u0239\3\2\2\2\u023a\u023b\3\2\2\2\u023b\u023c\3\2\2\2")
        buf.write("\u023c\u0240\5j\66\2\u023d\u023e\7>\2\2\u023e\u0241\7")
        buf.write("?\2\2\u023f\u0241\7@\2\2\u0240\u023d\3\2\2\2\u0240\u023f")
        buf.write("\3\2\2\2\u0241\u0245\3\2\2\2\u0242\u0243\5Z.\2\u0243\u0244")
        buf.write("\5f\64\2\u0244\u0246\3\2\2\2\u0245\u0242\3\2\2\2\u0245")
        buf.write("\u0246\3\2\2\2\u0246Q\3\2\2\2\u0247\u0249\5\64\33\2\u0248")
        buf.write("\u024a\5N(\2\u0249\u0248\3\2\2\2\u0249\u024a\3\2\2\2\u024a")
        buf.write("\u024e\3\2\2\2\u024b\u024d\t\7\2\2\u024c\u024b\3\2\2\2")
        buf.write("\u024d\u0250\3\2\2\2\u024e\u024c\3\2\2\2\u024e\u024f\3")
        buf.write("\2\2\2\u024f\u0251\3\2\2\2\u0250\u024e\3\2\2\2\u0251\u0255")
        buf.write("\5j\66\2\u0252\u0254\t\b\2\2\u0253\u0252\3\2\2\2\u0254")
        buf.write("\u0257\3\2\2\2\u0255\u0253\3\2\2\2\u0255\u0256\3\2\2\2")
        buf.write("\u0256\u0258\3\2\2\2\u0257\u0255\3\2\2\2\u0258\u025c\5")
        buf.write("\64\33\2\u0259\u025a\5Z.\2\u025a\u025b\5f\64\2\u025b\u025d")
        buf.write("\3\2\2\2\u025c\u0259\3\2\2\2\u025c\u025d\3\2\2\2\u025d")
        buf.write("S\3\2\2\2\u025e\u025f\5\64\33\2\u025f\u0260\5j\66\2\u0260")
        buf.write("\u0261\5\64\33\2\u0261\u0262\5n8\2\u0262\u0263\5f\64\2")
        buf.write("\u0263U\3\2\2\2\u0264\u0265\7\3\2\2\u0265\u0266\7\4\2")
        buf.write("\2\u0266\u026b\5j\66\2\u0267\u0268\7\5\2\2\u0268\u026a")
        buf.write("\5\64\33\2\u0269\u0267\3\2\2\2\u026a\u026d\3\2\2\2\u026b")
        buf.write("\u0269\3\2\2\2\u026b\u026c\3\2\2\2\u026c\u026e\3\2\2\2")
        buf.write("\u026d\u026b\3\2\2\2\u026e\u026f\7\6\2\2\u026fW\3\2\2")
        buf.write("\2\u0270\u0271\t\t\2\2\u0271Y\3\2\2\2\u0272\u0273\t\n")
        buf.write("\2\2\u0273[\3\2\2\2\u0274\u0275\7N\2\2\u0275\u0276\5j")
        buf.write("\66\2\u0276\u027a\7\7\2\2\u0277\u027b\5d\63\2\u0278\u027b")
        buf.write("\5^\60\2\u0279\u027b\5:\36\2\u027a\u0277\3\2\2\2\u027a")
        buf.write("\u0278\3\2\2\2\u027a\u0279\3\2\2\2\u027b\u0284\3\2\2\2")
        buf.write("\u027c\u0280\7\23\2\2\u027d\u0281\5d\63\2\u027e\u0281")
        buf.write("\5^\60\2\u027f\u0281\5:\36\2\u0280\u027d\3\2\2\2\u0280")
        buf.write("\u027e\3\2\2\2\u0280\u027f\3\2\2\2\u0281\u0283\3\2\2\2")
        buf.write("\u0282\u027c\3\2\2\2\u0283\u0286\3\2\2\2\u0284\u0282\3")
        buf.write("\2\2\2\u0284\u0285\3\2\2\2\u0285\u0287\3\2\2\2\u0286\u0284")
        buf.write("\3\2\2\2\u0287\u0288\7\b\2\2\u0288]\3\2\2\2\u0289\u028a")
        buf.write("\7O\2\2\u028a\u028b\7\7\2\2\u028b\u028c\5`\61\2\u028c")
        buf.write("_\3\2\2\2\u028d\u028e\7\33\2\2\u028e\u0293\5j\66\2\u028f")
        buf.write("\u0290\7\5\2\2\u0290\u0292\5j\66\2\u0291\u028f\3\2\2\2")
        buf.write("\u0292\u0295\3\2\2\2\u0293\u0291\3\2\2\2\u0293\u0294\3")
        buf.write("\2\2\2\u0294a\3\2\2\2\u0295\u0293\3\2\2\2\u0296\u0297")
        buf.write("\7\\\2\2\u0297c\3\2\2\2\u0298\u0299\7P\2\2\u0299\u029a")
        buf.write("\7\7\2\2\u029a\u029f\5p9\2\u029b\u029c\7\5\2\2\u029c\u029e")
        buf.write("\5p9\2\u029d\u029b\3\2\2\2\u029e\u02a1\3\2\2\2\u029f\u029d")
        buf.write("\3\2\2\2\u029f\u02a0\3\2\2\2\u02a0e\3\2\2\2\u02a1\u029f")
        buf.write("\3\2\2\2\u02a2\u02a3\7_\2\2\u02a3g\3\2\2\2\u02a4\u02a5")
        buf.write("\7`\2\2\u02a5i\3\2\2\2\u02a6\u02a7\7b\2\2\u02a7k\3\2\2")
        buf.write("\2\u02a8\u02a9\7c\2\2\u02a9m\3\2\2\2\u02aa\u02ab\t\13")
        buf.write("\2\2\u02abo\3\2\2\2\u02ac\u02ad\7V\2\2\u02ad\u02ae\5f")
        buf.write("\64\2\u02ae\u02af\7W\2\2\u02af\u02b0\5j\66\2\u02b0\u02bc")
        buf.write("\3\2\2\2\u02b1\u02b2\7V\2\2\u02b2\u02b3\5f\64\2\u02b3")
        buf.write("\u02b4\7\7\2\2\u02b4\u02b5\5f\64\2\u02b5\u02b7\7W\2\2")
        buf.write("\u02b6\u02b8\5r:\2\u02b7\u02b6\3\2\2\2\u02b7\u02b8\3\2")
        buf.write("\2\2\u02b8\u02b9\3\2\2\2\u02b9\u02ba\5j\66\2\u02ba\u02bc")
        buf.write("\3\2\2\2\u02bb\u02ac\3\2\2\2\u02bb\u02b1\3\2\2\2\u02bc")
        buf.write("q\3\2\2\2\u02bd\u02bf\t\f\2\2\u02be\u02bd\3\2\2\2\u02bf")
        buf.write("\u02c0\3\2\2\2\u02c0\u02be\3\2\2\2\u02c0\u02c1\3\2\2\2")
        buf.write("\u02c1s\3\2\2\2Fy{\u0087\u008c\u0098\u009c\u00a0\u00a7")
        buf.write("\u00b0\u00b5\u00b9\u00bf\u00cc\u00d0\u00d9\u00dd\u00e8")
        buf.write("\u00ec\u00f5\u00fa\u00ff\u0101\u0104\u010e\u0113\u0116")
        buf.write("\u0119\u011d\u0123\u0134\u0140\u0149\u0155\u0161\u016c")
        buf.write("\u0171\u017a\u0184\u0189\u018e\u0193\u0197\u019f\u01a7")
        buf.write("\u01b0\u01b4\u01bb\u01c1\u01ce\u01d7\u0202\u020e\u023a")
        buf.write("\u0240\u0245\u0249\u024e\u0255\u025c\u026b\u027a\u0280")
        buf.write("\u0284\u0293\u029f\u02b7\u02bb\u02c0")
        return buf.getvalue()


class kismetParser ( Parser ):

    grammarFileName = "kismet.ebnv"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'pattern'", "'('", "','", "')'", "':'", 
                     "'.'", "'opposes'", "'/'", "'default'", "'trait'", 
                     "'status'", "'scalar'", "'visibility'", "'@'", "'+'", 
                     "'action'", "';'", "'costs'", "'response'", "'result'", 
                     "'location:'", "'?'", "'role'", "'extends'", "'cast'", 
                     "'<'", "'^'", "'*'", "'>'", "'tags'", "'if'", "'does not know'", 
                     "'doesnt know'", "'doesn't know'", "'did'", "'not'", 
                     "'hear'", "'didnt'", "'didn't'", "'see'", "'do'", "'receive'", 
                     "'forgets'", "'forgot'", "'forget'", "'knows'", "'hears'", 
                     "'heard'", "'saw'", "'received'", "''s'", "'s'", "'do not'", 
                     "'dont'", "'don't'", "'does not'", "'doesn't'", "'doesnt'", 
                     "'and'", "'each'", "'other'", "'eachother'", "'have'", 
                     "'has'", "'is'", "'of'", "'to'", "'with'", "'at'", 
                     "'is missing'", "'is not'", "'isn't'", "'isnt'", "'aint'", 
                     "'missing'", "'location'", "'each_turn'", "'supports'", 
                     "'='", "'=='", "'<='", "'>='", "'!='", "'['", "']'", 
                     "'_'", "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "'-'" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "MINUS", "PLUS", 
                      "EQUALS", "RANDOM_TEXT", "WS", "LINE_COMMENT", "NUMBER", 
                      "POSITIVE_NUMBER", "NEG", "NAME", "VAR" ]

    RULE_world = 0
    RULE_pattern = 1
    RULE_opposition = 2
    RULE_trait = 3
    RULE_default = 4
    RULE_trait_type = 5
    RULE_is_num = 6
    RULE_propensity = 7
    RULE_propensity_name = 8
    RULE_modifier = 9
    RULE_goto = 10
    RULE_valence = 11
    RULE_action = 12
    RULE_cost = 13
    RULE_response = 14
    RULE_add = 15
    RULE_change = 16
    RULE_visibility = 17
    RULE_action_location = 18
    RULE_loc = 19
    RULE_locWildCard = 20
    RULE_action_item = 21
    RULE_role = 22
    RULE_extension = 23
    RULE_cast_name = 24
    RULE_arg = 25
    RULE_sub = 26
    RULE_arg_type = 27
    RULE_tags = 28
    RULE_comparison = 29
    RULE_knowledge = 30
    RULE_condition = 31
    RULE_cond8 = 32
    RULE_cond3 = 33
    RULE_cond1 = 34
    RULE_cond4 = 35
    RULE_cond9 = 36
    RULE_cond10 = 37
    RULE_inversion = 38
    RULE_cond5 = 39
    RULE_cond6 = 40
    RULE_cond7 = 41
    RULE_condpattern = 42
    RULE_tag_compare = 43
    RULE_operator = 44
    RULE_location = 45
    RULE_each_turn = 46
    RULE_cast = 47
    RULE_random_text = 48
    RULE_supports = 49
    RULE_num = 50
    RULE_pos_num = 51
    RULE_name = 52
    RULE_var = 53
    RULE_comparator = 54
    RULE_num_choice = 55
    RULE_pdf = 56

    ruleNames =  [ "world", "pattern", "opposition", "trait", "default", 
                   "trait_type", "is_num", "propensity", "propensity_name", 
                   "modifier", "goto", "valence", "action", "cost", "response", 
                   "add", "change", "visibility", "action_location", "loc", 
                   "locWildCard", "action_item", "role", "extension", "cast_name", 
                   "arg", "sub", "arg_type", "tags", "comparison", "knowledge", 
                   "condition", "cond8", "cond3", "cond1", "cond4", "cond9", 
                   "cond10", "inversion", "cond5", "cond6", "cond7", "condpattern", 
                   "tag_compare", "operator", "location", "each_turn", "cast", 
                   "random_text", "supports", "num", "pos_num", "name", 
                   "var", "comparator", "num_choice", "pdf" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    T__2=3
    T__3=4
    T__4=5
    T__5=6
    T__6=7
    T__7=8
    T__8=9
    T__9=10
    T__10=11
    T__11=12
    T__12=13
    T__13=14
    T__14=15
    T__15=16
    T__16=17
    T__17=18
    T__18=19
    T__19=20
    T__20=21
    T__21=22
    T__22=23
    T__23=24
    T__24=25
    T__25=26
    T__26=27
    T__27=28
    T__28=29
    T__29=30
    T__30=31
    T__31=32
    T__32=33
    T__33=34
    T__34=35
    T__35=36
    T__36=37
    T__37=38
    T__38=39
    T__39=40
    T__40=41
    T__41=42
    T__42=43
    T__43=44
    T__44=45
    T__45=46
    T__46=47
    T__47=48
    T__48=49
    T__49=50
    T__50=51
    T__51=52
    T__52=53
    T__53=54
    T__54=55
    T__55=56
    T__56=57
    T__57=58
    T__58=59
    T__59=60
    T__60=61
    T__61=62
    T__62=63
    T__63=64
    T__64=65
    T__65=66
    T__66=67
    T__67=68
    T__68=69
    T__69=70
    T__70=71
    T__71=72
    T__72=73
    T__73=74
    T__74=75
    T__75=76
    T__76=77
    T__77=78
    T__78=79
    T__79=80
    T__80=81
    T__81=82
    T__82=83
    T__83=84
    T__84=85
    T__85=86
    MINUS=87
    PLUS=88
    EQUALS=89
    RANDOM_TEXT=90
    WS=91
    LINE_COMMENT=92
    NUMBER=93
    POSITIVE_NUMBER=94
    NEG=95
    NAME=96
    VAR=97

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.7.2")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class WorldContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOF(self):
            return self.getToken(kismetParser.EOF, 0)

        def location(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.LocationContext)
            else:
                return self.getTypedRuleContext(kismetParser.LocationContext,i)


        def role(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.RoleContext)
            else:
                return self.getTypedRuleContext(kismetParser.RoleContext,i)


        def action(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.ActionContext)
            else:
                return self.getTypedRuleContext(kismetParser.ActionContext,i)


        def trait(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.TraitContext)
            else:
                return self.getTypedRuleContext(kismetParser.TraitContext,i)


        def pattern(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.PatternContext)
            else:
                return self.getTypedRuleContext(kismetParser.PatternContext,i)


        def getRuleIndex(self):
            return kismetParser.RULE_world

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWorld" ):
                listener.enterWorld(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWorld" ):
                listener.exitWorld(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWorld" ):
                return visitor.visitWorld(self)
            else:
                return visitor.visitChildren(self)




    def world(self):

        localctx = kismetParser.WorldContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_world)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 119 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 119
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [kismetParser.T__75]:
                    self.state = 114
                    self.location()
                    pass
                elif token in [kismetParser.T__22]:
                    self.state = 115
                    self.role()
                    pass
                elif token in [kismetParser.T__15, kismetParser.T__18]:
                    self.state = 116
                    self.action()
                    pass
                elif token in [kismetParser.T__8, kismetParser.T__9, kismetParser.T__10]:
                    self.state = 117
                    self.trait()
                    pass
                elif token in [kismetParser.T__0]:
                    self.state = 118
                    self.pattern()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 121 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << kismetParser.T__0) | (1 << kismetParser.T__8) | (1 << kismetParser.T__9) | (1 << kismetParser.T__10) | (1 << kismetParser.T__15) | (1 << kismetParser.T__18) | (1 << kismetParser.T__22))) != 0) or _la==kismetParser.T__75):
                    break

            self.state = 123
            self.match(kismetParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PatternContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def name(self):
            return self.getTypedRuleContext(kismetParser.NameContext,0)


        def arg(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.ArgContext)
            else:
                return self.getTypedRuleContext(kismetParser.ArgContext,i)


        def comparison(self):
            return self.getTypedRuleContext(kismetParser.ComparisonContext,0)


        def random_text(self):
            return self.getTypedRuleContext(kismetParser.Random_textContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_pattern

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPattern" ):
                listener.enterPattern(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPattern" ):
                listener.exitPattern(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPattern" ):
                return visitor.visitPattern(self)
            else:
                return visitor.visitChildren(self)




    def pattern(self):

        localctx = kismetParser.PatternContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_pattern)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 125
            self.match(kismetParser.T__0)
            self.state = 126
            self.name()
            self.state = 127
            self.match(kismetParser.T__1)
            self.state = 128
            self.arg()
            self.state = 133
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__2:
                self.state = 129
                self.match(kismetParser.T__2)
                self.state = 130
                self.arg()
                self.state = 135
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 136
            self.match(kismetParser.T__3)
            self.state = 138
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==kismetParser.RANDOM_TEXT:
                self.state = 137
                self.random_text()


            self.state = 140
            self.match(kismetParser.T__4)
            self.state = 141
            self.comparison()
            self.state = 142
            self.match(kismetParser.T__5)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OppositionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.NameContext)
            else:
                return self.getTypedRuleContext(kismetParser.NameContext,i)


        def getRuleIndex(self):
            return kismetParser.RULE_opposition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOpposition" ):
                listener.enterOpposition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOpposition" ):
                listener.exitOpposition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOpposition" ):
                return visitor.visitOpposition(self)
            else:
                return visitor.visitChildren(self)




    def opposition(self):

        localctx = kismetParser.OppositionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_opposition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 144
            self.match(kismetParser.T__6)
            self.state = 145
            self.name()
            self.state = 150
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__7:
                self.state = 146
                self.match(kismetParser.T__7)
                self.state = 147
                self.name()
                self.state = 152
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraitContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def trait_type(self):
            return self.getTypedRuleContext(kismetParser.Trait_typeContext,0)


        def name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.NameContext)
            else:
                return self.getTypedRuleContext(kismetParser.NameContext,i)


        def arg(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.ArgContext)
            else:
                return self.getTypedRuleContext(kismetParser.ArgContext,i)


        def default(self):
            return self.getTypedRuleContext(kismetParser.DefaultContext,0)


        def is_num(self):
            return self.getTypedRuleContext(kismetParser.Is_numContext,0)


        def opposition(self):
            return self.getTypedRuleContext(kismetParser.OppositionContext,0)


        def propensity(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.PropensityContext)
            else:
                return self.getTypedRuleContext(kismetParser.PropensityContext,i)


        def getRuleIndex(self):
            return kismetParser.RULE_trait

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTrait" ):
                listener.enterTrait(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTrait" ):
                listener.exitTrait(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTrait" ):
                return visitor.visitTrait(self)
            else:
                return visitor.visitChildren(self)




    def trait(self):

        localctx = kismetParser.TraitContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_trait)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 154
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==kismetParser.T__8:
                self.state = 153
                self.default()


            self.state = 156
            self.trait_type()
            self.state = 158
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==kismetParser.T__11:
                self.state = 157
                self.is_num()


            self.state = 160
            self.name()
            self.state = 165
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__7:
                self.state = 161
                self.match(kismetParser.T__7)
                self.state = 162
                self.name()
                self.state = 167
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 168
            self.match(kismetParser.T__1)
            self.state = 169
            self.arg()
            self.state = 174
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__2:
                self.state = 170
                self.match(kismetParser.T__2)
                self.state = 171
                self.arg()
                self.state = 176
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 177
            self.match(kismetParser.T__3)
            self.state = 179
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==kismetParser.T__6:
                self.state = 178
                self.opposition()


            self.state = 181
            self.match(kismetParser.T__4)
            self.state = 183
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==kismetParser.T__14 or _la==kismetParser.NEG:
                self.state = 182
                self.propensity()


            self.state = 189
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__2:
                self.state = 185
                self.match(kismetParser.T__2)
                self.state = 186
                self.propensity()
                self.state = 191
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 192
            self.match(kismetParser.T__5)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DefaultContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return kismetParser.RULE_default

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDefault" ):
                listener.enterDefault(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDefault" ):
                listener.exitDefault(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDefault" ):
                return visitor.visitDefault(self)
            else:
                return visitor.visitChildren(self)




    def default(self):

        localctx = kismetParser.DefaultContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_default)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 194
            self.match(kismetParser.T__8)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Trait_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return kismetParser.RULE_trait_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTrait_type" ):
                listener.enterTrait_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTrait_type" ):
                listener.exitTrait_type(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTrait_type" ):
                return visitor.visitTrait_type(self)
            else:
                return visitor.visitChildren(self)




    def trait_type(self):

        localctx = kismetParser.Trait_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_trait_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 196
            _la = self._input.LA(1)
            if not(_la==kismetParser.T__9 or _la==kismetParser.T__10):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Is_numContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return kismetParser.RULE_is_num

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIs_num" ):
                listener.enterIs_num(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIs_num" ):
                listener.exitIs_num(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIs_num" ):
                return visitor.visitIs_num(self)
            else:
                return visitor.visitChildren(self)




    def is_num(self):

        localctx = kismetParser.Is_numContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_is_num)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 198
            self.match(kismetParser.T__11)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PropensityContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def modifier(self):
            return self.getTypedRuleContext(kismetParser.ModifierContext,0)


        def goto(self):
            return self.getTypedRuleContext(kismetParser.GotoContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_propensity

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPropensity" ):
                listener.enterPropensity(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPropensity" ):
                listener.exitPropensity(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPropensity" ):
                return visitor.visitPropensity(self)
            else:
                return visitor.visitChildren(self)




    def propensity(self):

        localctx = kismetParser.PropensityContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_propensity)
        try:
            self.state = 202
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,12,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 200
                self.modifier()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 201
                self.goto()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Propensity_nameContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def name(self):
            return self.getTypedRuleContext(kismetParser.NameContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_propensity_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPropensity_name" ):
                listener.enterPropensity_name(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPropensity_name" ):
                listener.exitPropensity_name(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPropensity_name" ):
                return visitor.visitPropensity_name(self)
            else:
                return visitor.visitChildren(self)




    def propensity_name(self):

        localctx = kismetParser.Propensity_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_propensity_name)
        try:
            self.state = 206
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [kismetParser.T__12]:
                self.enterOuterAlt(localctx, 1)
                self.state = 204
                self.match(kismetParser.T__12)
                pass
            elif token in [kismetParser.NAME]:
                self.enterOuterAlt(localctx, 2)
                self.state = 205
                self.name()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ModifierContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def valence(self):
            return self.getTypedRuleContext(kismetParser.ValenceContext,0)


        def propensity_name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.Propensity_nameContext)
            else:
                return self.getTypedRuleContext(kismetParser.Propensity_nameContext,i)


        def comparison(self):
            return self.getTypedRuleContext(kismetParser.ComparisonContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_modifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterModifier" ):
                listener.enterModifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitModifier" ):
                listener.exitModifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitModifier" ):
                return visitor.visitModifier(self)
            else:
                return visitor.visitChildren(self)




    def modifier(self):

        localctx = kismetParser.ModifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_modifier)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 208
            self.valence()
            self.state = 209
            self.match(kismetParser.T__1)
            self.state = 210
            self.propensity_name()
            self.state = 215
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__2:
                self.state = 211
                self.match(kismetParser.T__2)
                self.state = 212
                self.propensity_name()
                self.state = 217
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 219
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==kismetParser.T__30:
                self.state = 218
                self.comparison()


            self.state = 221
            self.match(kismetParser.T__3)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GotoContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def valence(self):
            return self.getTypedRuleContext(kismetParser.ValenceContext,0)


        def name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.NameContext)
            else:
                return self.getTypedRuleContext(kismetParser.NameContext,i)


        def comparison(self):
            return self.getTypedRuleContext(kismetParser.ComparisonContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_goto

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGoto" ):
                listener.enterGoto(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGoto" ):
                listener.exitGoto(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGoto" ):
                return visitor.visitGoto(self)
            else:
                return visitor.visitChildren(self)




    def goto(self):

        localctx = kismetParser.GotoContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_goto)
        self._la = 0 # Token type
        try:
            self.state = 243
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,18,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 223
                self.valence()
                self.state = 224
                self.match(kismetParser.T__13)
                self.state = 225
                self.name()
                self.state = 230
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==kismetParser.T__2:
                    self.state = 226
                    self.match(kismetParser.T__2)
                    self.state = 227
                    self.name()
                    self.state = 232
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 234
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==kismetParser.T__30:
                    self.state = 233
                    self.comparison()


                self.state = 236
                self.match(kismetParser.T__13)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 238
                self.valence()
                self.state = 239
                self.match(kismetParser.T__13)
                self.state = 240
                self.comparison()
                self.state = 241
                self.match(kismetParser.T__13)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ValenceContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NEG(self, i:int=None):
            if i is None:
                return self.getTokens(kismetParser.NEG)
            else:
                return self.getToken(kismetParser.NEG, i)

        def getRuleIndex(self):
            return kismetParser.RULE_valence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterValence" ):
                listener.enterValence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitValence" ):
                listener.exitValence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitValence" ):
                return visitor.visitValence(self)
            else:
                return visitor.visitChildren(self)




    def valence(self):

        localctx = kismetParser.ValenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_valence)
        self._la = 0 # Token type
        try:
            self.state = 255
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [kismetParser.T__14]:
                self.enterOuterAlt(localctx, 1)
                self.state = 246 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 245
                    self.match(kismetParser.T__14)
                    self.state = 248 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==kismetParser.T__14):
                        break

                pass
            elif token in [kismetParser.NEG]:
                self.enterOuterAlt(localctx, 2)
                self.state = 251 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 250
                    self.match(kismetParser.NEG)
                    self.state = 253 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==kismetParser.NEG):
                        break

                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ActionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def name(self):
            return self.getTypedRuleContext(kismetParser.NameContext,0)


        def arg(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.ArgContext)
            else:
                return self.getTypedRuleContext(kismetParser.ArgContext,i)


        def response(self):
            return self.getTypedRuleContext(kismetParser.ResponseContext,0)


        def cost(self):
            return self.getTypedRuleContext(kismetParser.CostContext,0)


        def extension(self):
            return self.getTypedRuleContext(kismetParser.ExtensionContext,0)


        def random_text(self):
            return self.getTypedRuleContext(kismetParser.Random_textContext,0)


        def action_item(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.Action_itemContext)
            else:
                return self.getTypedRuleContext(kismetParser.Action_itemContext,i)


        def getRuleIndex(self):
            return kismetParser.RULE_action

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAction" ):
                listener.enterAction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAction" ):
                listener.exitAction(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAction" ):
                return visitor.visitAction(self)
            else:
                return visitor.visitChildren(self)




    def action(self):

        localctx = kismetParser.ActionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_action)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 258
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==kismetParser.T__18:
                self.state = 257
                self.response()


            self.state = 260
            self.match(kismetParser.T__15)
            self.state = 261
            self.name()
            self.state = 262
            self.match(kismetParser.T__1)
            self.state = 263
            self.arg()
            self.state = 268
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__2:
                self.state = 264
                self.match(kismetParser.T__2)
                self.state = 265
                self.arg()
                self.state = 270
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 271
            self.match(kismetParser.T__3)
            self.state = 273
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==kismetParser.T__17:
                self.state = 272
                self.cost()


            self.state = 276
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==kismetParser.T__23:
                self.state = 275
                self.extension()


            self.state = 279
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==kismetParser.RANDOM_TEXT:
                self.state = 278
                self.random_text()


            self.state = 281
            self.match(kismetParser.T__4)
            self.state = 283
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << kismetParser.T__12) | (1 << kismetParser.T__19) | (1 << kismetParser.T__20) | (1 << kismetParser.T__29) | (1 << kismetParser.T__30))) != 0):
                self.state = 282
                self.action_item()


            self.state = 289
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__16:
                self.state = 285
                self.match(kismetParser.T__16)

                self.state = 286
                self.action_item()
                self.state = 291
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 292
            self.match(kismetParser.T__5)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CostContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def num(self):
            return self.getTypedRuleContext(kismetParser.NumContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_cost

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCost" ):
                listener.enterCost(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCost" ):
                listener.exitCost(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCost" ):
                return visitor.visitCost(self)
            else:
                return visitor.visitChildren(self)




    def cost(self):

        localctx = kismetParser.CostContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_cost)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 294
            self.match(kismetParser.T__17)
            self.state = 295
            self.num()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ResponseContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return kismetParser.RULE_response

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterResponse" ):
                listener.enterResponse(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitResponse" ):
                listener.exitResponse(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitResponse" ):
                return visitor.visitResponse(self)
            else:
                return visitor.visitChildren(self)




    def response(self):

        localctx = kismetParser.ResponseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_response)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 297
            self.match(kismetParser.T__18)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AddContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def change(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.ChangeContext)
            else:
                return self.getTypedRuleContext(kismetParser.ChangeContext,i)


        def getRuleIndex(self):
            return kismetParser.RULE_add

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAdd" ):
                listener.enterAdd(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAdd" ):
                listener.exitAdd(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAdd" ):
                return visitor.visitAdd(self)
            else:
                return visitor.visitChildren(self)




    def add(self):

        localctx = kismetParser.AddContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_add)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 299
            self.match(kismetParser.T__19)
            self.state = 300
            self.match(kismetParser.T__4)
            self.state = 301
            self.change()
            self.state = 306
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__2:
                self.state = 302
                self.match(kismetParser.T__2)
                self.state = 303
                self.change()
                self.state = 308
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ChangeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def condition(self):
            return self.getTypedRuleContext(kismetParser.ConditionContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_change

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterChange" ):
                listener.enterChange(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitChange" ):
                listener.exitChange(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitChange" ):
                return visitor.visitChange(self)
            else:
                return visitor.visitChildren(self)




    def change(self):

        localctx = kismetParser.ChangeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_change)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 309
            self.condition()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VisibilityContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def valence(self):
            return self.getTypedRuleContext(kismetParser.ValenceContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_visibility

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVisibility" ):
                listener.enterVisibility(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVisibility" ):
                listener.exitVisibility(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVisibility" ):
                return visitor.visitVisibility(self)
            else:
                return visitor.visitChildren(self)




    def visibility(self):

        localctx = kismetParser.VisibilityContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_visibility)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 311
            self.match(kismetParser.T__12)
            self.state = 312
            self.valence()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Action_locationContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def loc(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.LocContext)
            else:
                return self.getTypedRuleContext(kismetParser.LocContext,i)


        def getRuleIndex(self):
            return kismetParser.RULE_action_location

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAction_location" ):
                listener.enterAction_location(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAction_location" ):
                listener.exitAction_location(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAction_location" ):
                return visitor.visitAction_location(self)
            else:
                return visitor.visitChildren(self)




    def action_location(self):

        localctx = kismetParser.Action_locationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_action_location)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 314
            self.match(kismetParser.T__20)
            self.state = 316 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 315
                self.loc()
                self.state = 318 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==kismetParser.T__1 or _la==kismetParser.T__21 or _la==kismetParser.NAME or _la==kismetParser.VAR):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LocContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def var(self):
            return self.getTypedRuleContext(kismetParser.VarContext,0)


        def arg(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.ArgContext)
            else:
                return self.getTypedRuleContext(kismetParser.ArgContext,i)


        def name(self):
            return self.getTypedRuleContext(kismetParser.NameContext,0)


        def locWildCard(self):
            return self.getTypedRuleContext(kismetParser.LocWildCardContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_loc

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLoc" ):
                listener.enterLoc(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLoc" ):
                listener.exitLoc(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLoc" ):
                return visitor.visitLoc(self)
            else:
                return visitor.visitChildren(self)




    def loc(self):

        localctx = kismetParser.LocContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_loc)
        self._la = 0 # Token type
        try:
            self.state = 367
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [kismetParser.VAR]:
                self.enterOuterAlt(localctx, 1)
                self.state = 320
                self.var()
                self.state = 321
                self.match(kismetParser.T__1)
                self.state = 322
                self.arg()
                self.state = 327
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==kismetParser.T__2:
                    self.state = 323
                    self.match(kismetParser.T__2)
                    self.state = 324
                    self.arg()
                    self.state = 329
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 330
                self.match(kismetParser.T__3)
                pass
            elif token in [kismetParser.NAME]:
                self.enterOuterAlt(localctx, 2)
                self.state = 332
                self.name()
                self.state = 333
                self.match(kismetParser.T__1)
                self.state = 334
                self.arg()
                self.state = 339
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==kismetParser.T__2:
                    self.state = 335
                    self.match(kismetParser.T__2)
                    self.state = 336
                    self.arg()
                    self.state = 341
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 342
                self.match(kismetParser.T__3)
                pass
            elif token in [kismetParser.T__21]:
                self.enterOuterAlt(localctx, 3)
                self.state = 344
                self.locWildCard()
                self.state = 345
                self.match(kismetParser.T__1)
                self.state = 346
                self.arg()
                self.state = 351
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==kismetParser.T__2:
                    self.state = 347
                    self.match(kismetParser.T__2)
                    self.state = 348
                    self.arg()
                    self.state = 353
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 354
                self.match(kismetParser.T__3)
                pass
            elif token in [kismetParser.T__1]:
                self.enterOuterAlt(localctx, 4)
                self.state = 356
                self.match(kismetParser.T__1)
                self.state = 357
                self.arg()
                self.state = 362
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==kismetParser.T__2:
                    self.state = 358
                    self.match(kismetParser.T__2)
                    self.state = 359
                    self.arg()
                    self.state = 364
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 365
                self.match(kismetParser.T__3)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LocWildCardContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return kismetParser.RULE_locWildCard

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLocWildCard" ):
                listener.enterLocWildCard(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLocWildCard" ):
                listener.exitLocWildCard(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLocWildCard" ):
                return visitor.visitLocWildCard(self)
            else:
                return visitor.visitChildren(self)




    def locWildCard(self):

        localctx = kismetParser.LocWildCardContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_locWildCard)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 369
            self.match(kismetParser.T__21)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Action_itemContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def tags(self):
            return self.getTypedRuleContext(kismetParser.TagsContext,0)


        def comparison(self):
            return self.getTypedRuleContext(kismetParser.ComparisonContext,0)


        def action_location(self):
            return self.getTypedRuleContext(kismetParser.Action_locationContext,0)


        def add(self):
            return self.getTypedRuleContext(kismetParser.AddContext,0)


        def visibility(self):
            return self.getTypedRuleContext(kismetParser.VisibilityContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_action_item

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAction_item" ):
                listener.enterAction_item(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAction_item" ):
                listener.exitAction_item(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAction_item" ):
                return visitor.visitAction_item(self)
            else:
                return visitor.visitChildren(self)




    def action_item(self):

        localctx = kismetParser.Action_itemContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_action_item)
        try:
            self.state = 376
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [kismetParser.T__29]:
                self.enterOuterAlt(localctx, 1)
                self.state = 371
                self.tags()
                pass
            elif token in [kismetParser.T__30]:
                self.enterOuterAlt(localctx, 2)
                self.state = 372
                self.comparison()
                pass
            elif token in [kismetParser.T__20]:
                self.enterOuterAlt(localctx, 3)
                self.state = 373
                self.action_location()
                pass
            elif token in [kismetParser.T__19]:
                self.enterOuterAlt(localctx, 4)
                self.state = 374
                self.add()
                pass
            elif token in [kismetParser.T__12]:
                self.enterOuterAlt(localctx, 5)
                self.state = 375
                self.visibility()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RoleContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def name(self):
            return self.getTypedRuleContext(kismetParser.NameContext,0)


        def arg(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.ArgContext)
            else:
                return self.getTypedRuleContext(kismetParser.ArgContext,i)


        def tags(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.TagsContext)
            else:
                return self.getTypedRuleContext(kismetParser.TagsContext,i)


        def comparison(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.ComparisonContext)
            else:
                return self.getTypedRuleContext(kismetParser.ComparisonContext,i)


        def extension(self):
            return self.getTypedRuleContext(kismetParser.ExtensionContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_role

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRole" ):
                listener.enterRole(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRole" ):
                listener.exitRole(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRole" ):
                return visitor.visitRole(self)
            else:
                return visitor.visitChildren(self)




    def role(self):

        localctx = kismetParser.RoleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_role)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 378
            self.match(kismetParser.T__22)
            self.state = 379
            self.name()
            self.state = 380
            self.match(kismetParser.T__1)
            self.state = 381
            self.arg()
            self.state = 386
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__2:
                self.state = 382
                self.match(kismetParser.T__2)
                self.state = 383
                self.arg()
                self.state = 388
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 389
            self.match(kismetParser.T__3)
            self.state = 391
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==kismetParser.T__23:
                self.state = 390
                self.extension()


            self.state = 393
            self.match(kismetParser.T__4)
            self.state = 396
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [kismetParser.T__29]:
                self.state = 394
                self.tags()
                pass
            elif token in [kismetParser.T__30]:
                self.state = 395
                self.comparison()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 405
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__16:
                self.state = 398
                self.match(kismetParser.T__16)
                self.state = 401
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [kismetParser.T__29]:
                    self.state = 399
                    self.tags()
                    pass
                elif token in [kismetParser.T__30]:
                    self.state = 400
                    self.comparison()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 407
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 408
            self.match(kismetParser.T__5)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExtensionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def arg(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.ArgContext)
            else:
                return self.getTypedRuleContext(kismetParser.ArgContext,i)


        def cast_name(self):
            return self.getTypedRuleContext(kismetParser.Cast_nameContext,0)


        def name(self):
            return self.getTypedRuleContext(kismetParser.NameContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_extension

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExtension" ):
                listener.enterExtension(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExtension" ):
                listener.exitExtension(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExtension" ):
                return visitor.visitExtension(self)
            else:
                return visitor.visitChildren(self)




    def extension(self):

        localctx = kismetParser.ExtensionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_extension)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 410
            self.match(kismetParser.T__23)
            self.state = 413
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [kismetParser.T__24]:
                self.state = 411
                self.cast_name()
                pass
            elif token in [kismetParser.NAME]:
                self.state = 412
                self.name()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 415
            self.match(kismetParser.T__1)
            self.state = 416
            self.arg()
            self.state = 421
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__2:
                self.state = 417
                self.match(kismetParser.T__2)
                self.state = 418
                self.arg()
                self.state = 423
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 424
            self.match(kismetParser.T__3)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Cast_nameContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def name(self):
            return self.getTypedRuleContext(kismetParser.NameContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_cast_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCast_name" ):
                listener.enterCast_name(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCast_name" ):
                listener.exitCast_name(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCast_name" ):
                return visitor.visitCast_name(self)
            else:
                return visitor.visitChildren(self)




    def cast_name(self):

        localctx = kismetParser.Cast_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_cast_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 426
            self.match(kismetParser.T__24)
            self.state = 427
            self.name()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ArgContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def var(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.VarContext)
            else:
                return self.getTypedRuleContext(kismetParser.VarContext,i)


        def arg_type(self):
            return self.getTypedRuleContext(kismetParser.Arg_typeContext,0)


        def sub(self):
            return self.getTypedRuleContext(kismetParser.SubContext,0)


        def name(self):
            return self.getTypedRuleContext(kismetParser.NameContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_arg

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArg" ):
                listener.enterArg(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArg" ):
                listener.exitArg(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitArg" ):
                return visitor.visitArg(self)
            else:
                return visitor.visitChildren(self)




    def arg(self):

        localctx = kismetParser.ArgContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_arg)
        self._la = 0 # Token type
        try:
            self.state = 447
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,47,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 430
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << kismetParser.T__13) | (1 << kismetParser.T__25) | (1 << kismetParser.T__26) | (1 << kismetParser.T__27) | (1 << kismetParser.T__28))) != 0):
                    self.state = 429
                    self.arg_type()


                self.state = 432
                self.var()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 434
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << kismetParser.T__13) | (1 << kismetParser.T__25) | (1 << kismetParser.T__26) | (1 << kismetParser.T__27) | (1 << kismetParser.T__28))) != 0):
                    self.state = 433
                    self.arg_type()


                self.state = 436
                self.var()
                self.state = 437
                self.sub()
                self.state = 438
                self.name()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 441
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << kismetParser.T__13) | (1 << kismetParser.T__25) | (1 << kismetParser.T__26) | (1 << kismetParser.T__27) | (1 << kismetParser.T__28))) != 0):
                    self.state = 440
                    self.arg_type()


                self.state = 443
                self.var()
                self.state = 444
                self.sub()
                self.state = 445
                self.var()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SubContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return kismetParser.RULE_sub

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSub" ):
                listener.enterSub(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSub" ):
                listener.exitSub(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSub" ):
                return visitor.visitSub(self)
            else:
                return visitor.visitChildren(self)




    def sub(self):

        localctx = kismetParser.SubContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_sub)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 449
            _la = self._input.LA(1)
            if not(_la==kismetParser.T__4 or _la==kismetParser.T__5):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Arg_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return kismetParser.RULE_arg_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArg_type" ):
                listener.enterArg_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArg_type" ):
                listener.exitArg_type(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitArg_type" ):
                return visitor.visitArg_type(self)
            else:
                return visitor.visitChildren(self)




    def arg_type(self):

        localctx = kismetParser.Arg_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_arg_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 451
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << kismetParser.T__13) | (1 << kismetParser.T__25) | (1 << kismetParser.T__26) | (1 << kismetParser.T__27) | (1 << kismetParser.T__28))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TagsContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.NameContext)
            else:
                return self.getTypedRuleContext(kismetParser.NameContext,i)


        def getRuleIndex(self):
            return kismetParser.RULE_tags

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTags" ):
                listener.enterTags(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTags" ):
                listener.exitTags(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTags" ):
                return visitor.visitTags(self)
            else:
                return visitor.visitChildren(self)




    def tags(self):

        localctx = kismetParser.TagsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_tags)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 453
            self.match(kismetParser.T__29)
            self.state = 454
            self.match(kismetParser.T__4)
            self.state = 455
            self.name()
            self.state = 460
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__2:
                self.state = 456
                self.match(kismetParser.T__2)
                self.state = 457
                self.name()
                self.state = 462
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ComparisonContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def condition(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.ConditionContext)
            else:
                return self.getTypedRuleContext(kismetParser.ConditionContext,i)


        def getRuleIndex(self):
            return kismetParser.RULE_comparison

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterComparison" ):
                listener.enterComparison(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitComparison" ):
                listener.exitComparison(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitComparison" ):
                return visitor.visitComparison(self)
            else:
                return visitor.visitChildren(self)




    def comparison(self):

        localctx = kismetParser.ComparisonContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_comparison)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 463
            self.match(kismetParser.T__30)
            self.state = 464
            self.condition()
            self.state = 469
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__2:
                self.state = 465
                self.match(kismetParser.T__2)
                self.state = 466
                self.condition()
                self.state = 471
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class KnowledgeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return kismetParser.RULE_knowledge

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterKnowledge" ):
                listener.enterKnowledge(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitKnowledge" ):
                listener.exitKnowledge(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitKnowledge" ):
                return visitor.visitKnowledge(self)
            else:
                return visitor.visitChildren(self)




    def knowledge(self):

        localctx = kismetParser.KnowledgeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_knowledge)
        try:
            self.state = 512
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,50,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 472
                self.match(kismetParser.T__31)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 473
                self.match(kismetParser.T__32)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 474
                self.match(kismetParser.T__33)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 475
                self.match(kismetParser.T__34)
                self.state = 476
                self.match(kismetParser.T__35)
                self.state = 477
                self.match(kismetParser.T__36)
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 478
                self.match(kismetParser.T__37)
                self.state = 479
                self.match(kismetParser.T__36)
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 480
                self.match(kismetParser.T__38)
                self.state = 481
                self.match(kismetParser.T__36)
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 482
                self.match(kismetParser.T__34)
                self.state = 483
                self.match(kismetParser.T__35)
                self.state = 484
                self.match(kismetParser.T__39)
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 485
                self.match(kismetParser.T__37)
                self.state = 486
                self.match(kismetParser.T__39)
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 487
                self.match(kismetParser.T__38)
                self.state = 488
                self.match(kismetParser.T__39)
                pass

            elif la_ == 10:
                self.enterOuterAlt(localctx, 10)
                self.state = 489
                self.match(kismetParser.T__34)
                self.state = 490
                self.match(kismetParser.T__35)
                self.state = 491
                self.match(kismetParser.T__40)
                pass

            elif la_ == 11:
                self.enterOuterAlt(localctx, 11)
                self.state = 492
                self.match(kismetParser.T__37)
                self.state = 493
                self.match(kismetParser.T__40)
                pass

            elif la_ == 12:
                self.enterOuterAlt(localctx, 12)
                self.state = 494
                self.match(kismetParser.T__38)
                self.state = 495
                self.match(kismetParser.T__40)
                pass

            elif la_ == 13:
                self.enterOuterAlt(localctx, 13)
                self.state = 496
                self.match(kismetParser.T__34)
                self.state = 497
                self.match(kismetParser.T__35)
                self.state = 498
                self.match(kismetParser.T__41)
                pass

            elif la_ == 14:
                self.enterOuterAlt(localctx, 14)
                self.state = 499
                self.match(kismetParser.T__37)
                self.state = 500
                self.match(kismetParser.T__41)
                pass

            elif la_ == 15:
                self.enterOuterAlt(localctx, 15)
                self.state = 501
                self.match(kismetParser.T__38)
                self.state = 502
                self.match(kismetParser.T__41)
                pass

            elif la_ == 16:
                self.enterOuterAlt(localctx, 16)
                self.state = 503
                self.match(kismetParser.T__42)
                pass

            elif la_ == 17:
                self.enterOuterAlt(localctx, 17)
                self.state = 504
                self.match(kismetParser.T__43)
                pass

            elif la_ == 18:
                self.enterOuterAlt(localctx, 18)
                self.state = 505
                self.match(kismetParser.T__44)
                pass

            elif la_ == 19:
                self.enterOuterAlt(localctx, 19)
                self.state = 506
                self.match(kismetParser.T__45)
                pass

            elif la_ == 20:
                self.enterOuterAlt(localctx, 20)
                self.state = 507
                self.match(kismetParser.T__46)
                pass

            elif la_ == 21:
                self.enterOuterAlt(localctx, 21)
                self.state = 508
                self.match(kismetParser.T__47)
                pass

            elif la_ == 22:
                self.enterOuterAlt(localctx, 22)
                self.state = 509
                self.match(kismetParser.T__48)
                pass

            elif la_ == 23:
                self.enterOuterAlt(localctx, 23)
                self.state = 510
                self.match(kismetParser.T__34)
                pass

            elif la_ == 24:
                self.enterOuterAlt(localctx, 24)
                self.state = 511
                self.match(kismetParser.T__49)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConditionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def cond10(self):
            return self.getTypedRuleContext(kismetParser.Cond10Context,0)


        def cond9(self):
            return self.getTypedRuleContext(kismetParser.Cond9Context,0)


        def cond8(self):
            return self.getTypedRuleContext(kismetParser.Cond8Context,0)


        def cond3(self):
            return self.getTypedRuleContext(kismetParser.Cond3Context,0)


        def cond1(self):
            return self.getTypedRuleContext(kismetParser.Cond1Context,0)


        def cond4(self):
            return self.getTypedRuleContext(kismetParser.Cond4Context,0)


        def cond5(self):
            return self.getTypedRuleContext(kismetParser.Cond5Context,0)


        def cond6(self):
            return self.getTypedRuleContext(kismetParser.Cond6Context,0)


        def cond7(self):
            return self.getTypedRuleContext(kismetParser.Cond7Context,0)


        def condpattern(self):
            return self.getTypedRuleContext(kismetParser.CondpatternContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_condition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCondition" ):
                listener.enterCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCondition" ):
                listener.exitCondition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCondition" ):
                return visitor.visitCondition(self)
            else:
                return visitor.visitChildren(self)




    def condition(self):

        localctx = kismetParser.ConditionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_condition)
        try:
            self.state = 524
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,51,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 514
                self.cond10()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 515
                self.cond9()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 516
                self.cond8()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 517
                self.cond3()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 518
                self.cond1()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 519
                self.cond4()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 520
                self.cond5()
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 521
                self.cond6()
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 522
                self.cond7()
                pass

            elif la_ == 10:
                self.enterOuterAlt(localctx, 10)
                self.state = 523
                self.condpattern()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Cond8Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def arg(self):
            return self.getTypedRuleContext(kismetParser.ArgContext,0)


        def name(self):
            return self.getTypedRuleContext(kismetParser.NameContext,0)


        def operator(self):
            return self.getTypedRuleContext(kismetParser.OperatorContext,0)


        def num(self):
            return self.getTypedRuleContext(kismetParser.NumContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_cond8

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCond8" ):
                listener.enterCond8(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCond8" ):
                listener.exitCond8(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCond8" ):
                return visitor.visitCond8(self)
            else:
                return visitor.visitChildren(self)




    def cond8(self):

        localctx = kismetParser.Cond8Context(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_cond8)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 526
            self.arg()
            self.state = 527
            _la = self._input.LA(1)
            if not(_la==kismetParser.T__50 or _la==kismetParser.T__51):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 528
            self.name()
            self.state = 529
            self.operator()
            self.state = 530
            self.num()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Cond3Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def arg(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.ArgContext)
            else:
                return self.getTypedRuleContext(kismetParser.ArgContext,i)


        def knowledge(self):
            return self.getTypedRuleContext(kismetParser.KnowledgeContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_cond3

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCond3" ):
                listener.enterCond3(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCond3" ):
                listener.exitCond3(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCond3" ):
                return visitor.visitCond3(self)
            else:
                return visitor.visitChildren(self)




    def cond3(self):

        localctx = kismetParser.Cond3Context(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_cond3)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 532
            self.arg()
            self.state = 533
            self.knowledge()
            self.state = 534
            self.arg()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Cond1Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def arg(self):
            return self.getTypedRuleContext(kismetParser.ArgContext,0)


        def tag_compare(self):
            return self.getTypedRuleContext(kismetParser.Tag_compareContext,0)


        def name(self):
            return self.getTypedRuleContext(kismetParser.NameContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_cond1

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCond1" ):
                listener.enterCond1(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCond1" ):
                listener.exitCond1(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCond1" ):
                return visitor.visitCond1(self)
            else:
                return visitor.visitChildren(self)




    def cond1(self):

        localctx = kismetParser.Cond1Context(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_cond1)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 536
            self.arg()
            self.state = 537
            self.tag_compare()
            self.state = 538
            self.name()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Cond4Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def arg(self):
            return self.getTypedRuleContext(kismetParser.ArgContext,0)


        def name(self):
            return self.getTypedRuleContext(kismetParser.NameContext,0)


        def comparator(self):
            return self.getTypedRuleContext(kismetParser.ComparatorContext,0)


        def num(self):
            return self.getTypedRuleContext(kismetParser.NumContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_cond4

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCond4" ):
                listener.enterCond4(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCond4" ):
                listener.exitCond4(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCond4" ):
                return visitor.visitCond4(self)
            else:
                return visitor.visitChildren(self)




    def cond4(self):

        localctx = kismetParser.Cond4Context(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_cond4)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 540
            self.arg()
            self.state = 541
            _la = self._input.LA(1)
            if not(_la==kismetParser.T__50 or _la==kismetParser.T__51):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 542
            self.name()
            self.state = 543
            self.comparator()
            self.state = 544
            self.num()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Cond9Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def arg(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.ArgContext)
            else:
                return self.getTypedRuleContext(kismetParser.ArgContext,i)


        def name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.NameContext)
            else:
                return self.getTypedRuleContext(kismetParser.NameContext,i)


        def comparator(self):
            return self.getTypedRuleContext(kismetParser.ComparatorContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_cond9

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCond9" ):
                listener.enterCond9(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCond9" ):
                listener.exitCond9(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCond9" ):
                return visitor.visitCond9(self)
            else:
                return visitor.visitChildren(self)




    def cond9(self):

        localctx = kismetParser.Cond9Context(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_cond9)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 546
            self.arg()
            self.state = 547
            _la = self._input.LA(1)
            if not(_la==kismetParser.T__50 or _la==kismetParser.T__51):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 548
            self.name()
            self.state = 549
            self.comparator()
            self.state = 550
            self.arg()
            self.state = 551
            _la = self._input.LA(1)
            if not(_la==kismetParser.T__50 or _la==kismetParser.T__51):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 552
            self.name()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Cond10Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def arg(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.ArgContext)
            else:
                return self.getTypedRuleContext(kismetParser.ArgContext,i)


        def name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.NameContext)
            else:
                return self.getTypedRuleContext(kismetParser.NameContext,i)


        def comparator(self):
            return self.getTypedRuleContext(kismetParser.ComparatorContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_cond10

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCond10" ):
                listener.enterCond10(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCond10" ):
                listener.exitCond10(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCond10" ):
                return visitor.visitCond10(self)
            else:
                return visitor.visitChildren(self)




    def cond10(self):

        localctx = kismetParser.Cond10Context(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_cond10)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 554
            self.arg()
            self.state = 555
            self.name()
            self.state = 556
            self.arg()
            self.state = 557
            self.comparator()
            self.state = 558
            self.arg()
            self.state = 559
            self.name()
            self.state = 560
            self.arg()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InversionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return kismetParser.RULE_inversion

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInversion" ):
                listener.enterInversion(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInversion" ):
                listener.exitInversion(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInversion" ):
                return visitor.visitInversion(self)
            else:
                return visitor.visitChildren(self)




    def inversion(self):

        localctx = kismetParser.InversionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_inversion)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 562
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << kismetParser.T__52) | (1 << kismetParser.T__53) | (1 << kismetParser.T__54) | (1 << kismetParser.T__55) | (1 << kismetParser.T__56) | (1 << kismetParser.T__57))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Cond5Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def arg(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.ArgContext)
            else:
                return self.getTypedRuleContext(kismetParser.ArgContext,i)


        def name(self):
            return self.getTypedRuleContext(kismetParser.NameContext,0)


        def inversion(self):
            return self.getTypedRuleContext(kismetParser.InversionContext,0)


        def operator(self):
            return self.getTypedRuleContext(kismetParser.OperatorContext,0)


        def num(self):
            return self.getTypedRuleContext(kismetParser.NumContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_cond5

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCond5" ):
                listener.enterCond5(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCond5" ):
                listener.exitCond5(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCond5" ):
                return visitor.visitCond5(self)
            else:
                return visitor.visitChildren(self)




    def cond5(self):

        localctx = kismetParser.Cond5Context(self, self._ctx, self.state)
        self.enterRule(localctx, 78, self.RULE_cond5)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 564
            self.arg()
            self.state = 565
            self.match(kismetParser.T__58)
            self.state = 566
            self.arg()
            self.state = 568
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << kismetParser.T__52) | (1 << kismetParser.T__53) | (1 << kismetParser.T__54) | (1 << kismetParser.T__55) | (1 << kismetParser.T__56) | (1 << kismetParser.T__57))) != 0):
                self.state = 567
                self.inversion()


            self.state = 570
            self.name()
            self.state = 574
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [kismetParser.T__59]:
                self.state = 571
                self.match(kismetParser.T__59)
                self.state = 572
                self.match(kismetParser.T__60)
                pass
            elif token in [kismetParser.T__61]:
                self.state = 573
                self.match(kismetParser.T__61)
                pass
            else:
                raise NoViableAltException(self)

            self.state = 579
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 87)) & ~0x3f) == 0 and ((1 << (_la - 87)) & ((1 << (kismetParser.MINUS - 87)) | (1 << (kismetParser.PLUS - 87)) | (1 << (kismetParser.EQUALS - 87)))) != 0):
                self.state = 576
                self.operator()
                self.state = 577
                self.num()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Cond6Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def arg(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.ArgContext)
            else:
                return self.getTypedRuleContext(kismetParser.ArgContext,i)


        def name(self):
            return self.getTypedRuleContext(kismetParser.NameContext,0)


        def inversion(self):
            return self.getTypedRuleContext(kismetParser.InversionContext,0)


        def operator(self):
            return self.getTypedRuleContext(kismetParser.OperatorContext,0)


        def num(self):
            return self.getTypedRuleContext(kismetParser.NumContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_cond6

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCond6" ):
                listener.enterCond6(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCond6" ):
                listener.exitCond6(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCond6" ):
                return visitor.visitCond6(self)
            else:
                return visitor.visitChildren(self)




    def cond6(self):

        localctx = kismetParser.Cond6Context(self, self._ctx, self.state)
        self.enterRule(localctx, 80, self.RULE_cond6)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 581
            self.arg()
            self.state = 583
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << kismetParser.T__52) | (1 << kismetParser.T__53) | (1 << kismetParser.T__54) | (1 << kismetParser.T__55) | (1 << kismetParser.T__56) | (1 << kismetParser.T__57))) != 0):
                self.state = 582
                self.inversion()


            self.state = 588
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((((_la - 63)) & ~0x3f) == 0 and ((1 << (_la - 63)) & ((1 << (kismetParser.T__62 - 63)) | (1 << (kismetParser.T__63 - 63)) | (1 << (kismetParser.T__64 - 63)))) != 0):
                self.state = 585
                _la = self._input.LA(1)
                if not(((((_la - 63)) & ~0x3f) == 0 and ((1 << (_la - 63)) & ((1 << (kismetParser.T__62 - 63)) | (1 << (kismetParser.T__63 - 63)) | (1 << (kismetParser.T__64 - 63)))) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 590
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 591
            self.name()
            self.state = 595
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((((_la - 66)) & ~0x3f) == 0 and ((1 << (_la - 66)) & ((1 << (kismetParser.T__65 - 66)) | (1 << (kismetParser.T__66 - 66)) | (1 << (kismetParser.T__67 - 66)) | (1 << (kismetParser.T__68 - 66)))) != 0):
                self.state = 592
                _la = self._input.LA(1)
                if not(((((_la - 66)) & ~0x3f) == 0 and ((1 << (_la - 66)) & ((1 << (kismetParser.T__65 - 66)) | (1 << (kismetParser.T__66 - 66)) | (1 << (kismetParser.T__67 - 66)) | (1 << (kismetParser.T__68 - 66)))) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 597
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 598
            self.arg()
            self.state = 602
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 87)) & ~0x3f) == 0 and ((1 << (_la - 87)) & ((1 << (kismetParser.MINUS - 87)) | (1 << (kismetParser.PLUS - 87)) | (1 << (kismetParser.EQUALS - 87)))) != 0):
                self.state = 599
                self.operator()
                self.state = 600
                self.num()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Cond7Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def arg(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.ArgContext)
            else:
                return self.getTypedRuleContext(kismetParser.ArgContext,i)


        def name(self):
            return self.getTypedRuleContext(kismetParser.NameContext,0)


        def comparator(self):
            return self.getTypedRuleContext(kismetParser.ComparatorContext,0)


        def num(self):
            return self.getTypedRuleContext(kismetParser.NumContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_cond7

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCond7" ):
                listener.enterCond7(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCond7" ):
                listener.exitCond7(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCond7" ):
                return visitor.visitCond7(self)
            else:
                return visitor.visitChildren(self)




    def cond7(self):

        localctx = kismetParser.Cond7Context(self, self._ctx, self.state)
        self.enterRule(localctx, 82, self.RULE_cond7)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 604
            self.arg()
            self.state = 605
            self.name()
            self.state = 606
            self.arg()
            self.state = 607
            self.comparator()
            self.state = 608
            self.num()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CondpatternContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def name(self):
            return self.getTypedRuleContext(kismetParser.NameContext,0)


        def arg(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.ArgContext)
            else:
                return self.getTypedRuleContext(kismetParser.ArgContext,i)


        def getRuleIndex(self):
            return kismetParser.RULE_condpattern

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCondpattern" ):
                listener.enterCondpattern(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCondpattern" ):
                listener.exitCondpattern(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCondpattern" ):
                return visitor.visitCondpattern(self)
            else:
                return visitor.visitChildren(self)




    def condpattern(self):

        localctx = kismetParser.CondpatternContext(self, self._ctx, self.state)
        self.enterRule(localctx, 84, self.RULE_condpattern)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 610
            self.match(kismetParser.T__0)
            self.state = 611
            self.match(kismetParser.T__1)
            self.state = 612
            self.name()
            self.state = 617
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__2:
                self.state = 613
                self.match(kismetParser.T__2)
                self.state = 614
                self.arg()
                self.state = 619
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 620
            self.match(kismetParser.T__3)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Tag_compareContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return kismetParser.RULE_tag_compare

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTag_compare" ):
                listener.enterTag_compare(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTag_compare" ):
                listener.exitTag_compare(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTag_compare" ):
                return visitor.visitTag_compare(self)
            else:
                return visitor.visitChildren(self)




    def tag_compare(self):

        localctx = kismetParser.Tag_compareContext(self, self._ctx, self.state)
        self.enterRule(localctx, 86, self.RULE_tag_compare)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 622
            _la = self._input.LA(1)
            if not(((((_la - 65)) & ~0x3f) == 0 and ((1 << (_la - 65)) & ((1 << (kismetParser.T__64 - 65)) | (1 << (kismetParser.T__69 - 65)) | (1 << (kismetParser.T__70 - 65)) | (1 << (kismetParser.T__71 - 65)) | (1 << (kismetParser.T__72 - 65)) | (1 << (kismetParser.T__73 - 65)) | (1 << (kismetParser.T__74 - 65)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OperatorContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MINUS(self):
            return self.getToken(kismetParser.MINUS, 0)

        def PLUS(self):
            return self.getToken(kismetParser.PLUS, 0)

        def EQUALS(self):
            return self.getToken(kismetParser.EQUALS, 0)

        def getRuleIndex(self):
            return kismetParser.RULE_operator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOperator" ):
                listener.enterOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOperator" ):
                listener.exitOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOperator" ):
                return visitor.visitOperator(self)
            else:
                return visitor.visitChildren(self)




    def operator(self):

        localctx = kismetParser.OperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 88, self.RULE_operator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 624
            _la = self._input.LA(1)
            if not(((((_la - 87)) & ~0x3f) == 0 and ((1 << (_la - 87)) & ((1 << (kismetParser.MINUS - 87)) | (1 << (kismetParser.PLUS - 87)) | (1 << (kismetParser.EQUALS - 87)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LocationContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def name(self):
            return self.getTypedRuleContext(kismetParser.NameContext,0)


        def supports(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.SupportsContext)
            else:
                return self.getTypedRuleContext(kismetParser.SupportsContext,i)


        def each_turn(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.Each_turnContext)
            else:
                return self.getTypedRuleContext(kismetParser.Each_turnContext,i)


        def tags(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.TagsContext)
            else:
                return self.getTypedRuleContext(kismetParser.TagsContext,i)


        def getRuleIndex(self):
            return kismetParser.RULE_location

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLocation" ):
                listener.enterLocation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLocation" ):
                listener.exitLocation(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLocation" ):
                return visitor.visitLocation(self)
            else:
                return visitor.visitChildren(self)




    def location(self):

        localctx = kismetParser.LocationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 90, self.RULE_location)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 626
            self.match(kismetParser.T__75)
            self.state = 627
            self.name()
            self.state = 628
            self.match(kismetParser.T__4)
            self.state = 632
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [kismetParser.T__77]:
                self.state = 629
                self.supports()
                pass
            elif token in [kismetParser.T__76]:
                self.state = 630
                self.each_turn()
                pass
            elif token in [kismetParser.T__29]:
                self.state = 631
                self.tags()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 642
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__16:
                self.state = 634
                self.match(kismetParser.T__16)
                self.state = 638
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [kismetParser.T__77]:
                    self.state = 635
                    self.supports()
                    pass
                elif token in [kismetParser.T__76]:
                    self.state = 636
                    self.each_turn()
                    pass
                elif token in [kismetParser.T__29]:
                    self.state = 637
                    self.tags()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 644
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 645
            self.match(kismetParser.T__5)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Each_turnContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def cast(self):
            return self.getTypedRuleContext(kismetParser.CastContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_each_turn

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEach_turn" ):
                listener.enterEach_turn(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEach_turn" ):
                listener.exitEach_turn(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEach_turn" ):
                return visitor.visitEach_turn(self)
            else:
                return visitor.visitChildren(self)




    def each_turn(self):

        localctx = kismetParser.Each_turnContext(self, self._ctx, self.state)
        self.enterRule(localctx, 92, self.RULE_each_turn)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 647
            self.match(kismetParser.T__76)
            self.state = 648
            self.match(kismetParser.T__4)
            self.state = 649
            self.cast()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CastContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.NameContext)
            else:
                return self.getTypedRuleContext(kismetParser.NameContext,i)


        def getRuleIndex(self):
            return kismetParser.RULE_cast

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCast" ):
                listener.enterCast(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCast" ):
                listener.exitCast(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCast" ):
                return visitor.visitCast(self)
            else:
                return visitor.visitChildren(self)




    def cast(self):

        localctx = kismetParser.CastContext(self, self._ctx, self.state)
        self.enterRule(localctx, 94, self.RULE_cast)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 651
            self.match(kismetParser.T__24)
            self.state = 652
            self.name()
            self.state = 657
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__2:
                self.state = 653
                self.match(kismetParser.T__2)
                self.state = 654
                self.name()
                self.state = 659
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Random_textContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RANDOM_TEXT(self):
            return self.getToken(kismetParser.RANDOM_TEXT, 0)

        def getRuleIndex(self):
            return kismetParser.RULE_random_text

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRandom_text" ):
                listener.enterRandom_text(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRandom_text" ):
                listener.exitRandom_text(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRandom_text" ):
                return visitor.visitRandom_text(self)
            else:
                return visitor.visitChildren(self)




    def random_text(self):

        localctx = kismetParser.Random_textContext(self, self._ctx, self.state)
        self.enterRule(localctx, 96, self.RULE_random_text)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 660
            self.match(kismetParser.RANDOM_TEXT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SupportsContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def num_choice(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.Num_choiceContext)
            else:
                return self.getTypedRuleContext(kismetParser.Num_choiceContext,i)


        def getRuleIndex(self):
            return kismetParser.RULE_supports

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSupports" ):
                listener.enterSupports(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSupports" ):
                listener.exitSupports(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSupports" ):
                return visitor.visitSupports(self)
            else:
                return visitor.visitChildren(self)




    def supports(self):

        localctx = kismetParser.SupportsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 98, self.RULE_supports)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 662
            self.match(kismetParser.T__77)
            self.state = 663
            self.match(kismetParser.T__4)
            self.state = 664
            self.num_choice()
            self.state = 669
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__2:
                self.state = 665
                self.match(kismetParser.T__2)
                self.state = 666
                self.num_choice()
                self.state = 671
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NumContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NUMBER(self):
            return self.getToken(kismetParser.NUMBER, 0)

        def getRuleIndex(self):
            return kismetParser.RULE_num

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNum" ):
                listener.enterNum(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNum" ):
                listener.exitNum(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNum" ):
                return visitor.visitNum(self)
            else:
                return visitor.visitChildren(self)




    def num(self):

        localctx = kismetParser.NumContext(self, self._ctx, self.state)
        self.enterRule(localctx, 100, self.RULE_num)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 672
            self.match(kismetParser.NUMBER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Pos_numContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def POSITIVE_NUMBER(self):
            return self.getToken(kismetParser.POSITIVE_NUMBER, 0)

        def getRuleIndex(self):
            return kismetParser.RULE_pos_num

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPos_num" ):
                listener.enterPos_num(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPos_num" ):
                listener.exitPos_num(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPos_num" ):
                return visitor.visitPos_num(self)
            else:
                return visitor.visitChildren(self)




    def pos_num(self):

        localctx = kismetParser.Pos_numContext(self, self._ctx, self.state)
        self.enterRule(localctx, 102, self.RULE_pos_num)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 674
            self.match(kismetParser.POSITIVE_NUMBER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NameContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NAME(self):
            return self.getToken(kismetParser.NAME, 0)

        def getRuleIndex(self):
            return kismetParser.RULE_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterName" ):
                listener.enterName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitName" ):
                listener.exitName(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitName" ):
                return visitor.visitName(self)
            else:
                return visitor.visitChildren(self)




    def name(self):

        localctx = kismetParser.NameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 104, self.RULE_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 676
            self.match(kismetParser.NAME)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VarContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def VAR(self):
            return self.getToken(kismetParser.VAR, 0)

        def getRuleIndex(self):
            return kismetParser.RULE_var

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVar" ):
                listener.enterVar(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVar" ):
                listener.exitVar(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVar" ):
                return visitor.visitVar(self)
            else:
                return visitor.visitChildren(self)




    def var(self):

        localctx = kismetParser.VarContext(self, self._ctx, self.state)
        self.enterRule(localctx, 106, self.RULE_var)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 678
            self.match(kismetParser.VAR)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ComparatorContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return kismetParser.RULE_comparator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterComparator" ):
                listener.enterComparator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitComparator" ):
                listener.exitComparator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitComparator" ):
                return visitor.visitComparator(self)
            else:
                return visitor.visitChildren(self)




    def comparator(self):

        localctx = kismetParser.ComparatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 108, self.RULE_comparator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 680
            _la = self._input.LA(1)
            if not(((((_la - 26)) & ~0x3f) == 0 and ((1 << (_la - 26)) & ((1 << (kismetParser.T__25 - 26)) | (1 << (kismetParser.T__28 - 26)) | (1 << (kismetParser.T__78 - 26)) | (1 << (kismetParser.T__79 - 26)) | (1 << (kismetParser.T__80 - 26)) | (1 << (kismetParser.T__81 - 26)) | (1 << (kismetParser.T__82 - 26)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Num_choiceContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def num(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.NumContext)
            else:
                return self.getTypedRuleContext(kismetParser.NumContext,i)


        def name(self):
            return self.getTypedRuleContext(kismetParser.NameContext,0)


        def pdf(self):
            return self.getTypedRuleContext(kismetParser.PdfContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_num_choice

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNum_choice" ):
                listener.enterNum_choice(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNum_choice" ):
                listener.exitNum_choice(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNum_choice" ):
                return visitor.visitNum_choice(self)
            else:
                return visitor.visitChildren(self)




    def num_choice(self):

        localctx = kismetParser.Num_choiceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 110, self.RULE_num_choice)
        self._la = 0 # Token type
        try:
            self.state = 697
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,66,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 682
                self.match(kismetParser.T__83)
                self.state = 683
                self.num()
                self.state = 684
                self.match(kismetParser.T__84)
                self.state = 685
                self.name()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 687
                self.match(kismetParser.T__83)
                self.state = 688
                self.num()
                self.state = 689
                self.match(kismetParser.T__4)
                self.state = 690
                self.num()
                self.state = 691
                self.match(kismetParser.T__84)
                self.state = 693
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==kismetParser.T__5 or _la==kismetParser.T__26 or _la==kismetParser.T__85 or _la==kismetParser.NEG:
                    self.state = 692
                    self.pdf()


                self.state = 695
                self.name()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PdfContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NEG(self, i:int=None):
            if i is None:
                return self.getTokens(kismetParser.NEG)
            else:
                return self.getToken(kismetParser.NEG, i)

        def getRuleIndex(self):
            return kismetParser.RULE_pdf

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPdf" ):
                listener.enterPdf(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPdf" ):
                listener.exitPdf(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPdf" ):
                return visitor.visitPdf(self)
            else:
                return visitor.visitChildren(self)




    def pdf(self):

        localctx = kismetParser.PdfContext(self, self._ctx, self.state)
        self.enterRule(localctx, 112, self.RULE_pdf)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 700 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 699
                _la = self._input.LA(1)
                if not(_la==kismetParser.T__5 or _la==kismetParser.T__26 or _la==kismetParser.T__85 or _la==kismetParser.NEG):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 702 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==kismetParser.T__5 or _la==kismetParser.T__26 or _la==kismetParser.T__85 or _la==kismetParser.NEG):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





