# Generated from kismet.ebnv by ANTLR 4.7.2
# encoding: utf-8
from antlr4 import *
from io import StringIO
from typing.io import TextIO
import sys


def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3a")
        buf.write("\u029f\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\4\23\t\23")
        buf.write("\4\24\t\24\4\25\t\25\4\26\t\26\4\27\t\27\4\30\t\30\4\31")
        buf.write("\t\31\4\32\t\32\4\33\t\33\4\34\t\34\4\35\t\35\4\36\t\36")
        buf.write("\4\37\t\37\4 \t \4!\t!\4\"\t\"\4#\t#\4$\t$\4%\t%\4&\t")
        buf.write("&\4\'\t\'\4(\t(\4)\t)\4*\t*\4+\t+\4,\t,\4-\t-\4.\t.\4")
        buf.write("/\t/\4\60\t\60\4\61\t\61\4\62\t\62\4\63\t\63\4\64\t\64")
        buf.write("\4\65\t\65\4\66\t\66\4\67\t\67\3\2\3\2\3\2\3\2\6\2s\n")
        buf.write("\2\r\2\16\2t\3\2\3\2\3\3\3\3\3\3\3\3\7\3}\n\3\f\3\16\3")
        buf.write("\u0080\13\3\3\4\5\4\u0083\n\4\3\4\3\4\5\4\u0087\n\4\3")
        buf.write("\4\3\4\3\4\7\4\u008c\n\4\f\4\16\4\u008f\13\4\3\4\3\4\3")
        buf.write("\4\3\4\7\4\u0095\n\4\f\4\16\4\u0098\13\4\3\4\3\4\5\4\u009c")
        buf.write("\n\4\3\4\3\4\5\4\u00a0\n\4\3\4\3\4\7\4\u00a4\n\4\f\4\16")
        buf.write("\4\u00a7\13\4\3\4\3\4\3\5\3\5\3\6\3\6\3\7\3\7\3\b\3\b")
        buf.write("\5\b\u00b3\n\b\3\t\3\t\5\t\u00b7\n\t\3\n\3\n\3\n\3\n\3")
        buf.write("\n\7\n\u00be\n\n\f\n\16\n\u00c1\13\n\3\n\5\n\u00c4\n\n")
        buf.write("\3\n\3\n\3\13\3\13\3\13\3\13\3\13\7\13\u00cd\n\13\f\13")
        buf.write("\16\13\u00d0\13\13\3\13\5\13\u00d3\n\13\3\13\3\13\3\f")
        buf.write("\6\f\u00d8\n\f\r\f\16\f\u00d9\3\f\6\f\u00dd\n\f\r\f\16")
        buf.write("\f\u00de\5\f\u00e1\n\f\3\r\5\r\u00e4\n\r\3\r\3\r\3\r\3")
        buf.write("\r\3\r\3\r\7\r\u00ec\n\r\f\r\16\r\u00ef\13\r\3\r\3\r\5")
        buf.write("\r\u00f3\n\r\3\r\5\r\u00f6\n\r\3\r\5\r\u00f9\n\r\3\r\3")
        buf.write("\r\5\r\u00fd\n\r\3\r\3\r\7\r\u0101\n\r\f\r\16\r\u0104")
        buf.write("\13\r\3\r\3\r\3\16\3\16\3\16\3\17\3\17\3\20\3\20\3\20")
        buf.write("\3\20\3\20\7\20\u0112\n\20\f\20\16\20\u0115\13\20\3\21")
        buf.write("\3\21\3\22\3\22\3\22\3\23\3\23\6\23\u011e\n\23\r\23\16")
        buf.write("\23\u011f\3\24\3\24\3\24\3\24\3\24\7\24\u0127\n\24\f\24")
        buf.write("\16\24\u012a\13\24\3\24\3\24\3\24\3\24\3\24\3\24\3\24")
        buf.write("\7\24\u0133\n\24\f\24\16\24\u0136\13\24\3\24\3\24\3\24")
        buf.write("\3\24\3\24\3\24\3\24\7\24\u013f\n\24\f\24\16\24\u0142")
        buf.write("\13\24\3\24\3\24\3\24\3\24\3\24\3\24\7\24\u014a\n\24\f")
        buf.write("\24\16\24\u014d\13\24\3\24\3\24\5\24\u0151\n\24\3\25\3")
        buf.write("\25\3\26\3\26\3\26\3\26\3\26\5\26\u015a\n\26\3\27\3\27")
        buf.write("\3\27\3\27\3\27\3\27\7\27\u0162\n\27\f\27\16\27\u0165")
        buf.write("\13\27\3\27\3\27\5\27\u0169\n\27\3\27\3\27\3\27\5\27\u016e")
        buf.write("\n\27\3\27\3\27\3\27\5\27\u0173\n\27\7\27\u0175\n\27\f")
        buf.write("\27\16\27\u0178\13\27\3\27\3\27\3\30\3\30\3\30\5\30\u017f")
        buf.write("\n\30\3\30\3\30\3\30\3\30\7\30\u0185\n\30\f\30\16\30\u0188")
        buf.write("\13\30\3\30\3\30\3\31\3\31\3\31\3\32\5\32\u0190\n\32\3")
        buf.write("\32\3\32\5\32\u0194\n\32\3\32\3\32\3\32\3\32\3\32\5\32")
        buf.write("\u019b\n\32\3\32\3\32\3\32\3\32\5\32\u01a1\n\32\3\33\3")
        buf.write("\33\3\34\3\34\3\35\3\35\3\35\3\35\3\35\7\35\u01ac\n\35")
        buf.write("\f\35\16\35\u01af\13\35\3\36\3\36\3\36\3\36\7\36\u01b5")
        buf.write("\n\36\f\36\16\36\u01b8\13\36\3\37\3\37\3\37\3\37\3\37")
        buf.write("\3\37\3\37\3\37\3\37\3\37\3\37\3\37\3\37\3\37\3\37\3\37")
        buf.write("\3\37\3\37\3\37\3\37\3\37\3\37\3\37\3\37\3\37\3\37\3\37")
        buf.write("\3\37\3\37\3\37\3\37\3\37\3\37\3\37\3\37\3\37\3\37\3\37")
        buf.write("\3\37\3\37\5\37\u01e2\n\37\3 \3 \3 \3 \3 \3 \3 \5 \u01eb")
        buf.write("\n \3!\3!\3!\3!\3\"\3\"\3\"\3\"\3#\3#\3#\3#\3#\3#\3$\3")
        buf.write("$\3%\3%\3%\3%\5%\u0201\n%\3%\3%\3%\3%\5%\u0207\n%\3%\3")
        buf.write("%\3%\5%\u020c\n%\3&\3&\5&\u0210\n&\3&\7&\u0213\n&\f&\16")
        buf.write("&\u0216\13&\3&\3&\7&\u021a\n&\f&\16&\u021d\13&\3&\3&\3")
        buf.write("&\3&\5&\u0223\n&\3\'\3\'\3\'\3\'\3\'\3\'\3(\3(\3(\3(\3")
        buf.write("(\7(\u0230\n(\f(\16(\u0233\13(\3(\3(\3)\3)\3*\3*\3+\3")
        buf.write("+\3+\3+\3+\3+\3+\3+\5+\u0243\n+\3+\3+\3+\3+\3+\3+\5+\u024b")
        buf.write("\n+\7+\u024d\n+\f+\16+\u0250\13+\3+\3+\3,\3,\3,\3,\3,")
        buf.write("\7,\u0259\n,\f,\16,\u025c\13,\3-\3-\3-\3-\3-\7-\u0263")
        buf.write("\n-\f-\16-\u0266\13-\3.\3.\3.\3.\7.\u026c\n.\f.\16.\u026f")
        buf.write("\13.\3/\3/\3\60\3\60\3\60\3\60\3\61\3\61\3\61\3\61\3\61")
        buf.write("\7\61\u027c\n\61\f\61\16\61\u027f\13\61\3\62\3\62\3\63")
        buf.write("\3\63\3\64\3\64\3\65\3\65\3\66\3\66\3\66\3\66\3\66\3\66")
        buf.write("\3\66\3\66\3\66\3\66\3\66\5\66\u0294\n\66\3\66\3\66\5")
        buf.write("\66\u0298\n\66\3\67\6\67\u029b\n\67\r\67\16\67\u029c\3")
        buf.write("\67\2\28\2\4\6\b\n\f\16\20\22\24\26\30\32\34\36 \"$&(")
        buf.write("*,.\60\62\64\668:<>@BDFHJLNPRTVXZ\\^`bdfhjl\2\r\3\2\13")
        buf.write("\f\3\2\b\t\4\2\17\17\34\37\3\2\65\66\3\2\67<\3\2AC\3\2")
        buf.write("DE\4\2CCGL\3\2Z[\5\2\34\34\37\37RV\6\2\t\t\21\21\35\35")
        buf.write("YY\2\u02d4\2r\3\2\2\2\4x\3\2\2\2\6\u0082\3\2\2\2\b\u00aa")
        buf.write("\3\2\2\2\n\u00ac\3\2\2\2\f\u00ae\3\2\2\2\16\u00b2\3\2")
        buf.write("\2\2\20\u00b6\3\2\2\2\22\u00b8\3\2\2\2\24\u00c7\3\2\2")
        buf.write("\2\26\u00e0\3\2\2\2\30\u00e3\3\2\2\2\32\u0107\3\2\2\2")
        buf.write("\34\u010a\3\2\2\2\36\u010c\3\2\2\2 \u0116\3\2\2\2\"\u0118")
        buf.write("\3\2\2\2$\u011b\3\2\2\2&\u0150\3\2\2\2(\u0152\3\2\2\2")
        buf.write("*\u0159\3\2\2\2,\u015b\3\2\2\2.\u017b\3\2\2\2\60\u018b")
        buf.write("\3\2\2\2\62\u01a0\3\2\2\2\64\u01a2\3\2\2\2\66\u01a4\3")
        buf.write("\2\2\28\u01a6\3\2\2\2:\u01b0\3\2\2\2<\u01e1\3\2\2\2>\u01ea")
        buf.write("\3\2\2\2@\u01ec\3\2\2\2B\u01f0\3\2\2\2D\u01f4\3\2\2\2")
        buf.write("F\u01fa\3\2\2\2H\u01fc\3\2\2\2J\u020d\3\2\2\2L\u0224\3")
        buf.write("\2\2\2N\u022a\3\2\2\2P\u0236\3\2\2\2R\u0238\3\2\2\2T\u023a")
        buf.write("\3\2\2\2V\u0253\3\2\2\2X\u025d\3\2\2\2Z\u0267\3\2\2\2")
        buf.write("\\\u0270\3\2\2\2^\u0272\3\2\2\2`\u0276\3\2\2\2b\u0280")
        buf.write("\3\2\2\2d\u0282\3\2\2\2f\u0284\3\2\2\2h\u0286\3\2\2\2")
        buf.write("j\u0297\3\2\2\2l\u029a\3\2\2\2ns\5T+\2os\5,\27\2ps\5\30")
        buf.write("\r\2qs\5\6\4\2rn\3\2\2\2ro\3\2\2\2rp\3\2\2\2rq\3\2\2\2")
        buf.write("st\3\2\2\2tr\3\2\2\2tu\3\2\2\2uv\3\2\2\2vw\7\2\2\3w\3")
        buf.write("\3\2\2\2xy\7\3\2\2y~\5d\63\2z{\7\4\2\2{}\5d\63\2|z\3\2")
        buf.write("\2\2}\u0080\3\2\2\2~|\3\2\2\2~\177\3\2\2\2\177\5\3\2\2")
        buf.write("\2\u0080~\3\2\2\2\u0081\u0083\5\b\5\2\u0082\u0081\3\2")
        buf.write("\2\2\u0082\u0083\3\2\2\2\u0083\u0084\3\2\2\2\u0084\u0086")
        buf.write("\5\n\6\2\u0085\u0087\5\f\7\2\u0086\u0085\3\2\2\2\u0086")
        buf.write("\u0087\3\2\2\2\u0087\u0088\3\2\2\2\u0088\u008d\5d\63\2")
        buf.write("\u0089\u008a\7\4\2\2\u008a\u008c\5d\63\2\u008b\u0089\3")
        buf.write("\2\2\2\u008c\u008f\3\2\2\2\u008d\u008b\3\2\2\2\u008d\u008e")
        buf.write("\3\2\2\2\u008e\u0090\3\2\2\2\u008f\u008d\3\2\2\2\u0090")
        buf.write("\u0091\7\5\2\2\u0091\u0096\5\62\32\2\u0092\u0093\7\6\2")
        buf.write("\2\u0093\u0095\5\62\32\2\u0094\u0092\3\2\2\2\u0095\u0098")
        buf.write("\3\2\2\2\u0096\u0094\3\2\2\2\u0096\u0097\3\2\2\2\u0097")
        buf.write("\u0099\3\2\2\2\u0098\u0096\3\2\2\2\u0099\u009b\7\7\2\2")
        buf.write("\u009a\u009c\5\4\3\2\u009b\u009a\3\2\2\2\u009b\u009c\3")
        buf.write("\2\2\2\u009c\u009d\3\2\2\2\u009d\u009f\7\b\2\2\u009e\u00a0")
        buf.write("\5\16\b\2\u009f\u009e\3\2\2\2\u009f\u00a0\3\2\2\2\u00a0")
        buf.write("\u00a5\3\2\2\2\u00a1\u00a2\7\6\2\2\u00a2\u00a4\5\16\b")
        buf.write("\2\u00a3\u00a1\3\2\2\2\u00a4\u00a7\3\2\2\2\u00a5\u00a3")
        buf.write("\3\2\2\2\u00a5\u00a6\3\2\2\2\u00a6\u00a8\3\2\2\2\u00a7")
        buf.write("\u00a5\3\2\2\2\u00a8\u00a9\7\t\2\2\u00a9\7\3\2\2\2\u00aa")
        buf.write("\u00ab\7\n\2\2\u00ab\t\3\2\2\2\u00ac\u00ad\t\2\2\2\u00ad")
        buf.write("\13\3\2\2\2\u00ae\u00af\7\r\2\2\u00af\r\3\2\2\2\u00b0")
        buf.write("\u00b3\5\22\n\2\u00b1\u00b3\5\24\13\2\u00b2\u00b0\3\2")
        buf.write("\2\2\u00b2\u00b1\3\2\2\2\u00b3\17\3\2\2\2\u00b4\u00b7")
        buf.write("\7\16\2\2\u00b5\u00b7\5d\63\2\u00b6\u00b4\3\2\2\2\u00b6")
        buf.write("\u00b5\3\2\2\2\u00b7\21\3\2\2\2\u00b8\u00b9\5\26\f\2\u00b9")
        buf.write("\u00ba\7\5\2\2\u00ba\u00bf\5\20\t\2\u00bb\u00bc\7\6\2")
        buf.write("\2\u00bc\u00be\5\20\t\2\u00bd\u00bb\3\2\2\2\u00be\u00c1")
        buf.write("\3\2\2\2\u00bf\u00bd\3\2\2\2\u00bf\u00c0\3\2\2\2\u00c0")
        buf.write("\u00c3\3\2\2\2\u00c1\u00bf\3\2\2\2\u00c2\u00c4\5:\36\2")
        buf.write("\u00c3\u00c2\3\2\2\2\u00c3\u00c4\3\2\2\2\u00c4\u00c5\3")
        buf.write("\2\2\2\u00c5\u00c6\7\7\2\2\u00c6\23\3\2\2\2\u00c7\u00c8")
        buf.write("\5\26\f\2\u00c8\u00c9\7\17\2\2\u00c9\u00ce\5d\63\2\u00ca")
        buf.write("\u00cb\7\6\2\2\u00cb\u00cd\5d\63\2\u00cc\u00ca\3\2\2\2")
        buf.write("\u00cd\u00d0\3\2\2\2\u00ce\u00cc\3\2\2\2\u00ce\u00cf\3")
        buf.write("\2\2\2\u00cf\u00d2\3\2\2\2\u00d0\u00ce\3\2\2\2\u00d1\u00d3")
        buf.write("\5:\36\2\u00d2\u00d1\3\2\2\2\u00d2\u00d3\3\2\2\2\u00d3")
        buf.write("\u00d4\3\2\2\2\u00d4\u00d5\7\17\2\2\u00d5\25\3\2\2\2\u00d6")
        buf.write("\u00d8\7\20\2\2\u00d7\u00d6\3\2\2\2\u00d8\u00d9\3\2\2")
        buf.write("\2\u00d9\u00d7\3\2\2\2\u00d9\u00da\3\2\2\2\u00da\u00e1")
        buf.write("\3\2\2\2\u00db\u00dd\7\21\2\2\u00dc\u00db\3\2\2\2\u00dd")
        buf.write("\u00de\3\2\2\2\u00de\u00dc\3\2\2\2\u00de\u00df\3\2\2\2")
        buf.write("\u00df\u00e1\3\2\2\2\u00e0\u00d7\3\2\2\2\u00e0\u00dc\3")
        buf.write("\2\2\2\u00e1\27\3\2\2\2\u00e2\u00e4\5\34\17\2\u00e3\u00e2")
        buf.write("\3\2\2\2\u00e3\u00e4\3\2\2\2\u00e4\u00e5\3\2\2\2\u00e5")
        buf.write("\u00e6\7\22\2\2\u00e6\u00e7\5d\63\2\u00e7\u00e8\7\5\2")
        buf.write("\2\u00e8\u00ed\5\62\32\2\u00e9\u00ea\7\6\2\2\u00ea\u00ec")
        buf.write("\5\62\32\2\u00eb\u00e9\3\2\2\2\u00ec\u00ef\3\2\2\2\u00ed")
        buf.write("\u00eb\3\2\2\2\u00ed\u00ee\3\2\2\2\u00ee\u00f0\3\2\2\2")
        buf.write("\u00ef\u00ed\3\2\2\2\u00f0\u00f2\7\7\2\2\u00f1\u00f3\5")
        buf.write("\32\16\2\u00f2\u00f1\3\2\2\2\u00f2\u00f3\3\2\2\2\u00f3")
        buf.write("\u00f5\3\2\2\2\u00f4\u00f6\5.\30\2\u00f5\u00f4\3\2\2\2")
        buf.write("\u00f5\u00f6\3\2\2\2\u00f6\u00f8\3\2\2\2\u00f7\u00f9\5")
        buf.write("\\/\2\u00f8\u00f7\3\2\2\2\u00f8\u00f9\3\2\2\2\u00f9\u00fa")
        buf.write("\3\2\2\2\u00fa\u00fc\7\b\2\2\u00fb\u00fd\5*\26\2\u00fc")
        buf.write("\u00fb\3\2\2\2\u00fc\u00fd\3\2\2\2\u00fd\u0102\3\2\2\2")
        buf.write("\u00fe\u00ff\7\23\2\2\u00ff\u0101\5*\26\2\u0100\u00fe")
        buf.write("\3\2\2\2\u0101\u0104\3\2\2\2\u0102\u0100\3\2\2\2\u0102")
        buf.write("\u0103\3\2\2\2\u0103\u0105\3\2\2\2\u0104\u0102\3\2\2\2")
        buf.write("\u0105\u0106\7\t\2\2\u0106\31\3\2\2\2\u0107\u0108\7\24")
        buf.write("\2\2\u0108\u0109\5b\62\2\u0109\33\3\2\2\2\u010a\u010b")
        buf.write("\7\25\2\2\u010b\35\3\2\2\2\u010c\u010d\7\26\2\2\u010d")
        buf.write("\u010e\7\b\2\2\u010e\u0113\5 \21\2\u010f\u0110\7\6\2\2")
        buf.write("\u0110\u0112\5 \21\2\u0111\u010f\3\2\2\2\u0112\u0115\3")
        buf.write("\2\2\2\u0113\u0111\3\2\2\2\u0113\u0114\3\2\2\2\u0114\37")
        buf.write("\3\2\2\2\u0115\u0113\3\2\2\2\u0116\u0117\5> \2\u0117!")
        buf.write("\3\2\2\2\u0118\u0119\7\16\2\2\u0119\u011a\5\26\f\2\u011a")
        buf.write("#\3\2\2\2\u011b\u011d\7\27\2\2\u011c\u011e\5&\24\2\u011d")
        buf.write("\u011c\3\2\2\2\u011e\u011f\3\2\2\2\u011f\u011d\3\2\2\2")
        buf.write("\u011f\u0120\3\2\2\2\u0120%\3\2\2\2\u0121\u0122\5f\64")
        buf.write("\2\u0122\u0123\7\5\2\2\u0123\u0128\5\62\32\2\u0124\u0125")
        buf.write("\7\6\2\2\u0125\u0127\5\62\32\2\u0126\u0124\3\2\2\2\u0127")
        buf.write("\u012a\3\2\2\2\u0128\u0126\3\2\2\2\u0128\u0129\3\2\2\2")
        buf.write("\u0129\u012b\3\2\2\2\u012a\u0128\3\2\2\2\u012b\u012c\7")
        buf.write("\7\2\2\u012c\u0151\3\2\2\2\u012d\u012e\5d\63\2\u012e\u012f")
        buf.write("\7\5\2\2\u012f\u0134\5\62\32\2\u0130\u0131\7\6\2\2\u0131")
        buf.write("\u0133\5\62\32\2\u0132\u0130\3\2\2\2\u0133\u0136\3\2\2")
        buf.write("\2\u0134\u0132\3\2\2\2\u0134\u0135\3\2\2\2\u0135\u0137")
        buf.write("\3\2\2\2\u0136\u0134\3\2\2\2\u0137\u0138\7\7\2\2\u0138")
        buf.write("\u0151\3\2\2\2\u0139\u013a\5(\25\2\u013a\u013b\7\5\2\2")
        buf.write("\u013b\u0140\5\62\32\2\u013c\u013d\7\6\2\2\u013d\u013f")
        buf.write("\5\62\32\2\u013e\u013c\3\2\2\2\u013f\u0142\3\2\2\2\u0140")
        buf.write("\u013e\3\2\2\2\u0140\u0141\3\2\2\2\u0141\u0143\3\2\2\2")
        buf.write("\u0142\u0140\3\2\2\2\u0143\u0144\7\7\2\2\u0144\u0151\3")
        buf.write("\2\2\2\u0145\u0146\7\5\2\2\u0146\u014b\5\62\32\2\u0147")
        buf.write("\u0148\7\6\2\2\u0148\u014a\5\62\32\2\u0149\u0147\3\2\2")
        buf.write("\2\u014a\u014d\3\2\2\2\u014b\u0149\3\2\2\2\u014b\u014c")
        buf.write("\3\2\2\2\u014c\u014e\3\2\2\2\u014d\u014b\3\2\2\2\u014e")
        buf.write("\u014f\7\7\2\2\u014f\u0151\3\2\2\2\u0150\u0121\3\2\2\2")
        buf.write("\u0150\u012d\3\2\2\2\u0150\u0139\3\2\2\2\u0150\u0145\3")
        buf.write("\2\2\2\u0151\'\3\2\2\2\u0152\u0153\7\30\2\2\u0153)\3\2")
        buf.write("\2\2\u0154\u015a\58\35\2\u0155\u015a\5:\36\2\u0156\u015a")
        buf.write("\5$\23\2\u0157\u015a\5\36\20\2\u0158\u015a\5\"\22\2\u0159")
        buf.write("\u0154\3\2\2\2\u0159\u0155\3\2\2\2\u0159\u0156\3\2\2\2")
        buf.write("\u0159\u0157\3\2\2\2\u0159\u0158\3\2\2\2\u015a+\3\2\2")
        buf.write("\2\u015b\u015c\7\31\2\2\u015c\u015d\5d\63\2\u015d\u015e")
        buf.write("\7\5\2\2\u015e\u0163\5\62\32\2\u015f\u0160\7\6\2\2\u0160")
        buf.write("\u0162\5\62\32\2\u0161\u015f\3\2\2\2\u0162\u0165\3\2\2")
        buf.write("\2\u0163\u0161\3\2\2\2\u0163\u0164\3\2\2\2\u0164\u0166")
        buf.write("\3\2\2\2\u0165\u0163\3\2\2\2\u0166\u0168\7\7\2\2\u0167")
        buf.write("\u0169\5.\30\2\u0168\u0167\3\2\2\2\u0168\u0169\3\2\2\2")
        buf.write("\u0169\u016a\3\2\2\2\u016a\u016d\7\b\2\2\u016b\u016e\5")
        buf.write("8\35\2\u016c\u016e\5:\36\2\u016d\u016b\3\2\2\2\u016d\u016c")
        buf.write("\3\2\2\2\u016e\u0176\3\2\2\2\u016f\u0172\7\23\2\2\u0170")
        buf.write("\u0173\58\35\2\u0171\u0173\5:\36\2\u0172\u0170\3\2\2\2")
        buf.write("\u0172\u0171\3\2\2\2\u0173\u0175\3\2\2\2\u0174\u016f\3")
        buf.write("\2\2\2\u0175\u0178\3\2\2\2\u0176\u0174\3\2\2\2\u0176\u0177")
        buf.write("\3\2\2\2\u0177\u0179\3\2\2\2\u0178\u0176\3\2\2\2\u0179")
        buf.write("\u017a\7\t\2\2\u017a-\3\2\2\2\u017b\u017e\7\32\2\2\u017c")
        buf.write("\u017f\5\60\31\2\u017d\u017f\5d\63\2\u017e\u017c\3\2\2")
        buf.write("\2\u017e\u017d\3\2\2\2\u017f\u0180\3\2\2\2\u0180\u0181")
        buf.write("\7\5\2\2\u0181\u0186\5\62\32\2\u0182\u0183\7\6\2\2\u0183")
        buf.write("\u0185\5\62\32\2\u0184\u0182\3\2\2\2\u0185\u0188\3\2\2")
        buf.write("\2\u0186\u0184\3\2\2\2\u0186\u0187\3\2\2\2\u0187\u0189")
        buf.write("\3\2\2\2\u0188\u0186\3\2\2\2\u0189\u018a\7\7\2\2\u018a")
        buf.write("/\3\2\2\2\u018b\u018c\7\33\2\2\u018c\u018d\5d\63\2\u018d")
        buf.write("\61\3\2\2\2\u018e\u0190\5\66\34\2\u018f\u018e\3\2\2\2")
        buf.write("\u018f\u0190\3\2\2\2\u0190\u0191\3\2\2\2\u0191\u01a1\5")
        buf.write("f\64\2\u0192\u0194\5\66\34\2\u0193\u0192\3\2\2\2\u0193")
        buf.write("\u0194\3\2\2\2\u0194\u0195\3\2\2\2\u0195\u0196\5f\64\2")
        buf.write("\u0196\u0197\5\64\33\2\u0197\u0198\5d\63\2\u0198\u01a1")
        buf.write("\3\2\2\2\u0199\u019b\5\66\34\2\u019a\u0199\3\2\2\2\u019a")
        buf.write("\u019b\3\2\2\2\u019b\u019c\3\2\2\2\u019c\u019d\5f\64\2")
        buf.write("\u019d\u019e\5\64\33\2\u019e\u019f\5f\64\2\u019f\u01a1")
        buf.write("\3\2\2\2\u01a0\u018f\3\2\2\2\u01a0\u0193\3\2\2\2\u01a0")
        buf.write("\u019a\3\2\2\2\u01a1\63\3\2\2\2\u01a2\u01a3\t\3\2\2\u01a3")
        buf.write("\65\3\2\2\2\u01a4\u01a5\t\4\2\2\u01a5\67\3\2\2\2\u01a6")
        buf.write("\u01a7\7 \2\2\u01a7\u01a8\7\b\2\2\u01a8\u01ad\5d\63\2")
        buf.write("\u01a9\u01aa\7\6\2\2\u01aa\u01ac\5d\63\2\u01ab\u01a9\3")
        buf.write("\2\2\2\u01ac\u01af\3\2\2\2\u01ad\u01ab\3\2\2\2\u01ad\u01ae")
        buf.write("\3\2\2\2\u01ae9\3\2\2\2\u01af\u01ad\3\2\2\2\u01b0\u01b1")
        buf.write("\7!\2\2\u01b1\u01b6\5> \2\u01b2\u01b3\7\6\2\2\u01b3\u01b5")
        buf.write("\5> \2\u01b4\u01b2\3\2\2\2\u01b5\u01b8\3\2\2\2\u01b6\u01b4")
        buf.write("\3\2\2\2\u01b6\u01b7\3\2\2\2\u01b7;\3\2\2\2\u01b8\u01b6")
        buf.write("\3\2\2\2\u01b9\u01e2\7\"\2\2\u01ba\u01e2\7#\2\2\u01bb")
        buf.write("\u01e2\7$\2\2\u01bc\u01bd\7%\2\2\u01bd\u01be\7&\2\2\u01be")
        buf.write("\u01e2\7\'\2\2\u01bf\u01c0\7(\2\2\u01c0\u01e2\7\'\2\2")
        buf.write("\u01c1\u01c2\7)\2\2\u01c2\u01e2\7\'\2\2\u01c3\u01c4\7")
        buf.write("%\2\2\u01c4\u01c5\7&\2\2\u01c5\u01e2\7*\2\2\u01c6\u01c7")
        buf.write("\7(\2\2\u01c7\u01e2\7*\2\2\u01c8\u01c9\7)\2\2\u01c9\u01e2")
        buf.write("\7*\2\2\u01ca\u01cb\7%\2\2\u01cb\u01cc\7&\2\2\u01cc\u01e2")
        buf.write("\7+\2\2\u01cd\u01ce\7(\2\2\u01ce\u01e2\7+\2\2\u01cf\u01d0")
        buf.write("\7)\2\2\u01d0\u01e2\7+\2\2\u01d1\u01d2\7%\2\2\u01d2\u01d3")
        buf.write("\7&\2\2\u01d3\u01e2\7,\2\2\u01d4\u01d5\7(\2\2\u01d5\u01e2")
        buf.write("\7,\2\2\u01d6\u01d7\7)\2\2\u01d7\u01e2\7,\2\2\u01d8\u01e2")
        buf.write("\7-\2\2\u01d9\u01e2\7.\2\2\u01da\u01e2\7/\2\2\u01db\u01e2")
        buf.write("\7\60\2\2\u01dc\u01e2\7\61\2\2\u01dd\u01e2\7\62\2\2\u01de")
        buf.write("\u01e2\7\63\2\2\u01df\u01e2\7%\2\2\u01e0\u01e2\7\64\2")
        buf.write("\2\u01e1\u01b9\3\2\2\2\u01e1\u01ba\3\2\2\2\u01e1\u01bb")
        buf.write("\3\2\2\2\u01e1\u01bc\3\2\2\2\u01e1\u01bf\3\2\2\2\u01e1")
        buf.write("\u01c1\3\2\2\2\u01e1\u01c3\3\2\2\2\u01e1\u01c6\3\2\2\2")
        buf.write("\u01e1\u01c8\3\2\2\2\u01e1\u01ca\3\2\2\2\u01e1\u01cd\3")
        buf.write("\2\2\2\u01e1\u01cf\3\2\2\2\u01e1\u01d1\3\2\2\2\u01e1\u01d4")
        buf.write("\3\2\2\2\u01e1\u01d6\3\2\2\2\u01e1\u01d8\3\2\2\2\u01e1")
        buf.write("\u01d9\3\2\2\2\u01e1\u01da\3\2\2\2\u01e1\u01db\3\2\2\2")
        buf.write("\u01e1\u01dc\3\2\2\2\u01e1\u01dd\3\2\2\2\u01e1\u01de\3")
        buf.write("\2\2\2\u01e1\u01df\3\2\2\2\u01e1\u01e0\3\2\2\2\u01e2=")
        buf.write("\3\2\2\2\u01e3\u01eb\5@!\2\u01e4\u01eb\5B\"\2\u01e5\u01eb")
        buf.write("\5D#\2\u01e6\u01eb\5H%\2\u01e7\u01eb\5J&\2\u01e8\u01eb")
        buf.write("\5L\'\2\u01e9\u01eb\5N(\2\u01ea\u01e3\3\2\2\2\u01ea\u01e4")
        buf.write("\3\2\2\2\u01ea\u01e5\3\2\2\2\u01ea\u01e6\3\2\2\2\u01ea")
        buf.write("\u01e7\3\2\2\2\u01ea\u01e8\3\2\2\2\u01ea\u01e9\3\2\2\2")
        buf.write("\u01eb?\3\2\2\2\u01ec\u01ed\5\62\32\2\u01ed\u01ee\5<\37")
        buf.write("\2\u01ee\u01ef\5\62\32\2\u01efA\3\2\2\2\u01f0\u01f1\5")
        buf.write("\62\32\2\u01f1\u01f2\5P)\2\u01f2\u01f3\5d\63\2\u01f3C")
        buf.write("\3\2\2\2\u01f4\u01f5\5\62\32\2\u01f5\u01f6\t\5\2\2\u01f6")
        buf.write("\u01f7\5d\63\2\u01f7\u01f8\5h\65\2\u01f8\u01f9\5b\62\2")
        buf.write("\u01f9E\3\2\2\2\u01fa\u01fb\t\6\2\2\u01fbG\3\2\2\2\u01fc")
        buf.write("\u01fd\5\62\32\2\u01fd\u01fe\7=\2\2\u01fe\u0200\5\62\32")
        buf.write("\2\u01ff\u0201\5F$\2\u0200\u01ff\3\2\2\2\u0200\u0201\3")
        buf.write("\2\2\2\u0201\u0202\3\2\2\2\u0202\u0206\5d\63\2\u0203\u0204")
        buf.write("\7>\2\2\u0204\u0207\7?\2\2\u0205\u0207\7@\2\2\u0206\u0203")
        buf.write("\3\2\2\2\u0206\u0205\3\2\2\2\u0207\u020b\3\2\2\2\u0208")
        buf.write("\u0209\5R*\2\u0209\u020a\5b\62\2\u020a\u020c\3\2\2\2\u020b")
        buf.write("\u0208\3\2\2\2\u020b\u020c\3\2\2\2\u020cI\3\2\2\2\u020d")
        buf.write("\u020f\5\62\32\2\u020e\u0210\5F$\2\u020f\u020e\3\2\2\2")
        buf.write("\u020f\u0210\3\2\2\2\u0210\u0214\3\2\2\2\u0211\u0213\t")
        buf.write("\7\2\2\u0212\u0211\3\2\2\2\u0213\u0216\3\2\2\2\u0214\u0212")
        buf.write("\3\2\2\2\u0214\u0215\3\2\2\2\u0215\u0217\3\2\2\2\u0216")
        buf.write("\u0214\3\2\2\2\u0217\u021b\5d\63\2\u0218\u021a\t\b\2\2")
        buf.write("\u0219\u0218\3\2\2\2\u021a\u021d\3\2\2\2\u021b\u0219\3")
        buf.write("\2\2\2\u021b\u021c\3\2\2\2\u021c\u021e\3\2\2\2\u021d\u021b")
        buf.write("\3\2\2\2\u021e\u0222\5\62\32\2\u021f\u0220\5R*\2\u0220")
        buf.write("\u0221\5b\62\2\u0221\u0223\3\2\2\2\u0222\u021f\3\2\2\2")
        buf.write("\u0222\u0223\3\2\2\2\u0223K\3\2\2\2\u0224\u0225\5\62\32")
        buf.write("\2\u0225\u0226\5d\63\2\u0226\u0227\5\62\32\2\u0227\u0228")
        buf.write("\5h\65\2\u0228\u0229\5b\62\2\u0229M\3\2\2\2\u022a\u022b")
        buf.write("\7F\2\2\u022b\u022c\7\5\2\2\u022c\u0231\5\62\32\2\u022d")
        buf.write("\u022e\7\6\2\2\u022e\u0230\5\62\32\2\u022f\u022d\3\2\2")
        buf.write("\2\u0230\u0233\3\2\2\2\u0231\u022f\3\2\2\2\u0231\u0232")
        buf.write("\3\2\2\2\u0232\u0234\3\2\2\2\u0233\u0231\3\2\2\2\u0234")
        buf.write("\u0235\7\7\2\2\u0235O\3\2\2\2\u0236\u0237\t\t\2\2\u0237")
        buf.write("Q\3\2\2\2\u0238\u0239\t\n\2\2\u0239S\3\2\2\2\u023a\u023b")
        buf.write("\7M\2\2\u023b\u023c\5d\63\2\u023c\u0242\7\b\2\2\u023d")
        buf.write("\u0243\5^\60\2\u023e\u0243\5`\61\2\u023f\u0243\5V,\2\u0240")
        buf.write("\u0243\5X-\2\u0241\u0243\58\35\2\u0242\u023d\3\2\2\2\u0242")
        buf.write("\u023e\3\2\2\2\u0242\u023f\3\2\2\2\u0242\u0240\3\2\2\2")
        buf.write("\u0242\u0241\3\2\2\2\u0243\u024e\3\2\2\2\u0244\u024a\7")
        buf.write("\23\2\2\u0245\u024b\5^\60\2\u0246\u024b\5`\61\2\u0247")
        buf.write("\u024b\5V,\2\u0248\u024b\5X-\2\u0249\u024b\58\35\2\u024a")
        buf.write("\u0245\3\2\2\2\u024a\u0246\3\2\2\2\u024a\u0247\3\2\2\2")
        buf.write("\u024a\u0248\3\2\2\2\u024a\u0249\3\2\2\2\u024b\u024d\3")
        buf.write("\2\2\2\u024c\u0244\3\2\2\2\u024d\u0250\3\2\2\2\u024e\u024c")
        buf.write("\3\2\2\2\u024e\u024f\3\2\2\2\u024f\u0251\3\2\2\2\u0250")
        buf.write("\u024e\3\2\2\2\u0251\u0252\7\t\2\2\u0252U\3\2\2\2\u0253")
        buf.write("\u0254\7N\2\2\u0254\u0255\7\b\2\2\u0255\u025a\5Z.\2\u0256")
        buf.write("\u0257\7\6\2\2\u0257\u0259\5Z.\2\u0258\u0256\3\2\2\2\u0259")
        buf.write("\u025c\3\2\2\2\u025a\u0258\3\2\2\2\u025a\u025b\3\2\2\2")
        buf.write("\u025bW\3\2\2\2\u025c\u025a\3\2\2\2\u025d\u025e\7O\2\2")
        buf.write("\u025e\u025f\7\b\2\2\u025f\u0264\5Z.\2\u0260\u0261\7\6")
        buf.write("\2\2\u0261\u0263\5Z.\2\u0262\u0260\3\2\2\2\u0263\u0266")
        buf.write("\3\2\2\2\u0264\u0262\3\2\2\2\u0264\u0265\3\2\2\2\u0265")
        buf.write("Y\3\2\2\2\u0266\u0264\3\2\2\2\u0267\u0268\7\33\2\2\u0268")
        buf.write("\u026d\5j\66\2\u0269\u026a\7\6\2\2\u026a\u026c\5j\66\2")
        buf.write("\u026b\u0269\3\2\2\2\u026c\u026f\3\2\2\2\u026d\u026b\3")
        buf.write("\2\2\2\u026d\u026e\3\2\2\2\u026e[\3\2\2\2\u026f\u026d")
        buf.write("\3\2\2\2\u0270\u0271\7\\\2\2\u0271]\3\2\2\2\u0272\u0273")
        buf.write("\7P\2\2\u0273\u0274\7\b\2\2\u0274\u0275\5\\/\2\u0275_")
        buf.write("\3\2\2\2\u0276\u0277\7Q\2\2\u0277\u0278\7\b\2\2\u0278")
        buf.write("\u027d\5j\66\2\u0279\u027a\7\6\2\2\u027a\u027c\5j\66\2")
        buf.write("\u027b\u0279\3\2\2\2\u027c\u027f\3\2\2\2\u027d\u027b\3")
        buf.write("\2\2\2\u027d\u027e\3\2\2\2\u027ea\3\2\2\2\u027f\u027d")
        buf.write("\3\2\2\2\u0280\u0281\7_\2\2\u0281c\3\2\2\2\u0282\u0283")
        buf.write("\7`\2\2\u0283e\3\2\2\2\u0284\u0285\7a\2\2\u0285g\3\2\2")
        buf.write("\2\u0286\u0287\t\13\2\2\u0287i\3\2\2\2\u0288\u0289\7W")
        buf.write("\2\2\u0289\u028a\5b\62\2\u028a\u028b\7X\2\2\u028b\u028c")
        buf.write("\5d\63\2\u028c\u0298\3\2\2\2\u028d\u028e\7W\2\2\u028e")
        buf.write("\u028f\5b\62\2\u028f\u0290\7\21\2\2\u0290\u0291\5b\62")
        buf.write("\2\u0291\u0293\7X\2\2\u0292\u0294\5l\67\2\u0293\u0292")
        buf.write("\3\2\2\2\u0293\u0294\3\2\2\2\u0294\u0295\3\2\2\2\u0295")
        buf.write("\u0296\5d\63\2\u0296\u0298\3\2\2\2\u0297\u0288\3\2\2\2")
        buf.write("\u0297\u028d\3\2\2\2\u0298k\3\2\2\2\u0299\u029b\t\f\2")
        buf.write("\2\u029a\u0299\3\2\2\2\u029b\u029c\3\2\2\2\u029c\u029a")
        buf.write("\3\2\2\2\u029c\u029d\3\2\2\2\u029dm\3\2\2\2Ert~\u0082")
        buf.write("\u0086\u008d\u0096\u009b\u009f\u00a5\u00b2\u00b6\u00bf")
        buf.write("\u00c3\u00ce\u00d2\u00d9\u00de\u00e0\u00e3\u00ed\u00f2")
        buf.write("\u00f5\u00f8\u00fc\u0102\u0113\u011f\u0128\u0134\u0140")
        buf.write("\u014b\u0150\u0159\u0163\u0168\u016d\u0172\u0176\u017e")
        buf.write("\u0186\u018f\u0193\u019a\u01a0\u01ad\u01b6\u01e1\u01ea")
        buf.write("\u0200\u0206\u020b\u020f\u0214\u021b\u0222\u0231\u0242")
        buf.write("\u024a\u024e\u025a\u0264\u026d\u027d\u0293\u0297\u029c")
        return buf.getvalue()


class kismetParser ( Parser ):

    grammarFileName = "kismet.ebnv"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'opposes'", "'/'", "'('", "','", "')'", 
                     "':'", "'.'", "'default'", "'trait'", "'status'", "'scalar'", 
                     "'visibility'", "'@'", "'+'", "'-'", "'action'", "';'", 
                     "'costs'", "'response'", "'result'", "'location:'", 
                     "'?'", "'role'", "'extends'", "'cast'", "'<'", "'^'", 
                     "'*'", "'>'", "'tags'", "'if'", "'does not know'", 
                     "'doesnt know'", "'doesn't know'", "'did'", "'not'", 
                     "'hear'", "'didnt'", "'didn't'", "'see'", "'do'", "'receive'", 
                     "'forgets'", "'forgot'", "'forget'", "'knows'", "'hears'", 
                     "'heard'", "'saw'", "'received'", "''s'", "'s'", "'do not'", 
                     "'dont'", "'don't'", "'does not'", "'doesn't'", "'doesnt'", 
                     "'and'", "'each'", "'other'", "'eachother'", "'have'", 
                     "'has'", "'is'", "'to'", "'with'", "'pattern'", "'is missing'", 
                     "'is not'", "'isn't'", "'isnt'", "'aint'", "'missing'", 
                     "'location'", "'initialization'", "'each_turn'", "'name'", 
                     "'supports'", "'='", "'=='", "'<='", "'>='", "'!='", 
                     "'['", "']'", "'_'" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "MINUS", "PLUS", "RANDOM_TEXT", "WS", "LINE_COMMENT", 
                      "NUMBER", "NAME", "VAR" ]

    RULE_world = 0
    RULE_opposition = 1
    RULE_trait = 2
    RULE_default = 3
    RULE_trait_type = 4
    RULE_is_num = 5
    RULE_propensity = 6
    RULE_propensity_name = 7
    RULE_modifier = 8
    RULE_goto = 9
    RULE_valence = 10
    RULE_action = 11
    RULE_cost = 12
    RULE_response = 13
    RULE_add = 14
    RULE_change = 15
    RULE_visibility = 16
    RULE_action_location = 17
    RULE_loc = 18
    RULE_locWildCard = 19
    RULE_action_item = 20
    RULE_role = 21
    RULE_extension = 22
    RULE_cast_name = 23
    RULE_arg = 24
    RULE_sub = 25
    RULE_arg_type = 26
    RULE_tags = 27
    RULE_comparison = 28
    RULE_knowledge = 29
    RULE_condition = 30
    RULE_cond3 = 31
    RULE_cond1 = 32
    RULE_cond4 = 33
    RULE_inversion = 34
    RULE_cond5 = 35
    RULE_cond6 = 36
    RULE_cond7 = 37
    RULE_condpattern = 38
    RULE_tag_compare = 39
    RULE_operator = 40
    RULE_location = 41
    RULE_initialization = 42
    RULE_each_turn = 43
    RULE_cast = 44
    RULE_random_text = 45
    RULE_l_name = 46
    RULE_supports = 47
    RULE_num = 48
    RULE_name = 49
    RULE_var = 50
    RULE_comparator = 51
    RULE_num_choice = 52
    RULE_pdf = 53

    ruleNames =  [ "world", "opposition", "trait", "default", "trait_type", 
                   "is_num", "propensity", "propensity_name", "modifier", 
                   "goto", "valence", "action", "cost", "response", "add", 
                   "change", "visibility", "action_location", "loc", "locWildCard", 
                   "action_item", "role", "extension", "cast_name", "arg", 
                   "sub", "arg_type", "tags", "comparison", "knowledge", 
                   "condition", "cond3", "cond1", "cond4", "inversion", 
                   "cond5", "cond6", "cond7", "condpattern", "tag_compare", 
                   "operator", "location", "initialization", "each_turn", 
                   "cast", "random_text", "l_name", "supports", "num", "name", 
                   "var", "comparator", "num_choice", "pdf" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    T__2=3
    T__3=4
    T__4=5
    T__5=6
    T__6=7
    T__7=8
    T__8=9
    T__9=10
    T__10=11
    T__11=12
    T__12=13
    T__13=14
    T__14=15
    T__15=16
    T__16=17
    T__17=18
    T__18=19
    T__19=20
    T__20=21
    T__21=22
    T__22=23
    T__23=24
    T__24=25
    T__25=26
    T__26=27
    T__27=28
    T__28=29
    T__29=30
    T__30=31
    T__31=32
    T__32=33
    T__33=34
    T__34=35
    T__35=36
    T__36=37
    T__37=38
    T__38=39
    T__39=40
    T__40=41
    T__41=42
    T__42=43
    T__43=44
    T__44=45
    T__45=46
    T__46=47
    T__47=48
    T__48=49
    T__49=50
    T__50=51
    T__51=52
    T__52=53
    T__53=54
    T__54=55
    T__55=56
    T__56=57
    T__57=58
    T__58=59
    T__59=60
    T__60=61
    T__61=62
    T__62=63
    T__63=64
    T__64=65
    T__65=66
    T__66=67
    T__67=68
    T__68=69
    T__69=70
    T__70=71
    T__71=72
    T__72=73
    T__73=74
    T__74=75
    T__75=76
    T__76=77
    T__77=78
    T__78=79
    T__79=80
    T__80=81
    T__81=82
    T__82=83
    T__83=84
    T__84=85
    T__85=86
    T__86=87
    MINUS=88
    PLUS=89
    RANDOM_TEXT=90
    WS=91
    LINE_COMMENT=92
    NUMBER=93
    NAME=94
    VAR=95

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.7.2")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class WorldContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOF(self):
            return self.getToken(kismetParser.EOF, 0)

        def location(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.LocationContext)
            else:
                return self.getTypedRuleContext(kismetParser.LocationContext,i)


        def role(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.RoleContext)
            else:
                return self.getTypedRuleContext(kismetParser.RoleContext,i)


        def action(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.ActionContext)
            else:
                return self.getTypedRuleContext(kismetParser.ActionContext,i)


        def trait(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.TraitContext)
            else:
                return self.getTypedRuleContext(kismetParser.TraitContext,i)


        def getRuleIndex(self):
            return kismetParser.RULE_world

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWorld" ):
                listener.enterWorld(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWorld" ):
                listener.exitWorld(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWorld" ):
                return visitor.visitWorld(self)
            else:
                return visitor.visitChildren(self)




    def world(self):

        localctx = kismetParser.WorldContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_world)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 112 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 112
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [kismetParser.T__74]:
                    self.state = 108
                    self.location()
                    pass
                elif token in [kismetParser.T__22]:
                    self.state = 109
                    self.role()
                    pass
                elif token in [kismetParser.T__15, kismetParser.T__18]:
                    self.state = 110
                    self.action()
                    pass
                elif token in [kismetParser.T__7, kismetParser.T__8, kismetParser.T__9]:
                    self.state = 111
                    self.trait()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 114 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << kismetParser.T__7) | (1 << kismetParser.T__8) | (1 << kismetParser.T__9) | (1 << kismetParser.T__15) | (1 << kismetParser.T__18) | (1 << kismetParser.T__22))) != 0) or _la==kismetParser.T__74):
                    break

            self.state = 116
            self.match(kismetParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OppositionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.NameContext)
            else:
                return self.getTypedRuleContext(kismetParser.NameContext,i)


        def getRuleIndex(self):
            return kismetParser.RULE_opposition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOpposition" ):
                listener.enterOpposition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOpposition" ):
                listener.exitOpposition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOpposition" ):
                return visitor.visitOpposition(self)
            else:
                return visitor.visitChildren(self)




    def opposition(self):

        localctx = kismetParser.OppositionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_opposition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 118
            self.match(kismetParser.T__0)
            self.state = 119
            self.name()
            self.state = 124
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__1:
                self.state = 120
                self.match(kismetParser.T__1)
                self.state = 121
                self.name()
                self.state = 126
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraitContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def trait_type(self):
            return self.getTypedRuleContext(kismetParser.Trait_typeContext,0)


        def name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.NameContext)
            else:
                return self.getTypedRuleContext(kismetParser.NameContext,i)


        def arg(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.ArgContext)
            else:
                return self.getTypedRuleContext(kismetParser.ArgContext,i)


        def default(self):
            return self.getTypedRuleContext(kismetParser.DefaultContext,0)


        def is_num(self):
            return self.getTypedRuleContext(kismetParser.Is_numContext,0)


        def opposition(self):
            return self.getTypedRuleContext(kismetParser.OppositionContext,0)


        def propensity(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.PropensityContext)
            else:
                return self.getTypedRuleContext(kismetParser.PropensityContext,i)


        def getRuleIndex(self):
            return kismetParser.RULE_trait

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTrait" ):
                listener.enterTrait(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTrait" ):
                listener.exitTrait(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTrait" ):
                return visitor.visitTrait(self)
            else:
                return visitor.visitChildren(self)




    def trait(self):

        localctx = kismetParser.TraitContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_trait)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 128
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==kismetParser.T__7:
                self.state = 127
                self.default()


            self.state = 130
            self.trait_type()
            self.state = 132
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==kismetParser.T__10:
                self.state = 131
                self.is_num()


            self.state = 134
            self.name()
            self.state = 139
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__1:
                self.state = 135
                self.match(kismetParser.T__1)
                self.state = 136
                self.name()
                self.state = 141
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 142
            self.match(kismetParser.T__2)
            self.state = 143
            self.arg()
            self.state = 148
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__3:
                self.state = 144
                self.match(kismetParser.T__3)
                self.state = 145
                self.arg()
                self.state = 150
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 151
            self.match(kismetParser.T__4)
            self.state = 153
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==kismetParser.T__0:
                self.state = 152
                self.opposition()


            self.state = 155
            self.match(kismetParser.T__5)
            self.state = 157
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==kismetParser.T__13 or _la==kismetParser.T__14:
                self.state = 156
                self.propensity()


            self.state = 163
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__3:
                self.state = 159
                self.match(kismetParser.T__3)
                self.state = 160
                self.propensity()
                self.state = 165
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 166
            self.match(kismetParser.T__6)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DefaultContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return kismetParser.RULE_default

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDefault" ):
                listener.enterDefault(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDefault" ):
                listener.exitDefault(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDefault" ):
                return visitor.visitDefault(self)
            else:
                return visitor.visitChildren(self)




    def default(self):

        localctx = kismetParser.DefaultContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_default)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 168
            self.match(kismetParser.T__7)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Trait_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return kismetParser.RULE_trait_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTrait_type" ):
                listener.enterTrait_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTrait_type" ):
                listener.exitTrait_type(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTrait_type" ):
                return visitor.visitTrait_type(self)
            else:
                return visitor.visitChildren(self)




    def trait_type(self):

        localctx = kismetParser.Trait_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_trait_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 170
            _la = self._input.LA(1)
            if not(_la==kismetParser.T__8 or _la==kismetParser.T__9):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Is_numContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return kismetParser.RULE_is_num

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIs_num" ):
                listener.enterIs_num(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIs_num" ):
                listener.exitIs_num(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIs_num" ):
                return visitor.visitIs_num(self)
            else:
                return visitor.visitChildren(self)




    def is_num(self):

        localctx = kismetParser.Is_numContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_is_num)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 172
            self.match(kismetParser.T__10)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PropensityContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def modifier(self):
            return self.getTypedRuleContext(kismetParser.ModifierContext,0)


        def goto(self):
            return self.getTypedRuleContext(kismetParser.GotoContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_propensity

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPropensity" ):
                listener.enterPropensity(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPropensity" ):
                listener.exitPropensity(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPropensity" ):
                return visitor.visitPropensity(self)
            else:
                return visitor.visitChildren(self)




    def propensity(self):

        localctx = kismetParser.PropensityContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_propensity)
        try:
            self.state = 176
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,10,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 174
                self.modifier()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 175
                self.goto()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Propensity_nameContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def name(self):
            return self.getTypedRuleContext(kismetParser.NameContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_propensity_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPropensity_name" ):
                listener.enterPropensity_name(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPropensity_name" ):
                listener.exitPropensity_name(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPropensity_name" ):
                return visitor.visitPropensity_name(self)
            else:
                return visitor.visitChildren(self)




    def propensity_name(self):

        localctx = kismetParser.Propensity_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_propensity_name)
        try:
            self.state = 180
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [kismetParser.T__11]:
                self.enterOuterAlt(localctx, 1)
                self.state = 178
                self.match(kismetParser.T__11)
                pass
            elif token in [kismetParser.NAME]:
                self.enterOuterAlt(localctx, 2)
                self.state = 179
                self.name()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ModifierContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def valence(self):
            return self.getTypedRuleContext(kismetParser.ValenceContext,0)


        def propensity_name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.Propensity_nameContext)
            else:
                return self.getTypedRuleContext(kismetParser.Propensity_nameContext,i)


        def comparison(self):
            return self.getTypedRuleContext(kismetParser.ComparisonContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_modifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterModifier" ):
                listener.enterModifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitModifier" ):
                listener.exitModifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitModifier" ):
                return visitor.visitModifier(self)
            else:
                return visitor.visitChildren(self)




    def modifier(self):

        localctx = kismetParser.ModifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_modifier)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 182
            self.valence()
            self.state = 183
            self.match(kismetParser.T__2)
            self.state = 184
            self.propensity_name()
            self.state = 189
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__3:
                self.state = 185
                self.match(kismetParser.T__3)
                self.state = 186
                self.propensity_name()
                self.state = 191
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 193
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==kismetParser.T__30:
                self.state = 192
                self.comparison()


            self.state = 195
            self.match(kismetParser.T__4)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GotoContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def valence(self):
            return self.getTypedRuleContext(kismetParser.ValenceContext,0)


        def name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.NameContext)
            else:
                return self.getTypedRuleContext(kismetParser.NameContext,i)


        def comparison(self):
            return self.getTypedRuleContext(kismetParser.ComparisonContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_goto

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGoto" ):
                listener.enterGoto(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGoto" ):
                listener.exitGoto(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGoto" ):
                return visitor.visitGoto(self)
            else:
                return visitor.visitChildren(self)




    def goto(self):

        localctx = kismetParser.GotoContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_goto)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 197
            self.valence()
            self.state = 198
            self.match(kismetParser.T__12)
            self.state = 199
            self.name()
            self.state = 204
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__3:
                self.state = 200
                self.match(kismetParser.T__3)
                self.state = 201
                self.name()
                self.state = 206
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 208
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==kismetParser.T__30:
                self.state = 207
                self.comparison()


            self.state = 210
            self.match(kismetParser.T__12)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ValenceContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return kismetParser.RULE_valence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterValence" ):
                listener.enterValence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitValence" ):
                listener.exitValence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitValence" ):
                return visitor.visitValence(self)
            else:
                return visitor.visitChildren(self)




    def valence(self):

        localctx = kismetParser.ValenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_valence)
        self._la = 0 # Token type
        try:
            self.state = 222
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [kismetParser.T__13]:
                self.enterOuterAlt(localctx, 1)
                self.state = 213 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 212
                    self.match(kismetParser.T__13)
                    self.state = 215 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==kismetParser.T__13):
                        break

                pass
            elif token in [kismetParser.T__14]:
                self.enterOuterAlt(localctx, 2)
                self.state = 218 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 217
                    self.match(kismetParser.T__14)
                    self.state = 220 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==kismetParser.T__14):
                        break

                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ActionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def name(self):
            return self.getTypedRuleContext(kismetParser.NameContext,0)


        def arg(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.ArgContext)
            else:
                return self.getTypedRuleContext(kismetParser.ArgContext,i)


        def response(self):
            return self.getTypedRuleContext(kismetParser.ResponseContext,0)


        def cost(self):
            return self.getTypedRuleContext(kismetParser.CostContext,0)


        def extension(self):
            return self.getTypedRuleContext(kismetParser.ExtensionContext,0)


        def random_text(self):
            return self.getTypedRuleContext(kismetParser.Random_textContext,0)


        def action_item(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.Action_itemContext)
            else:
                return self.getTypedRuleContext(kismetParser.Action_itemContext,i)


        def getRuleIndex(self):
            return kismetParser.RULE_action

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAction" ):
                listener.enterAction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAction" ):
                listener.exitAction(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAction" ):
                return visitor.visitAction(self)
            else:
                return visitor.visitChildren(self)




    def action(self):

        localctx = kismetParser.ActionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_action)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 225
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==kismetParser.T__18:
                self.state = 224
                self.response()


            self.state = 227
            self.match(kismetParser.T__15)
            self.state = 228
            self.name()
            self.state = 229
            self.match(kismetParser.T__2)
            self.state = 230
            self.arg()
            self.state = 235
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__3:
                self.state = 231
                self.match(kismetParser.T__3)
                self.state = 232
                self.arg()
                self.state = 237
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 238
            self.match(kismetParser.T__4)
            self.state = 240
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==kismetParser.T__17:
                self.state = 239
                self.cost()


            self.state = 243
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==kismetParser.T__23:
                self.state = 242
                self.extension()


            self.state = 246
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==kismetParser.RANDOM_TEXT:
                self.state = 245
                self.random_text()


            self.state = 248
            self.match(kismetParser.T__5)
            self.state = 250
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << kismetParser.T__11) | (1 << kismetParser.T__19) | (1 << kismetParser.T__20) | (1 << kismetParser.T__29) | (1 << kismetParser.T__30))) != 0):
                self.state = 249
                self.action_item()


            self.state = 256
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__16:
                self.state = 252
                self.match(kismetParser.T__16)

                self.state = 253
                self.action_item()
                self.state = 258
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 259
            self.match(kismetParser.T__6)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CostContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def num(self):
            return self.getTypedRuleContext(kismetParser.NumContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_cost

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCost" ):
                listener.enterCost(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCost" ):
                listener.exitCost(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCost" ):
                return visitor.visitCost(self)
            else:
                return visitor.visitChildren(self)




    def cost(self):

        localctx = kismetParser.CostContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_cost)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 261
            self.match(kismetParser.T__17)
            self.state = 262
            self.num()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ResponseContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return kismetParser.RULE_response

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterResponse" ):
                listener.enterResponse(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitResponse" ):
                listener.exitResponse(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitResponse" ):
                return visitor.visitResponse(self)
            else:
                return visitor.visitChildren(self)




    def response(self):

        localctx = kismetParser.ResponseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_response)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 264
            self.match(kismetParser.T__18)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AddContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def change(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.ChangeContext)
            else:
                return self.getTypedRuleContext(kismetParser.ChangeContext,i)


        def getRuleIndex(self):
            return kismetParser.RULE_add

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAdd" ):
                listener.enterAdd(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAdd" ):
                listener.exitAdd(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAdd" ):
                return visitor.visitAdd(self)
            else:
                return visitor.visitChildren(self)




    def add(self):

        localctx = kismetParser.AddContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_add)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 266
            self.match(kismetParser.T__19)
            self.state = 267
            self.match(kismetParser.T__5)
            self.state = 268
            self.change()
            self.state = 273
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__3:
                self.state = 269
                self.match(kismetParser.T__3)
                self.state = 270
                self.change()
                self.state = 275
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ChangeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def condition(self):
            return self.getTypedRuleContext(kismetParser.ConditionContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_change

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterChange" ):
                listener.enterChange(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitChange" ):
                listener.exitChange(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitChange" ):
                return visitor.visitChange(self)
            else:
                return visitor.visitChildren(self)




    def change(self):

        localctx = kismetParser.ChangeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_change)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 276
            self.condition()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VisibilityContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def valence(self):
            return self.getTypedRuleContext(kismetParser.ValenceContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_visibility

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVisibility" ):
                listener.enterVisibility(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVisibility" ):
                listener.exitVisibility(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVisibility" ):
                return visitor.visitVisibility(self)
            else:
                return visitor.visitChildren(self)




    def visibility(self):

        localctx = kismetParser.VisibilityContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_visibility)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 278
            self.match(kismetParser.T__11)
            self.state = 279
            self.valence()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Action_locationContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def loc(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.LocContext)
            else:
                return self.getTypedRuleContext(kismetParser.LocContext,i)


        def getRuleIndex(self):
            return kismetParser.RULE_action_location

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAction_location" ):
                listener.enterAction_location(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAction_location" ):
                listener.exitAction_location(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAction_location" ):
                return visitor.visitAction_location(self)
            else:
                return visitor.visitChildren(self)




    def action_location(self):

        localctx = kismetParser.Action_locationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_action_location)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 281
            self.match(kismetParser.T__20)
            self.state = 283 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 282
                self.loc()
                self.state = 285 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==kismetParser.T__2 or _la==kismetParser.T__21 or _la==kismetParser.NAME or _la==kismetParser.VAR):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LocContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def var(self):
            return self.getTypedRuleContext(kismetParser.VarContext,0)


        def arg(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.ArgContext)
            else:
                return self.getTypedRuleContext(kismetParser.ArgContext,i)


        def name(self):
            return self.getTypedRuleContext(kismetParser.NameContext,0)


        def locWildCard(self):
            return self.getTypedRuleContext(kismetParser.LocWildCardContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_loc

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLoc" ):
                listener.enterLoc(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLoc" ):
                listener.exitLoc(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLoc" ):
                return visitor.visitLoc(self)
            else:
                return visitor.visitChildren(self)




    def loc(self):

        localctx = kismetParser.LocContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_loc)
        self._la = 0 # Token type
        try:
            self.state = 334
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [kismetParser.VAR]:
                self.enterOuterAlt(localctx, 1)
                self.state = 287
                self.var()
                self.state = 288
                self.match(kismetParser.T__2)
                self.state = 289
                self.arg()
                self.state = 294
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==kismetParser.T__3:
                    self.state = 290
                    self.match(kismetParser.T__3)
                    self.state = 291
                    self.arg()
                    self.state = 296
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 297
                self.match(kismetParser.T__4)
                pass
            elif token in [kismetParser.NAME]:
                self.enterOuterAlt(localctx, 2)
                self.state = 299
                self.name()
                self.state = 300
                self.match(kismetParser.T__2)
                self.state = 301
                self.arg()
                self.state = 306
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==kismetParser.T__3:
                    self.state = 302
                    self.match(kismetParser.T__3)
                    self.state = 303
                    self.arg()
                    self.state = 308
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 309
                self.match(kismetParser.T__4)
                pass
            elif token in [kismetParser.T__21]:
                self.enterOuterAlt(localctx, 3)
                self.state = 311
                self.locWildCard()
                self.state = 312
                self.match(kismetParser.T__2)
                self.state = 313
                self.arg()
                self.state = 318
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==kismetParser.T__3:
                    self.state = 314
                    self.match(kismetParser.T__3)
                    self.state = 315
                    self.arg()
                    self.state = 320
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 321
                self.match(kismetParser.T__4)
                pass
            elif token in [kismetParser.T__2]:
                self.enterOuterAlt(localctx, 4)
                self.state = 323
                self.match(kismetParser.T__2)
                self.state = 324
                self.arg()
                self.state = 329
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==kismetParser.T__3:
                    self.state = 325
                    self.match(kismetParser.T__3)
                    self.state = 326
                    self.arg()
                    self.state = 331
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 332
                self.match(kismetParser.T__4)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LocWildCardContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return kismetParser.RULE_locWildCard

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLocWildCard" ):
                listener.enterLocWildCard(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLocWildCard" ):
                listener.exitLocWildCard(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLocWildCard" ):
                return visitor.visitLocWildCard(self)
            else:
                return visitor.visitChildren(self)




    def locWildCard(self):

        localctx = kismetParser.LocWildCardContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_locWildCard)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 336
            self.match(kismetParser.T__21)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Action_itemContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def tags(self):
            return self.getTypedRuleContext(kismetParser.TagsContext,0)


        def comparison(self):
            return self.getTypedRuleContext(kismetParser.ComparisonContext,0)


        def action_location(self):
            return self.getTypedRuleContext(kismetParser.Action_locationContext,0)


        def add(self):
            return self.getTypedRuleContext(kismetParser.AddContext,0)


        def visibility(self):
            return self.getTypedRuleContext(kismetParser.VisibilityContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_action_item

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAction_item" ):
                listener.enterAction_item(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAction_item" ):
                listener.exitAction_item(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAction_item" ):
                return visitor.visitAction_item(self)
            else:
                return visitor.visitChildren(self)




    def action_item(self):

        localctx = kismetParser.Action_itemContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_action_item)
        try:
            self.state = 343
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [kismetParser.T__29]:
                self.enterOuterAlt(localctx, 1)
                self.state = 338
                self.tags()
                pass
            elif token in [kismetParser.T__30]:
                self.enterOuterAlt(localctx, 2)
                self.state = 339
                self.comparison()
                pass
            elif token in [kismetParser.T__20]:
                self.enterOuterAlt(localctx, 3)
                self.state = 340
                self.action_location()
                pass
            elif token in [kismetParser.T__19]:
                self.enterOuterAlt(localctx, 4)
                self.state = 341
                self.add()
                pass
            elif token in [kismetParser.T__11]:
                self.enterOuterAlt(localctx, 5)
                self.state = 342
                self.visibility()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RoleContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def name(self):
            return self.getTypedRuleContext(kismetParser.NameContext,0)


        def arg(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.ArgContext)
            else:
                return self.getTypedRuleContext(kismetParser.ArgContext,i)


        def tags(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.TagsContext)
            else:
                return self.getTypedRuleContext(kismetParser.TagsContext,i)


        def comparison(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.ComparisonContext)
            else:
                return self.getTypedRuleContext(kismetParser.ComparisonContext,i)


        def extension(self):
            return self.getTypedRuleContext(kismetParser.ExtensionContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_role

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRole" ):
                listener.enterRole(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRole" ):
                listener.exitRole(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRole" ):
                return visitor.visitRole(self)
            else:
                return visitor.visitChildren(self)




    def role(self):

        localctx = kismetParser.RoleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_role)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 345
            self.match(kismetParser.T__22)
            self.state = 346
            self.name()
            self.state = 347
            self.match(kismetParser.T__2)
            self.state = 348
            self.arg()
            self.state = 353
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__3:
                self.state = 349
                self.match(kismetParser.T__3)
                self.state = 350
                self.arg()
                self.state = 355
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 356
            self.match(kismetParser.T__4)
            self.state = 358
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==kismetParser.T__23:
                self.state = 357
                self.extension()


            self.state = 360
            self.match(kismetParser.T__5)
            self.state = 363
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [kismetParser.T__29]:
                self.state = 361
                self.tags()
                pass
            elif token in [kismetParser.T__30]:
                self.state = 362
                self.comparison()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 372
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__16:
                self.state = 365
                self.match(kismetParser.T__16)
                self.state = 368
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [kismetParser.T__29]:
                    self.state = 366
                    self.tags()
                    pass
                elif token in [kismetParser.T__30]:
                    self.state = 367
                    self.comparison()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 374
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 375
            self.match(kismetParser.T__6)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExtensionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def arg(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.ArgContext)
            else:
                return self.getTypedRuleContext(kismetParser.ArgContext,i)


        def cast_name(self):
            return self.getTypedRuleContext(kismetParser.Cast_nameContext,0)


        def name(self):
            return self.getTypedRuleContext(kismetParser.NameContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_extension

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExtension" ):
                listener.enterExtension(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExtension" ):
                listener.exitExtension(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExtension" ):
                return visitor.visitExtension(self)
            else:
                return visitor.visitChildren(self)




    def extension(self):

        localctx = kismetParser.ExtensionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_extension)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 377
            self.match(kismetParser.T__23)
            self.state = 380
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [kismetParser.T__24]:
                self.state = 378
                self.cast_name()
                pass
            elif token in [kismetParser.NAME]:
                self.state = 379
                self.name()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 382
            self.match(kismetParser.T__2)
            self.state = 383
            self.arg()
            self.state = 388
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__3:
                self.state = 384
                self.match(kismetParser.T__3)
                self.state = 385
                self.arg()
                self.state = 390
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 391
            self.match(kismetParser.T__4)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Cast_nameContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def name(self):
            return self.getTypedRuleContext(kismetParser.NameContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_cast_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCast_name" ):
                listener.enterCast_name(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCast_name" ):
                listener.exitCast_name(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCast_name" ):
                return visitor.visitCast_name(self)
            else:
                return visitor.visitChildren(self)




    def cast_name(self):

        localctx = kismetParser.Cast_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_cast_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 393
            self.match(kismetParser.T__24)
            self.state = 394
            self.name()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ArgContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def var(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.VarContext)
            else:
                return self.getTypedRuleContext(kismetParser.VarContext,i)


        def arg_type(self):
            return self.getTypedRuleContext(kismetParser.Arg_typeContext,0)


        def sub(self):
            return self.getTypedRuleContext(kismetParser.SubContext,0)


        def name(self):
            return self.getTypedRuleContext(kismetParser.NameContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_arg

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArg" ):
                listener.enterArg(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArg" ):
                listener.exitArg(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitArg" ):
                return visitor.visitArg(self)
            else:
                return visitor.visitChildren(self)




    def arg(self):

        localctx = kismetParser.ArgContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_arg)
        self._la = 0 # Token type
        try:
            self.state = 414
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,44,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 397
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << kismetParser.T__12) | (1 << kismetParser.T__25) | (1 << kismetParser.T__26) | (1 << kismetParser.T__27) | (1 << kismetParser.T__28))) != 0):
                    self.state = 396
                    self.arg_type()


                self.state = 399
                self.var()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 401
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << kismetParser.T__12) | (1 << kismetParser.T__25) | (1 << kismetParser.T__26) | (1 << kismetParser.T__27) | (1 << kismetParser.T__28))) != 0):
                    self.state = 400
                    self.arg_type()


                self.state = 403
                self.var()
                self.state = 404
                self.sub()
                self.state = 405
                self.name()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 408
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << kismetParser.T__12) | (1 << kismetParser.T__25) | (1 << kismetParser.T__26) | (1 << kismetParser.T__27) | (1 << kismetParser.T__28))) != 0):
                    self.state = 407
                    self.arg_type()


                self.state = 410
                self.var()
                self.state = 411
                self.sub()
                self.state = 412
                self.var()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SubContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return kismetParser.RULE_sub

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSub" ):
                listener.enterSub(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSub" ):
                listener.exitSub(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSub" ):
                return visitor.visitSub(self)
            else:
                return visitor.visitChildren(self)




    def sub(self):

        localctx = kismetParser.SubContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_sub)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 416
            _la = self._input.LA(1)
            if not(_la==kismetParser.T__5 or _la==kismetParser.T__6):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Arg_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return kismetParser.RULE_arg_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArg_type" ):
                listener.enterArg_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArg_type" ):
                listener.exitArg_type(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitArg_type" ):
                return visitor.visitArg_type(self)
            else:
                return visitor.visitChildren(self)




    def arg_type(self):

        localctx = kismetParser.Arg_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_arg_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 418
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << kismetParser.T__12) | (1 << kismetParser.T__25) | (1 << kismetParser.T__26) | (1 << kismetParser.T__27) | (1 << kismetParser.T__28))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TagsContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.NameContext)
            else:
                return self.getTypedRuleContext(kismetParser.NameContext,i)


        def getRuleIndex(self):
            return kismetParser.RULE_tags

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTags" ):
                listener.enterTags(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTags" ):
                listener.exitTags(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTags" ):
                return visitor.visitTags(self)
            else:
                return visitor.visitChildren(self)




    def tags(self):

        localctx = kismetParser.TagsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_tags)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 420
            self.match(kismetParser.T__29)
            self.state = 421
            self.match(kismetParser.T__5)
            self.state = 422
            self.name()
            self.state = 427
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__3:
                self.state = 423
                self.match(kismetParser.T__3)
                self.state = 424
                self.name()
                self.state = 429
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ComparisonContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def condition(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.ConditionContext)
            else:
                return self.getTypedRuleContext(kismetParser.ConditionContext,i)


        def getRuleIndex(self):
            return kismetParser.RULE_comparison

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterComparison" ):
                listener.enterComparison(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitComparison" ):
                listener.exitComparison(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitComparison" ):
                return visitor.visitComparison(self)
            else:
                return visitor.visitChildren(self)




    def comparison(self):

        localctx = kismetParser.ComparisonContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_comparison)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 430
            self.match(kismetParser.T__30)
            self.state = 431
            self.condition()
            self.state = 436
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__3:
                self.state = 432
                self.match(kismetParser.T__3)
                self.state = 433
                self.condition()
                self.state = 438
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class KnowledgeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return kismetParser.RULE_knowledge

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterKnowledge" ):
                listener.enterKnowledge(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitKnowledge" ):
                listener.exitKnowledge(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitKnowledge" ):
                return visitor.visitKnowledge(self)
            else:
                return visitor.visitChildren(self)




    def knowledge(self):

        localctx = kismetParser.KnowledgeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_knowledge)
        try:
            self.state = 479
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,47,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 439
                self.match(kismetParser.T__31)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 440
                self.match(kismetParser.T__32)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 441
                self.match(kismetParser.T__33)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 442
                self.match(kismetParser.T__34)
                self.state = 443
                self.match(kismetParser.T__35)
                self.state = 444
                self.match(kismetParser.T__36)
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 445
                self.match(kismetParser.T__37)
                self.state = 446
                self.match(kismetParser.T__36)
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 447
                self.match(kismetParser.T__38)
                self.state = 448
                self.match(kismetParser.T__36)
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 449
                self.match(kismetParser.T__34)
                self.state = 450
                self.match(kismetParser.T__35)
                self.state = 451
                self.match(kismetParser.T__39)
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 452
                self.match(kismetParser.T__37)
                self.state = 453
                self.match(kismetParser.T__39)
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 454
                self.match(kismetParser.T__38)
                self.state = 455
                self.match(kismetParser.T__39)
                pass

            elif la_ == 10:
                self.enterOuterAlt(localctx, 10)
                self.state = 456
                self.match(kismetParser.T__34)
                self.state = 457
                self.match(kismetParser.T__35)
                self.state = 458
                self.match(kismetParser.T__40)
                pass

            elif la_ == 11:
                self.enterOuterAlt(localctx, 11)
                self.state = 459
                self.match(kismetParser.T__37)
                self.state = 460
                self.match(kismetParser.T__40)
                pass

            elif la_ == 12:
                self.enterOuterAlt(localctx, 12)
                self.state = 461
                self.match(kismetParser.T__38)
                self.state = 462
                self.match(kismetParser.T__40)
                pass

            elif la_ == 13:
                self.enterOuterAlt(localctx, 13)
                self.state = 463
                self.match(kismetParser.T__34)
                self.state = 464
                self.match(kismetParser.T__35)
                self.state = 465
                self.match(kismetParser.T__41)
                pass

            elif la_ == 14:
                self.enterOuterAlt(localctx, 14)
                self.state = 466
                self.match(kismetParser.T__37)
                self.state = 467
                self.match(kismetParser.T__41)
                pass

            elif la_ == 15:
                self.enterOuterAlt(localctx, 15)
                self.state = 468
                self.match(kismetParser.T__38)
                self.state = 469
                self.match(kismetParser.T__41)
                pass

            elif la_ == 16:
                self.enterOuterAlt(localctx, 16)
                self.state = 470
                self.match(kismetParser.T__42)
                pass

            elif la_ == 17:
                self.enterOuterAlt(localctx, 17)
                self.state = 471
                self.match(kismetParser.T__43)
                pass

            elif la_ == 18:
                self.enterOuterAlt(localctx, 18)
                self.state = 472
                self.match(kismetParser.T__44)
                pass

            elif la_ == 19:
                self.enterOuterAlt(localctx, 19)
                self.state = 473
                self.match(kismetParser.T__45)
                pass

            elif la_ == 20:
                self.enterOuterAlt(localctx, 20)
                self.state = 474
                self.match(kismetParser.T__46)
                pass

            elif la_ == 21:
                self.enterOuterAlt(localctx, 21)
                self.state = 475
                self.match(kismetParser.T__47)
                pass

            elif la_ == 22:
                self.enterOuterAlt(localctx, 22)
                self.state = 476
                self.match(kismetParser.T__48)
                pass

            elif la_ == 23:
                self.enterOuterAlt(localctx, 23)
                self.state = 477
                self.match(kismetParser.T__34)
                pass

            elif la_ == 24:
                self.enterOuterAlt(localctx, 24)
                self.state = 478
                self.match(kismetParser.T__49)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConditionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def cond3(self):
            return self.getTypedRuleContext(kismetParser.Cond3Context,0)


        def cond1(self):
            return self.getTypedRuleContext(kismetParser.Cond1Context,0)


        def cond4(self):
            return self.getTypedRuleContext(kismetParser.Cond4Context,0)


        def cond5(self):
            return self.getTypedRuleContext(kismetParser.Cond5Context,0)


        def cond6(self):
            return self.getTypedRuleContext(kismetParser.Cond6Context,0)


        def cond7(self):
            return self.getTypedRuleContext(kismetParser.Cond7Context,0)


        def condpattern(self):
            return self.getTypedRuleContext(kismetParser.CondpatternContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_condition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCondition" ):
                listener.enterCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCondition" ):
                listener.exitCondition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCondition" ):
                return visitor.visitCondition(self)
            else:
                return visitor.visitChildren(self)




    def condition(self):

        localctx = kismetParser.ConditionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_condition)
        try:
            self.state = 488
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,48,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 481
                self.cond3()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 482
                self.cond1()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 483
                self.cond4()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 484
                self.cond5()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 485
                self.cond6()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 486
                self.cond7()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 487
                self.condpattern()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Cond3Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def arg(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.ArgContext)
            else:
                return self.getTypedRuleContext(kismetParser.ArgContext,i)


        def knowledge(self):
            return self.getTypedRuleContext(kismetParser.KnowledgeContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_cond3

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCond3" ):
                listener.enterCond3(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCond3" ):
                listener.exitCond3(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCond3" ):
                return visitor.visitCond3(self)
            else:
                return visitor.visitChildren(self)




    def cond3(self):

        localctx = kismetParser.Cond3Context(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_cond3)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 490
            self.arg()
            self.state = 491
            self.knowledge()
            self.state = 492
            self.arg()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Cond1Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def arg(self):
            return self.getTypedRuleContext(kismetParser.ArgContext,0)


        def tag_compare(self):
            return self.getTypedRuleContext(kismetParser.Tag_compareContext,0)


        def name(self):
            return self.getTypedRuleContext(kismetParser.NameContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_cond1

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCond1" ):
                listener.enterCond1(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCond1" ):
                listener.exitCond1(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCond1" ):
                return visitor.visitCond1(self)
            else:
                return visitor.visitChildren(self)




    def cond1(self):

        localctx = kismetParser.Cond1Context(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_cond1)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 494
            self.arg()
            self.state = 495
            self.tag_compare()
            self.state = 496
            self.name()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Cond4Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def arg(self):
            return self.getTypedRuleContext(kismetParser.ArgContext,0)


        def name(self):
            return self.getTypedRuleContext(kismetParser.NameContext,0)


        def comparator(self):
            return self.getTypedRuleContext(kismetParser.ComparatorContext,0)


        def num(self):
            return self.getTypedRuleContext(kismetParser.NumContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_cond4

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCond4" ):
                listener.enterCond4(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCond4" ):
                listener.exitCond4(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCond4" ):
                return visitor.visitCond4(self)
            else:
                return visitor.visitChildren(self)




    def cond4(self):

        localctx = kismetParser.Cond4Context(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_cond4)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 498
            self.arg()
            self.state = 499
            _la = self._input.LA(1)
            if not(_la==kismetParser.T__50 or _la==kismetParser.T__51):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 500
            self.name()
            self.state = 501
            self.comparator()
            self.state = 502
            self.num()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InversionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return kismetParser.RULE_inversion

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInversion" ):
                listener.enterInversion(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInversion" ):
                listener.exitInversion(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInversion" ):
                return visitor.visitInversion(self)
            else:
                return visitor.visitChildren(self)




    def inversion(self):

        localctx = kismetParser.InversionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_inversion)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 504
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << kismetParser.T__52) | (1 << kismetParser.T__53) | (1 << kismetParser.T__54) | (1 << kismetParser.T__55) | (1 << kismetParser.T__56) | (1 << kismetParser.T__57))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Cond5Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def arg(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.ArgContext)
            else:
                return self.getTypedRuleContext(kismetParser.ArgContext,i)


        def name(self):
            return self.getTypedRuleContext(kismetParser.NameContext,0)


        def inversion(self):
            return self.getTypedRuleContext(kismetParser.InversionContext,0)


        def operator(self):
            return self.getTypedRuleContext(kismetParser.OperatorContext,0)


        def num(self):
            return self.getTypedRuleContext(kismetParser.NumContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_cond5

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCond5" ):
                listener.enterCond5(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCond5" ):
                listener.exitCond5(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCond5" ):
                return visitor.visitCond5(self)
            else:
                return visitor.visitChildren(self)




    def cond5(self):

        localctx = kismetParser.Cond5Context(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_cond5)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 506
            self.arg()
            self.state = 507
            self.match(kismetParser.T__58)
            self.state = 508
            self.arg()
            self.state = 510
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << kismetParser.T__52) | (1 << kismetParser.T__53) | (1 << kismetParser.T__54) | (1 << kismetParser.T__55) | (1 << kismetParser.T__56) | (1 << kismetParser.T__57))) != 0):
                self.state = 509
                self.inversion()


            self.state = 512
            self.name()
            self.state = 516
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [kismetParser.T__59]:
                self.state = 513
                self.match(kismetParser.T__59)
                self.state = 514
                self.match(kismetParser.T__60)
                pass
            elif token in [kismetParser.T__61]:
                self.state = 515
                self.match(kismetParser.T__61)
                pass
            else:
                raise NoViableAltException(self)

            self.state = 521
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==kismetParser.MINUS or _la==kismetParser.PLUS:
                self.state = 518
                self.operator()
                self.state = 519
                self.num()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Cond6Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def arg(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.ArgContext)
            else:
                return self.getTypedRuleContext(kismetParser.ArgContext,i)


        def name(self):
            return self.getTypedRuleContext(kismetParser.NameContext,0)


        def inversion(self):
            return self.getTypedRuleContext(kismetParser.InversionContext,0)


        def operator(self):
            return self.getTypedRuleContext(kismetParser.OperatorContext,0)


        def num(self):
            return self.getTypedRuleContext(kismetParser.NumContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_cond6

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCond6" ):
                listener.enterCond6(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCond6" ):
                listener.exitCond6(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCond6" ):
                return visitor.visitCond6(self)
            else:
                return visitor.visitChildren(self)




    def cond6(self):

        localctx = kismetParser.Cond6Context(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_cond6)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 523
            self.arg()
            self.state = 525
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << kismetParser.T__52) | (1 << kismetParser.T__53) | (1 << kismetParser.T__54) | (1 << kismetParser.T__55) | (1 << kismetParser.T__56) | (1 << kismetParser.T__57))) != 0):
                self.state = 524
                self.inversion()


            self.state = 530
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((((_la - 63)) & ~0x3f) == 0 and ((1 << (_la - 63)) & ((1 << (kismetParser.T__62 - 63)) | (1 << (kismetParser.T__63 - 63)) | (1 << (kismetParser.T__64 - 63)))) != 0):
                self.state = 527
                _la = self._input.LA(1)
                if not(((((_la - 63)) & ~0x3f) == 0 and ((1 << (_la - 63)) & ((1 << (kismetParser.T__62 - 63)) | (1 << (kismetParser.T__63 - 63)) | (1 << (kismetParser.T__64 - 63)))) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 532
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 533
            self.name()
            self.state = 537
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__65 or _la==kismetParser.T__66:
                self.state = 534
                _la = self._input.LA(1)
                if not(_la==kismetParser.T__65 or _la==kismetParser.T__66):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 539
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 540
            self.arg()
            self.state = 544
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==kismetParser.MINUS or _la==kismetParser.PLUS:
                self.state = 541
                self.operator()
                self.state = 542
                self.num()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Cond7Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def arg(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.ArgContext)
            else:
                return self.getTypedRuleContext(kismetParser.ArgContext,i)


        def name(self):
            return self.getTypedRuleContext(kismetParser.NameContext,0)


        def comparator(self):
            return self.getTypedRuleContext(kismetParser.ComparatorContext,0)


        def num(self):
            return self.getTypedRuleContext(kismetParser.NumContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_cond7

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCond7" ):
                listener.enterCond7(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCond7" ):
                listener.exitCond7(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCond7" ):
                return visitor.visitCond7(self)
            else:
                return visitor.visitChildren(self)




    def cond7(self):

        localctx = kismetParser.Cond7Context(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_cond7)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 546
            self.arg()
            self.state = 547
            self.name()
            self.state = 548
            self.arg()
            self.state = 549
            self.comparator()
            self.state = 550
            self.num()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CondpatternContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def arg(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.ArgContext)
            else:
                return self.getTypedRuleContext(kismetParser.ArgContext,i)


        def getRuleIndex(self):
            return kismetParser.RULE_condpattern

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCondpattern" ):
                listener.enterCondpattern(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCondpattern" ):
                listener.exitCondpattern(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCondpattern" ):
                return visitor.visitCondpattern(self)
            else:
                return visitor.visitChildren(self)




    def condpattern(self):

        localctx = kismetParser.CondpatternContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_condpattern)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 552
            self.match(kismetParser.T__67)
            self.state = 553
            self.match(kismetParser.T__2)
            self.state = 554
            self.arg()
            self.state = 559
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__3:
                self.state = 555
                self.match(kismetParser.T__3)
                self.state = 556
                self.arg()
                self.state = 561
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 562
            self.match(kismetParser.T__4)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Tag_compareContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return kismetParser.RULE_tag_compare

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTag_compare" ):
                listener.enterTag_compare(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTag_compare" ):
                listener.exitTag_compare(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTag_compare" ):
                return visitor.visitTag_compare(self)
            else:
                return visitor.visitChildren(self)




    def tag_compare(self):

        localctx = kismetParser.Tag_compareContext(self, self._ctx, self.state)
        self.enterRule(localctx, 78, self.RULE_tag_compare)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 564
            _la = self._input.LA(1)
            if not(((((_la - 65)) & ~0x3f) == 0 and ((1 << (_la - 65)) & ((1 << (kismetParser.T__64 - 65)) | (1 << (kismetParser.T__68 - 65)) | (1 << (kismetParser.T__69 - 65)) | (1 << (kismetParser.T__70 - 65)) | (1 << (kismetParser.T__71 - 65)) | (1 << (kismetParser.T__72 - 65)) | (1 << (kismetParser.T__73 - 65)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OperatorContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MINUS(self):
            return self.getToken(kismetParser.MINUS, 0)

        def PLUS(self):
            return self.getToken(kismetParser.PLUS, 0)

        def getRuleIndex(self):
            return kismetParser.RULE_operator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOperator" ):
                listener.enterOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOperator" ):
                listener.exitOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOperator" ):
                return visitor.visitOperator(self)
            else:
                return visitor.visitChildren(self)




    def operator(self):

        localctx = kismetParser.OperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 80, self.RULE_operator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 566
            _la = self._input.LA(1)
            if not(_la==kismetParser.MINUS or _la==kismetParser.PLUS):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LocationContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def name(self):
            return self.getTypedRuleContext(kismetParser.NameContext,0)


        def l_name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.L_nameContext)
            else:
                return self.getTypedRuleContext(kismetParser.L_nameContext,i)


        def supports(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.SupportsContext)
            else:
                return self.getTypedRuleContext(kismetParser.SupportsContext,i)


        def initialization(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.InitializationContext)
            else:
                return self.getTypedRuleContext(kismetParser.InitializationContext,i)


        def each_turn(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.Each_turnContext)
            else:
                return self.getTypedRuleContext(kismetParser.Each_turnContext,i)


        def tags(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.TagsContext)
            else:
                return self.getTypedRuleContext(kismetParser.TagsContext,i)


        def getRuleIndex(self):
            return kismetParser.RULE_location

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLocation" ):
                listener.enterLocation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLocation" ):
                listener.exitLocation(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLocation" ):
                return visitor.visitLocation(self)
            else:
                return visitor.visitChildren(self)




    def location(self):

        localctx = kismetParser.LocationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 82, self.RULE_location)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 568
            self.match(kismetParser.T__74)
            self.state = 569
            self.name()
            self.state = 570
            self.match(kismetParser.T__5)
            self.state = 576
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [kismetParser.T__77]:
                self.state = 571
                self.l_name()
                pass
            elif token in [kismetParser.T__78]:
                self.state = 572
                self.supports()
                pass
            elif token in [kismetParser.T__75]:
                self.state = 573
                self.initialization()
                pass
            elif token in [kismetParser.T__76]:
                self.state = 574
                self.each_turn()
                pass
            elif token in [kismetParser.T__29]:
                self.state = 575
                self.tags()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 588
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__16:
                self.state = 578
                self.match(kismetParser.T__16)
                self.state = 584
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [kismetParser.T__77]:
                    self.state = 579
                    self.l_name()
                    pass
                elif token in [kismetParser.T__78]:
                    self.state = 580
                    self.supports()
                    pass
                elif token in [kismetParser.T__75]:
                    self.state = 581
                    self.initialization()
                    pass
                elif token in [kismetParser.T__76]:
                    self.state = 582
                    self.each_turn()
                    pass
                elif token in [kismetParser.T__29]:
                    self.state = 583
                    self.tags()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 590
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 591
            self.match(kismetParser.T__6)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InitializationContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def cast(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.CastContext)
            else:
                return self.getTypedRuleContext(kismetParser.CastContext,i)


        def getRuleIndex(self):
            return kismetParser.RULE_initialization

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInitialization" ):
                listener.enterInitialization(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInitialization" ):
                listener.exitInitialization(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInitialization" ):
                return visitor.visitInitialization(self)
            else:
                return visitor.visitChildren(self)




    def initialization(self):

        localctx = kismetParser.InitializationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 84, self.RULE_initialization)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 593
            self.match(kismetParser.T__75)
            self.state = 594
            self.match(kismetParser.T__5)
            self.state = 595
            self.cast()
            self.state = 600
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__3:
                self.state = 596
                self.match(kismetParser.T__3)
                self.state = 597
                self.cast()
                self.state = 602
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Each_turnContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def cast(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.CastContext)
            else:
                return self.getTypedRuleContext(kismetParser.CastContext,i)


        def getRuleIndex(self):
            return kismetParser.RULE_each_turn

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEach_turn" ):
                listener.enterEach_turn(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEach_turn" ):
                listener.exitEach_turn(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEach_turn" ):
                return visitor.visitEach_turn(self)
            else:
                return visitor.visitChildren(self)




    def each_turn(self):

        localctx = kismetParser.Each_turnContext(self, self._ctx, self.state)
        self.enterRule(localctx, 86, self.RULE_each_turn)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 603
            self.match(kismetParser.T__76)
            self.state = 604
            self.match(kismetParser.T__5)
            self.state = 605
            self.cast()
            self.state = 610
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__3:
                self.state = 606
                self.match(kismetParser.T__3)
                self.state = 607
                self.cast()
                self.state = 612
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CastContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def num_choice(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.Num_choiceContext)
            else:
                return self.getTypedRuleContext(kismetParser.Num_choiceContext,i)


        def getRuleIndex(self):
            return kismetParser.RULE_cast

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCast" ):
                listener.enterCast(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCast" ):
                listener.exitCast(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCast" ):
                return visitor.visitCast(self)
            else:
                return visitor.visitChildren(self)




    def cast(self):

        localctx = kismetParser.CastContext(self, self._ctx, self.state)
        self.enterRule(localctx, 88, self.RULE_cast)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 613
            self.match(kismetParser.T__24)
            self.state = 614
            self.num_choice()
            self.state = 619
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,62,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 615
                    self.match(kismetParser.T__3)
                    self.state = 616
                    self.num_choice() 
                self.state = 621
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,62,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Random_textContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RANDOM_TEXT(self):
            return self.getToken(kismetParser.RANDOM_TEXT, 0)

        def getRuleIndex(self):
            return kismetParser.RULE_random_text

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRandom_text" ):
                listener.enterRandom_text(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRandom_text" ):
                listener.exitRandom_text(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRandom_text" ):
                return visitor.visitRandom_text(self)
            else:
                return visitor.visitChildren(self)




    def random_text(self):

        localctx = kismetParser.Random_textContext(self, self._ctx, self.state)
        self.enterRule(localctx, 90, self.RULE_random_text)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 622
            self.match(kismetParser.RANDOM_TEXT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class L_nameContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def random_text(self):
            return self.getTypedRuleContext(kismetParser.Random_textContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_l_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterL_name" ):
                listener.enterL_name(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitL_name" ):
                listener.exitL_name(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitL_name" ):
                return visitor.visitL_name(self)
            else:
                return visitor.visitChildren(self)




    def l_name(self):

        localctx = kismetParser.L_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 92, self.RULE_l_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 624
            self.match(kismetParser.T__77)
            self.state = 625
            self.match(kismetParser.T__5)
            self.state = 626
            self.random_text()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SupportsContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def num_choice(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.Num_choiceContext)
            else:
                return self.getTypedRuleContext(kismetParser.Num_choiceContext,i)


        def getRuleIndex(self):
            return kismetParser.RULE_supports

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSupports" ):
                listener.enterSupports(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSupports" ):
                listener.exitSupports(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSupports" ):
                return visitor.visitSupports(self)
            else:
                return visitor.visitChildren(self)




    def supports(self):

        localctx = kismetParser.SupportsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 94, self.RULE_supports)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 628
            self.match(kismetParser.T__78)
            self.state = 629
            self.match(kismetParser.T__5)
            self.state = 630
            self.num_choice()
            self.state = 635
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__3:
                self.state = 631
                self.match(kismetParser.T__3)
                self.state = 632
                self.num_choice()
                self.state = 637
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NumContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NUMBER(self):
            return self.getToken(kismetParser.NUMBER, 0)

        def getRuleIndex(self):
            return kismetParser.RULE_num

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNum" ):
                listener.enterNum(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNum" ):
                listener.exitNum(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNum" ):
                return visitor.visitNum(self)
            else:
                return visitor.visitChildren(self)




    def num(self):

        localctx = kismetParser.NumContext(self, self._ctx, self.state)
        self.enterRule(localctx, 96, self.RULE_num)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 638
            self.match(kismetParser.NUMBER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NameContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NAME(self):
            return self.getToken(kismetParser.NAME, 0)

        def getRuleIndex(self):
            return kismetParser.RULE_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterName" ):
                listener.enterName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitName" ):
                listener.exitName(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitName" ):
                return visitor.visitName(self)
            else:
                return visitor.visitChildren(self)




    def name(self):

        localctx = kismetParser.NameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 98, self.RULE_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 640
            self.match(kismetParser.NAME)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VarContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def VAR(self):
            return self.getToken(kismetParser.VAR, 0)

        def getRuleIndex(self):
            return kismetParser.RULE_var

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVar" ):
                listener.enterVar(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVar" ):
                listener.exitVar(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVar" ):
                return visitor.visitVar(self)
            else:
                return visitor.visitChildren(self)




    def var(self):

        localctx = kismetParser.VarContext(self, self._ctx, self.state)
        self.enterRule(localctx, 100, self.RULE_var)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 642
            self.match(kismetParser.VAR)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ComparatorContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return kismetParser.RULE_comparator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterComparator" ):
                listener.enterComparator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitComparator" ):
                listener.exitComparator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitComparator" ):
                return visitor.visitComparator(self)
            else:
                return visitor.visitChildren(self)




    def comparator(self):

        localctx = kismetParser.ComparatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 102, self.RULE_comparator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 644
            _la = self._input.LA(1)
            if not(((((_la - 26)) & ~0x3f) == 0 and ((1 << (_la - 26)) & ((1 << (kismetParser.T__25 - 26)) | (1 << (kismetParser.T__28 - 26)) | (1 << (kismetParser.T__79 - 26)) | (1 << (kismetParser.T__80 - 26)) | (1 << (kismetParser.T__81 - 26)) | (1 << (kismetParser.T__82 - 26)) | (1 << (kismetParser.T__83 - 26)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Num_choiceContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def num(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.NumContext)
            else:
                return self.getTypedRuleContext(kismetParser.NumContext,i)


        def name(self):
            return self.getTypedRuleContext(kismetParser.NameContext,0)


        def pdf(self):
            return self.getTypedRuleContext(kismetParser.PdfContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_num_choice

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNum_choice" ):
                listener.enterNum_choice(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNum_choice" ):
                listener.exitNum_choice(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNum_choice" ):
                return visitor.visitNum_choice(self)
            else:
                return visitor.visitChildren(self)




    def num_choice(self):

        localctx = kismetParser.Num_choiceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 104, self.RULE_num_choice)
        self._la = 0 # Token type
        try:
            self.state = 661
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,65,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 646
                self.match(kismetParser.T__84)
                self.state = 647
                self.num()
                self.state = 648
                self.match(kismetParser.T__85)
                self.state = 649
                self.name()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 651
                self.match(kismetParser.T__84)
                self.state = 652
                self.num()
                self.state = 653
                self.match(kismetParser.T__14)
                self.state = 654
                self.num()
                self.state = 655
                self.match(kismetParser.T__85)
                self.state = 657
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << kismetParser.T__6) | (1 << kismetParser.T__14) | (1 << kismetParser.T__26))) != 0) or _la==kismetParser.T__86:
                    self.state = 656
                    self.pdf()


                self.state = 659
                self.name()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PdfContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return kismetParser.RULE_pdf

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPdf" ):
                listener.enterPdf(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPdf" ):
                listener.exitPdf(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPdf" ):
                return visitor.visitPdf(self)
            else:
                return visitor.visitChildren(self)




    def pdf(self):

        localctx = kismetParser.PdfContext(self, self._ctx, self.state)
        self.enterRule(localctx, 106, self.RULE_pdf)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 664 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 663
                _la = self._input.LA(1)
                if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << kismetParser.T__6) | (1 << kismetParser.T__14) | (1 << kismetParser.T__26))) != 0) or _la==kismetParser.T__86):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 666 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << kismetParser.T__6) | (1 << kismetParser.T__14) | (1 << kismetParser.T__26))) != 0) or _la==kismetParser.T__86):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





