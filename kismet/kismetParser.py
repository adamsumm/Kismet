# Generated from kismet.ebnv by ANTLR 4.7.2
# encoding: utf-8
from antlr4 import *
from io import StringIO
from typing.io import TextIO
import sys


def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3b")
        buf.write("\u02b6\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\4\23\t\23")
        buf.write("\4\24\t\24\4\25\t\25\4\26\t\26\4\27\t\27\4\30\t\30\4\31")
        buf.write("\t\31\4\32\t\32\4\33\t\33\4\34\t\34\4\35\t\35\4\36\t\36")
        buf.write("\4\37\t\37\4 \t \4!\t!\4\"\t\"\4#\t#\4$\t$\4%\t%\4&\t")
        buf.write("&\4\'\t\'\4(\t(\4)\t)\4*\t*\4+\t+\4,\t,\4-\t-\4.\t.\4")
        buf.write("/\t/\4\60\t\60\4\61\t\61\4\62\t\62\4\63\t\63\4\64\t\64")
        buf.write("\4\65\t\65\4\66\t\66\4\67\t\67\48\t8\49\t9\3\2\3\2\3\2")
        buf.write("\3\2\3\2\6\2x\n\2\r\2\16\2y\3\2\3\2\3\3\3\3\3\3\3\3\3")
        buf.write("\3\3\3\7\3\u0084\n\3\f\3\16\3\u0087\13\3\3\3\3\3\3\3\3")
        buf.write("\3\3\3\3\4\3\4\3\4\3\4\7\4\u0092\n\4\f\4\16\4\u0095\13")
        buf.write("\4\3\5\5\5\u0098\n\5\3\5\3\5\5\5\u009c\n\5\3\5\3\5\3\5")
        buf.write("\7\5\u00a1\n\5\f\5\16\5\u00a4\13\5\3\5\3\5\3\5\3\5\7\5")
        buf.write("\u00aa\n\5\f\5\16\5\u00ad\13\5\3\5\3\5\5\5\u00b1\n\5\3")
        buf.write("\5\3\5\5\5\u00b5\n\5\3\5\3\5\7\5\u00b9\n\5\f\5\16\5\u00bc")
        buf.write("\13\5\3\5\3\5\3\6\3\6\3\7\3\7\3\b\3\b\3\t\3\t\5\t\u00c8")
        buf.write("\n\t\3\n\3\n\5\n\u00cc\n\n\3\13\3\13\3\13\3\13\3\13\7")
        buf.write("\13\u00d3\n\13\f\13\16\13\u00d6\13\13\3\13\5\13\u00d9")
        buf.write("\n\13\3\13\3\13\3\f\3\f\3\f\3\f\3\f\7\f\u00e2\n\f\f\f")
        buf.write("\16\f\u00e5\13\f\3\f\5\f\u00e8\n\f\3\f\3\f\3\r\6\r\u00ed")
        buf.write("\n\r\r\r\16\r\u00ee\3\r\6\r\u00f2\n\r\r\r\16\r\u00f3\5")
        buf.write("\r\u00f6\n\r\3\16\5\16\u00f9\n\16\3\16\3\16\3\16\3\16")
        buf.write("\3\16\3\16\7\16\u0101\n\16\f\16\16\16\u0104\13\16\3\16")
        buf.write("\3\16\5\16\u0108\n\16\3\16\5\16\u010b\n\16\3\16\5\16\u010e")
        buf.write("\n\16\3\16\3\16\5\16\u0112\n\16\3\16\3\16\7\16\u0116\n")
        buf.write("\16\f\16\16\16\u0119\13\16\3\16\3\16\3\17\3\17\3\17\3")
        buf.write("\20\3\20\3\21\3\21\3\21\3\21\3\21\7\21\u0127\n\21\f\21")
        buf.write("\16\21\u012a\13\21\3\22\3\22\3\23\3\23\3\23\3\24\3\24")
        buf.write("\6\24\u0133\n\24\r\24\16\24\u0134\3\25\3\25\3\25\3\25")
        buf.write("\3\25\7\25\u013c\n\25\f\25\16\25\u013f\13\25\3\25\3\25")
        buf.write("\3\25\3\25\3\25\3\25\3\25\7\25\u0148\n\25\f\25\16\25\u014b")
        buf.write("\13\25\3\25\3\25\3\25\3\25\3\25\3\25\3\25\7\25\u0154\n")
        buf.write("\25\f\25\16\25\u0157\13\25\3\25\3\25\3\25\3\25\3\25\3")
        buf.write("\25\7\25\u015f\n\25\f\25\16\25\u0162\13\25\3\25\3\25\5")
        buf.write("\25\u0166\n\25\3\26\3\26\3\27\3\27\3\27\3\27\3\27\5\27")
        buf.write("\u016f\n\27\3\30\3\30\3\30\3\30\3\30\3\30\7\30\u0177\n")
        buf.write("\30\f\30\16\30\u017a\13\30\3\30\3\30\5\30\u017e\n\30\3")
        buf.write("\30\3\30\3\30\5\30\u0183\n\30\3\30\3\30\3\30\5\30\u0188")
        buf.write("\n\30\7\30\u018a\n\30\f\30\16\30\u018d\13\30\3\30\3\30")
        buf.write("\3\31\3\31\3\31\5\31\u0194\n\31\3\31\3\31\3\31\3\31\7")
        buf.write("\31\u019a\n\31\f\31\16\31\u019d\13\31\3\31\3\31\3\32\3")
        buf.write("\32\3\32\3\33\5\33\u01a5\n\33\3\33\3\33\5\33\u01a9\n\33")
        buf.write("\3\33\3\33\3\33\3\33\3\33\5\33\u01b0\n\33\3\33\3\33\3")
        buf.write("\33\3\33\5\33\u01b6\n\33\3\34\3\34\3\35\3\35\3\36\3\36")
        buf.write("\3\36\3\36\3\36\7\36\u01c1\n\36\f\36\16\36\u01c4\13\36")
        buf.write("\3\37\3\37\3\37\3\37\7\37\u01ca\n\37\f\37\16\37\u01cd")
        buf.write("\13\37\3 \3 \3 \3 \3 \3 \3 \3 \3 \3 \3 \3 \3 \3 \3 \3")
        buf.write(" \3 \3 \3 \3 \3 \3 \3 \3 \3 \3 \3 \3 \3 \3 \3 \3 \3 \3")
        buf.write(" \3 \3 \3 \3 \3 \3 \5 \u01f7\n \3!\3!\3!\3!\3!\3!\3!\5")
        buf.write("!\u0200\n!\3\"\3\"\3\"\3\"\3#\3#\3#\3#\3$\3$\3$\3$\3$")
        buf.write("\3$\3%\3%\3&\3&\3&\3&\5&\u0216\n&\3&\3&\3&\3&\5&\u021c")
        buf.write("\n&\3&\3&\3&\5&\u0221\n&\3\'\3\'\5\'\u0225\n\'\3\'\7\'")
        buf.write("\u0228\n\'\f\'\16\'\u022b\13\'\3\'\3\'\7\'\u022f\n\'\f")
        buf.write("\'\16\'\u0232\13\'\3\'\3\'\3\'\3\'\5\'\u0238\n\'\3(\3")
        buf.write("(\3(\3(\3(\3(\3)\3)\3)\3)\3)\7)\u0245\n)\f)\16)\u0248")
        buf.write("\13)\3)\3)\3*\3*\3+\3+\3,\3,\3,\3,\3,\3,\3,\3,\5,\u0258")
        buf.write("\n,\3,\3,\3,\3,\3,\3,\5,\u0260\n,\7,\u0262\n,\f,\16,\u0265")
        buf.write("\13,\3,\3,\3-\3-\3-\3-\3-\7-\u026e\n-\f-\16-\u0271\13")
        buf.write("-\3.\3.\3.\3.\3.\7.\u0278\n.\f.\16.\u027b\13.\3/\3/\3")
        buf.write("/\3/\7/\u0281\n/\f/\16/\u0284\13/\3\60\3\60\3\61\3\61")
        buf.write("\3\61\3\61\3\62\3\62\3\62\3\62\3\62\7\62\u0291\n\62\f")
        buf.write("\62\16\62\u0294\13\62\3\63\3\63\3\64\3\64\3\65\3\65\3")
        buf.write("\66\3\66\3\67\3\67\38\38\38\38\38\38\38\38\38\38\38\5")
        buf.write("8\u02ab\n8\38\38\58\u02af\n8\39\69\u02b2\n9\r9\169\u02b3")
        buf.write("\39\2\2:\2\4\6\b\n\f\16\20\22\24\26\30\32\34\36 \"$&(")
        buf.write("*,.\60\62\64\668:<>@BDFHJLNPRTVXZ\\^`bdfhjlnp\2\r\3\2")
        buf.write("\f\r\3\2\7\b\4\2\20\20\34\37\3\2\65\66\3\2\67<\3\2AC\3")
        buf.write("\2DE\4\2CCFK\3\2YZ\5\2\34\34\37\37QU\6\2\b\b\35\35XX`")
        buf.write("`\2\u02eb\2w\3\2\2\2\4}\3\2\2\2\6\u008d\3\2\2\2\b\u0097")
        buf.write("\3\2\2\2\n\u00bf\3\2\2\2\f\u00c1\3\2\2\2\16\u00c3\3\2")
        buf.write("\2\2\20\u00c7\3\2\2\2\22\u00cb\3\2\2\2\24\u00cd\3\2\2")
        buf.write("\2\26\u00dc\3\2\2\2\30\u00f5\3\2\2\2\32\u00f8\3\2\2\2")
        buf.write("\34\u011c\3\2\2\2\36\u011f\3\2\2\2 \u0121\3\2\2\2\"\u012b")
        buf.write("\3\2\2\2$\u012d\3\2\2\2&\u0130\3\2\2\2(\u0165\3\2\2\2")
        buf.write("*\u0167\3\2\2\2,\u016e\3\2\2\2.\u0170\3\2\2\2\60\u0190")
        buf.write("\3\2\2\2\62\u01a0\3\2\2\2\64\u01b5\3\2\2\2\66\u01b7\3")
        buf.write("\2\2\28\u01b9\3\2\2\2:\u01bb\3\2\2\2<\u01c5\3\2\2\2>\u01f6")
        buf.write("\3\2\2\2@\u01ff\3\2\2\2B\u0201\3\2\2\2D\u0205\3\2\2\2")
        buf.write("F\u0209\3\2\2\2H\u020f\3\2\2\2J\u0211\3\2\2\2L\u0222\3")
        buf.write("\2\2\2N\u0239\3\2\2\2P\u023f\3\2\2\2R\u024b\3\2\2\2T\u024d")
        buf.write("\3\2\2\2V\u024f\3\2\2\2X\u0268\3\2\2\2Z\u0272\3\2\2\2")
        buf.write("\\\u027c\3\2\2\2^\u0285\3\2\2\2`\u0287\3\2\2\2b\u028b")
        buf.write("\3\2\2\2d\u0295\3\2\2\2f\u0297\3\2\2\2h\u0299\3\2\2\2")
        buf.write("j\u029b\3\2\2\2l\u029d\3\2\2\2n\u02ae\3\2\2\2p\u02b1\3")
        buf.write("\2\2\2rx\5V,\2sx\5.\30\2tx\5\32\16\2ux\5\b\5\2vx\5\4\3")
        buf.write("\2wr\3\2\2\2ws\3\2\2\2wt\3\2\2\2wu\3\2\2\2wv\3\2\2\2x")
        buf.write("y\3\2\2\2yw\3\2\2\2yz\3\2\2\2z{\3\2\2\2{|\7\2\2\3|\3\3")
        buf.write("\2\2\2}~\7\3\2\2~\177\5h\65\2\177\u0080\7\4\2\2\u0080")
        buf.write("\u0085\5\64\33\2\u0081\u0082\7\5\2\2\u0082\u0084\5\64")
        buf.write("\33\2\u0083\u0081\3\2\2\2\u0084\u0087\3\2\2\2\u0085\u0083")
        buf.write("\3\2\2\2\u0085\u0086\3\2\2\2\u0086\u0088\3\2\2\2\u0087")
        buf.write("\u0085\3\2\2\2\u0088\u0089\7\6\2\2\u0089\u008a\7\7\2\2")
        buf.write("\u008a\u008b\5<\37\2\u008b\u008c\7\b\2\2\u008c\5\3\2\2")
        buf.write("\2\u008d\u008e\7\t\2\2\u008e\u0093\5h\65\2\u008f\u0090")
        buf.write("\7\n\2\2\u0090\u0092\5h\65\2\u0091\u008f\3\2\2\2\u0092")
        buf.write("\u0095\3\2\2\2\u0093\u0091\3\2\2\2\u0093\u0094\3\2\2\2")
        buf.write("\u0094\7\3\2\2\2\u0095\u0093\3\2\2\2\u0096\u0098\5\n\6")
        buf.write("\2\u0097\u0096\3\2\2\2\u0097\u0098\3\2\2\2\u0098\u0099")
        buf.write("\3\2\2\2\u0099\u009b\5\f\7\2\u009a\u009c\5\16\b\2\u009b")
        buf.write("\u009a\3\2\2\2\u009b\u009c\3\2\2\2\u009c\u009d\3\2\2\2")
        buf.write("\u009d\u00a2\5h\65\2\u009e\u009f\7\n\2\2\u009f\u00a1\5")
        buf.write("h\65\2\u00a0\u009e\3\2\2\2\u00a1\u00a4\3\2\2\2\u00a2\u00a0")
        buf.write("\3\2\2\2\u00a2\u00a3\3\2\2\2\u00a3\u00a5\3\2\2\2\u00a4")
        buf.write("\u00a2\3\2\2\2\u00a5\u00a6\7\4\2\2\u00a6\u00ab\5\64\33")
        buf.write("\2\u00a7\u00a8\7\5\2\2\u00a8\u00aa\5\64\33\2\u00a9\u00a7")
        buf.write("\3\2\2\2\u00aa\u00ad\3\2\2\2\u00ab\u00a9\3\2\2\2\u00ab")
        buf.write("\u00ac\3\2\2\2\u00ac\u00ae\3\2\2\2\u00ad\u00ab\3\2\2\2")
        buf.write("\u00ae\u00b0\7\6\2\2\u00af\u00b1\5\6\4\2\u00b0\u00af\3")
        buf.write("\2\2\2\u00b0\u00b1\3\2\2\2\u00b1\u00b2\3\2\2\2\u00b2\u00b4")
        buf.write("\7\7\2\2\u00b3\u00b5\5\20\t\2\u00b4\u00b3\3\2\2\2\u00b4")
        buf.write("\u00b5\3\2\2\2\u00b5\u00ba\3\2\2\2\u00b6\u00b7\7\5\2\2")
        buf.write("\u00b7\u00b9\5\20\t\2\u00b8\u00b6\3\2\2\2\u00b9\u00bc")
        buf.write("\3\2\2\2\u00ba\u00b8\3\2\2\2\u00ba\u00bb\3\2\2\2\u00bb")
        buf.write("\u00bd\3\2\2\2\u00bc\u00ba\3\2\2\2\u00bd\u00be\7\b\2\2")
        buf.write("\u00be\t\3\2\2\2\u00bf\u00c0\7\13\2\2\u00c0\13\3\2\2\2")
        buf.write("\u00c1\u00c2\t\2\2\2\u00c2\r\3\2\2\2\u00c3\u00c4\7\16")
        buf.write("\2\2\u00c4\17\3\2\2\2\u00c5\u00c8\5\24\13\2\u00c6\u00c8")
        buf.write("\5\26\f\2\u00c7\u00c5\3\2\2\2\u00c7\u00c6\3\2\2\2\u00c8")
        buf.write("\21\3\2\2\2\u00c9\u00cc\7\17\2\2\u00ca\u00cc\5h\65\2\u00cb")
        buf.write("\u00c9\3\2\2\2\u00cb\u00ca\3\2\2\2\u00cc\23\3\2\2\2\u00cd")
        buf.write("\u00ce\5\30\r\2\u00ce\u00cf\7\4\2\2\u00cf\u00d4\5\22\n")
        buf.write("\2\u00d0\u00d1\7\5\2\2\u00d1\u00d3\5\22\n\2\u00d2\u00d0")
        buf.write("\3\2\2\2\u00d3\u00d6\3\2\2\2\u00d4\u00d2\3\2\2\2\u00d4")
        buf.write("\u00d5\3\2\2\2\u00d5\u00d8\3\2\2\2\u00d6\u00d4\3\2\2\2")
        buf.write("\u00d7\u00d9\5<\37\2\u00d8\u00d7\3\2\2\2\u00d8\u00d9\3")
        buf.write("\2\2\2\u00d9\u00da\3\2\2\2\u00da\u00db\7\6\2\2\u00db\25")
        buf.write("\3\2\2\2\u00dc\u00dd\5\30\r\2\u00dd\u00de\7\20\2\2\u00de")
        buf.write("\u00e3\5h\65\2\u00df\u00e0\7\5\2\2\u00e0\u00e2\5h\65\2")
        buf.write("\u00e1\u00df\3\2\2\2\u00e2\u00e5\3\2\2\2\u00e3\u00e1\3")
        buf.write("\2\2\2\u00e3\u00e4\3\2\2\2\u00e4\u00e7\3\2\2\2\u00e5\u00e3")
        buf.write("\3\2\2\2\u00e6\u00e8\5<\37\2\u00e7\u00e6\3\2\2\2\u00e7")
        buf.write("\u00e8\3\2\2\2\u00e8\u00e9\3\2\2\2\u00e9\u00ea\7\20\2")
        buf.write("\2\u00ea\27\3\2\2\2\u00eb\u00ed\7\21\2\2\u00ec\u00eb\3")
        buf.write("\2\2\2\u00ed\u00ee\3\2\2\2\u00ee\u00ec\3\2\2\2\u00ee\u00ef")
        buf.write("\3\2\2\2\u00ef\u00f6\3\2\2\2\u00f0\u00f2\7`\2\2\u00f1")
        buf.write("\u00f0\3\2\2\2\u00f2\u00f3\3\2\2\2\u00f3\u00f1\3\2\2\2")
        buf.write("\u00f3\u00f4\3\2\2\2\u00f4\u00f6\3\2\2\2\u00f5\u00ec\3")
        buf.write("\2\2\2\u00f5\u00f1\3\2\2\2\u00f6\31\3\2\2\2\u00f7\u00f9")
        buf.write("\5\36\20\2\u00f8\u00f7\3\2\2\2\u00f8\u00f9\3\2\2\2\u00f9")
        buf.write("\u00fa\3\2\2\2\u00fa\u00fb\7\22\2\2\u00fb\u00fc\5h\65")
        buf.write("\2\u00fc\u00fd\7\4\2\2\u00fd\u0102\5\64\33\2\u00fe\u00ff")
        buf.write("\7\5\2\2\u00ff\u0101\5\64\33\2\u0100\u00fe\3\2\2\2\u0101")
        buf.write("\u0104\3\2\2\2\u0102\u0100\3\2\2\2\u0102\u0103\3\2\2\2")
        buf.write("\u0103\u0105\3\2\2\2\u0104\u0102\3\2\2\2\u0105\u0107\7")
        buf.write("\6\2\2\u0106\u0108\5\34\17\2\u0107\u0106\3\2\2\2\u0107")
        buf.write("\u0108\3\2\2\2\u0108\u010a\3\2\2\2\u0109\u010b\5\60\31")
        buf.write("\2\u010a\u0109\3\2\2\2\u010a\u010b\3\2\2\2\u010b\u010d")
        buf.write("\3\2\2\2\u010c\u010e\5^\60\2\u010d\u010c\3\2\2\2\u010d")
        buf.write("\u010e\3\2\2\2\u010e\u010f\3\2\2\2\u010f\u0111\7\7\2\2")
        buf.write("\u0110\u0112\5,\27\2\u0111\u0110\3\2\2\2\u0111\u0112\3")
        buf.write("\2\2\2\u0112\u0117\3\2\2\2\u0113\u0114\7\23\2\2\u0114")
        buf.write("\u0116\5,\27\2\u0115\u0113\3\2\2\2\u0116\u0119\3\2\2\2")
        buf.write("\u0117\u0115\3\2\2\2\u0117\u0118\3\2\2\2\u0118\u011a\3")
        buf.write("\2\2\2\u0119\u0117\3\2\2\2\u011a\u011b\7\b\2\2\u011b\33")
        buf.write("\3\2\2\2\u011c\u011d\7\24\2\2\u011d\u011e\5d\63\2\u011e")
        buf.write("\35\3\2\2\2\u011f\u0120\7\25\2\2\u0120\37\3\2\2\2\u0121")
        buf.write("\u0122\7\26\2\2\u0122\u0123\7\7\2\2\u0123\u0128\5\"\22")
        buf.write("\2\u0124\u0125\7\5\2\2\u0125\u0127\5\"\22\2\u0126\u0124")
        buf.write("\3\2\2\2\u0127\u012a\3\2\2\2\u0128\u0126\3\2\2\2\u0128")
        buf.write("\u0129\3\2\2\2\u0129!\3\2\2\2\u012a\u0128\3\2\2\2\u012b")
        buf.write("\u012c\5@!\2\u012c#\3\2\2\2\u012d\u012e\7\17\2\2\u012e")
        buf.write("\u012f\5\30\r\2\u012f%\3\2\2\2\u0130\u0132\7\27\2\2\u0131")
        buf.write("\u0133\5(\25\2\u0132\u0131\3\2\2\2\u0133\u0134\3\2\2\2")
        buf.write("\u0134\u0132\3\2\2\2\u0134\u0135\3\2\2\2\u0135\'\3\2\2")
        buf.write("\2\u0136\u0137\5j\66\2\u0137\u0138\7\4\2\2\u0138\u013d")
        buf.write("\5\64\33\2\u0139\u013a\7\5\2\2\u013a\u013c\5\64\33\2\u013b")
        buf.write("\u0139\3\2\2\2\u013c\u013f\3\2\2\2\u013d\u013b\3\2\2\2")
        buf.write("\u013d\u013e\3\2\2\2\u013e\u0140\3\2\2\2\u013f\u013d\3")
        buf.write("\2\2\2\u0140\u0141\7\6\2\2\u0141\u0166\3\2\2\2\u0142\u0143")
        buf.write("\5h\65\2\u0143\u0144\7\4\2\2\u0144\u0149\5\64\33\2\u0145")
        buf.write("\u0146\7\5\2\2\u0146\u0148\5\64\33\2\u0147\u0145\3\2\2")
        buf.write("\2\u0148\u014b\3\2\2\2\u0149\u0147\3\2\2\2\u0149\u014a")
        buf.write("\3\2\2\2\u014a\u014c\3\2\2\2\u014b\u0149\3\2\2\2\u014c")
        buf.write("\u014d\7\6\2\2\u014d\u0166\3\2\2\2\u014e\u014f\5*\26\2")
        buf.write("\u014f\u0150\7\4\2\2\u0150\u0155\5\64\33\2\u0151\u0152")
        buf.write("\7\5\2\2\u0152\u0154\5\64\33\2\u0153\u0151\3\2\2\2\u0154")
        buf.write("\u0157\3\2\2\2\u0155\u0153\3\2\2\2\u0155\u0156\3\2\2\2")
        buf.write("\u0156\u0158\3\2\2\2\u0157\u0155\3\2\2\2\u0158\u0159\7")
        buf.write("\6\2\2\u0159\u0166\3\2\2\2\u015a\u015b\7\4\2\2\u015b\u0160")
        buf.write("\5\64\33\2\u015c\u015d\7\5\2\2\u015d\u015f\5\64\33\2\u015e")
        buf.write("\u015c\3\2\2\2\u015f\u0162\3\2\2\2\u0160\u015e\3\2\2\2")
        buf.write("\u0160\u0161\3\2\2\2\u0161\u0163\3\2\2\2\u0162\u0160\3")
        buf.write("\2\2\2\u0163\u0164\7\6\2\2\u0164\u0166\3\2\2\2\u0165\u0136")
        buf.write("\3\2\2\2\u0165\u0142\3\2\2\2\u0165\u014e\3\2\2\2\u0165")
        buf.write("\u015a\3\2\2\2\u0166)\3\2\2\2\u0167\u0168\7\30\2\2\u0168")
        buf.write("+\3\2\2\2\u0169\u016f\5:\36\2\u016a\u016f\5<\37\2\u016b")
        buf.write("\u016f\5&\24\2\u016c\u016f\5 \21\2\u016d\u016f\5$\23\2")
        buf.write("\u016e\u0169\3\2\2\2\u016e\u016a\3\2\2\2\u016e\u016b\3")
        buf.write("\2\2\2\u016e\u016c\3\2\2\2\u016e\u016d\3\2\2\2\u016f-")
        buf.write("\3\2\2\2\u0170\u0171\7\31\2\2\u0171\u0172\5h\65\2\u0172")
        buf.write("\u0173\7\4\2\2\u0173\u0178\5\64\33\2\u0174\u0175\7\5\2")
        buf.write("\2\u0175\u0177\5\64\33\2\u0176\u0174\3\2\2\2\u0177\u017a")
        buf.write("\3\2\2\2\u0178\u0176\3\2\2\2\u0178\u0179\3\2\2\2\u0179")
        buf.write("\u017b\3\2\2\2\u017a\u0178\3\2\2\2\u017b\u017d\7\6\2\2")
        buf.write("\u017c\u017e\5\60\31\2\u017d\u017c\3\2\2\2\u017d\u017e")
        buf.write("\3\2\2\2\u017e\u017f\3\2\2\2\u017f\u0182\7\7\2\2\u0180")
        buf.write("\u0183\5:\36\2\u0181\u0183\5<\37\2\u0182\u0180\3\2\2\2")
        buf.write("\u0182\u0181\3\2\2\2\u0183\u018b\3\2\2\2\u0184\u0187\7")
        buf.write("\23\2\2\u0185\u0188\5:\36\2\u0186\u0188\5<\37\2\u0187")
        buf.write("\u0185\3\2\2\2\u0187\u0186\3\2\2\2\u0188\u018a\3\2\2\2")
        buf.write("\u0189\u0184\3\2\2\2\u018a\u018d\3\2\2\2\u018b\u0189\3")
        buf.write("\2\2\2\u018b\u018c\3\2\2\2\u018c\u018e\3\2\2\2\u018d\u018b")
        buf.write("\3\2\2\2\u018e\u018f\7\b\2\2\u018f/\3\2\2\2\u0190\u0193")
        buf.write("\7\32\2\2\u0191\u0194\5\62\32\2\u0192\u0194\5h\65\2\u0193")
        buf.write("\u0191\3\2\2\2\u0193\u0192\3\2\2\2\u0194\u0195\3\2\2\2")
        buf.write("\u0195\u0196\7\4\2\2\u0196\u019b\5\64\33\2\u0197\u0198")
        buf.write("\7\5\2\2\u0198\u019a\5\64\33\2\u0199\u0197\3\2\2\2\u019a")
        buf.write("\u019d\3\2\2\2\u019b\u0199\3\2\2\2\u019b\u019c\3\2\2\2")
        buf.write("\u019c\u019e\3\2\2\2\u019d\u019b\3\2\2\2\u019e\u019f\7")
        buf.write("\6\2\2\u019f\61\3\2\2\2\u01a0\u01a1\7\33\2\2\u01a1\u01a2")
        buf.write("\5h\65\2\u01a2\63\3\2\2\2\u01a3\u01a5\58\35\2\u01a4\u01a3")
        buf.write("\3\2\2\2\u01a4\u01a5\3\2\2\2\u01a5\u01a6\3\2\2\2\u01a6")
        buf.write("\u01b6\5j\66\2\u01a7\u01a9\58\35\2\u01a8\u01a7\3\2\2\2")
        buf.write("\u01a8\u01a9\3\2\2\2\u01a9\u01aa\3\2\2\2\u01aa\u01ab\5")
        buf.write("j\66\2\u01ab\u01ac\5\66\34\2\u01ac\u01ad\5h\65\2\u01ad")
        buf.write("\u01b6\3\2\2\2\u01ae\u01b0\58\35\2\u01af\u01ae\3\2\2\2")
        buf.write("\u01af\u01b0\3\2\2\2\u01b0\u01b1\3\2\2\2\u01b1\u01b2\5")
        buf.write("j\66\2\u01b2\u01b3\5\66\34\2\u01b3\u01b4\5j\66\2\u01b4")
        buf.write("\u01b6\3\2\2\2\u01b5\u01a4\3\2\2\2\u01b5\u01a8\3\2\2\2")
        buf.write("\u01b5\u01af\3\2\2\2\u01b6\65\3\2\2\2\u01b7\u01b8\t\3")
        buf.write("\2\2\u01b8\67\3\2\2\2\u01b9\u01ba\t\4\2\2\u01ba9\3\2\2")
        buf.write("\2\u01bb\u01bc\7 \2\2\u01bc\u01bd\7\7\2\2\u01bd\u01c2")
        buf.write("\5h\65\2\u01be\u01bf\7\5\2\2\u01bf\u01c1\5h\65\2\u01c0")
        buf.write("\u01be\3\2\2\2\u01c1\u01c4\3\2\2\2\u01c2\u01c0\3\2\2\2")
        buf.write("\u01c2\u01c3\3\2\2\2\u01c3;\3\2\2\2\u01c4\u01c2\3\2\2")
        buf.write("\2\u01c5\u01c6\7!\2\2\u01c6\u01cb\5@!\2\u01c7\u01c8\7")
        buf.write("\5\2\2\u01c8\u01ca\5@!\2\u01c9\u01c7\3\2\2\2\u01ca\u01cd")
        buf.write("\3\2\2\2\u01cb\u01c9\3\2\2\2\u01cb\u01cc\3\2\2\2\u01cc")
        buf.write("=\3\2\2\2\u01cd\u01cb\3\2\2\2\u01ce\u01f7\7\"\2\2\u01cf")
        buf.write("\u01f7\7#\2\2\u01d0\u01f7\7$\2\2\u01d1\u01d2\7%\2\2\u01d2")
        buf.write("\u01d3\7&\2\2\u01d3\u01f7\7\'\2\2\u01d4\u01d5\7(\2\2\u01d5")
        buf.write("\u01f7\7\'\2\2\u01d6\u01d7\7)\2\2\u01d7\u01f7\7\'\2\2")
        buf.write("\u01d8\u01d9\7%\2\2\u01d9\u01da\7&\2\2\u01da\u01f7\7*")
        buf.write("\2\2\u01db\u01dc\7(\2\2\u01dc\u01f7\7*\2\2\u01dd\u01de")
        buf.write("\7)\2\2\u01de\u01f7\7*\2\2\u01df\u01e0\7%\2\2\u01e0\u01e1")
        buf.write("\7&\2\2\u01e1\u01f7\7+\2\2\u01e2\u01e3\7(\2\2\u01e3\u01f7")
        buf.write("\7+\2\2\u01e4\u01e5\7)\2\2\u01e5\u01f7\7+\2\2\u01e6\u01e7")
        buf.write("\7%\2\2\u01e7\u01e8\7&\2\2\u01e8\u01f7\7,\2\2\u01e9\u01ea")
        buf.write("\7(\2\2\u01ea\u01f7\7,\2\2\u01eb\u01ec\7)\2\2\u01ec\u01f7")
        buf.write("\7,\2\2\u01ed\u01f7\7-\2\2\u01ee\u01f7\7.\2\2\u01ef\u01f7")
        buf.write("\7/\2\2\u01f0\u01f7\7\60\2\2\u01f1\u01f7\7\61\2\2\u01f2")
        buf.write("\u01f7\7\62\2\2\u01f3\u01f7\7\63\2\2\u01f4\u01f7\7%\2")
        buf.write("\2\u01f5\u01f7\7\64\2\2\u01f6\u01ce\3\2\2\2\u01f6\u01cf")
        buf.write("\3\2\2\2\u01f6\u01d0\3\2\2\2\u01f6\u01d1\3\2\2\2\u01f6")
        buf.write("\u01d4\3\2\2\2\u01f6\u01d6\3\2\2\2\u01f6\u01d8\3\2\2\2")
        buf.write("\u01f6\u01db\3\2\2\2\u01f6\u01dd\3\2\2\2\u01f6\u01df\3")
        buf.write("\2\2\2\u01f6\u01e2\3\2\2\2\u01f6\u01e4\3\2\2\2\u01f6\u01e6")
        buf.write("\3\2\2\2\u01f6\u01e9\3\2\2\2\u01f6\u01eb\3\2\2\2\u01f6")
        buf.write("\u01ed\3\2\2\2\u01f6\u01ee\3\2\2\2\u01f6\u01ef\3\2\2\2")
        buf.write("\u01f6\u01f0\3\2\2\2\u01f6\u01f1\3\2\2\2\u01f6\u01f2\3")
        buf.write("\2\2\2\u01f6\u01f3\3\2\2\2\u01f6\u01f4\3\2\2\2\u01f6\u01f5")
        buf.write("\3\2\2\2\u01f7?\3\2\2\2\u01f8\u0200\5B\"\2\u01f9\u0200")
        buf.write("\5D#\2\u01fa\u0200\5F$\2\u01fb\u0200\5J&\2\u01fc\u0200")
        buf.write("\5L\'\2\u01fd\u0200\5N(\2\u01fe\u0200\5P)\2\u01ff\u01f8")
        buf.write("\3\2\2\2\u01ff\u01f9\3\2\2\2\u01ff\u01fa\3\2\2\2\u01ff")
        buf.write("\u01fb\3\2\2\2\u01ff\u01fc\3\2\2\2\u01ff\u01fd\3\2\2\2")
        buf.write("\u01ff\u01fe\3\2\2\2\u0200A\3\2\2\2\u0201\u0202\5\64\33")
        buf.write("\2\u0202\u0203\5> \2\u0203\u0204\5\64\33\2\u0204C\3\2")
        buf.write("\2\2\u0205\u0206\5\64\33\2\u0206\u0207\5R*\2\u0207\u0208")
        buf.write("\5h\65\2\u0208E\3\2\2\2\u0209\u020a\5\64\33\2\u020a\u020b")
        buf.write("\t\5\2\2\u020b\u020c\5h\65\2\u020c\u020d\5l\67\2\u020d")
        buf.write("\u020e\5d\63\2\u020eG\3\2\2\2\u020f\u0210\t\6\2\2\u0210")
        buf.write("I\3\2\2\2\u0211\u0212\5\64\33\2\u0212\u0213\7=\2\2\u0213")
        buf.write("\u0215\5\64\33\2\u0214\u0216\5H%\2\u0215\u0214\3\2\2\2")
        buf.write("\u0215\u0216\3\2\2\2\u0216\u0217\3\2\2\2\u0217\u021b\5")
        buf.write("h\65\2\u0218\u0219\7>\2\2\u0219\u021c\7?\2\2\u021a\u021c")
        buf.write("\7@\2\2\u021b\u0218\3\2\2\2\u021b\u021a\3\2\2\2\u021c")
        buf.write("\u0220\3\2\2\2\u021d\u021e\5T+\2\u021e\u021f\5d\63\2\u021f")
        buf.write("\u0221\3\2\2\2\u0220\u021d\3\2\2\2\u0220\u0221\3\2\2\2")
        buf.write("\u0221K\3\2\2\2\u0222\u0224\5\64\33\2\u0223\u0225\5H%")
        buf.write("\2\u0224\u0223\3\2\2\2\u0224\u0225\3\2\2\2\u0225\u0229")
        buf.write("\3\2\2\2\u0226\u0228\t\7\2\2\u0227\u0226\3\2\2\2\u0228")
        buf.write("\u022b\3\2\2\2\u0229\u0227\3\2\2\2\u0229\u022a\3\2\2\2")
        buf.write("\u022a\u022c\3\2\2\2\u022b\u0229\3\2\2\2\u022c\u0230\5")
        buf.write("h\65\2\u022d\u022f\t\b\2\2\u022e\u022d\3\2\2\2\u022f\u0232")
        buf.write("\3\2\2\2\u0230\u022e\3\2\2\2\u0230\u0231\3\2\2\2\u0231")
        buf.write("\u0233\3\2\2\2\u0232\u0230\3\2\2\2\u0233\u0237\5\64\33")
        buf.write("\2\u0234\u0235\5T+\2\u0235\u0236\5d\63\2\u0236\u0238\3")
        buf.write("\2\2\2\u0237\u0234\3\2\2\2\u0237\u0238\3\2\2\2\u0238M")
        buf.write("\3\2\2\2\u0239\u023a\5\64\33\2\u023a\u023b\5h\65\2\u023b")
        buf.write("\u023c\5\64\33\2\u023c\u023d\5l\67\2\u023d\u023e\5d\63")
        buf.write("\2\u023eO\3\2\2\2\u023f\u0240\7\3\2\2\u0240\u0241\7\4")
        buf.write("\2\2\u0241\u0246\5h\65\2\u0242\u0243\7\5\2\2\u0243\u0245")
        buf.write("\5\64\33\2\u0244\u0242\3\2\2\2\u0245\u0248\3\2\2\2\u0246")
        buf.write("\u0244\3\2\2\2\u0246\u0247\3\2\2\2\u0247\u0249\3\2\2\2")
        buf.write("\u0248\u0246\3\2\2\2\u0249\u024a\7\6\2\2\u024aQ\3\2\2")
        buf.write("\2\u024b\u024c\t\t\2\2\u024cS\3\2\2\2\u024d\u024e\t\n")
        buf.write("\2\2\u024eU\3\2\2\2\u024f\u0250\7L\2\2\u0250\u0251\5h")
        buf.write("\65\2\u0251\u0257\7\7\2\2\u0252\u0258\5`\61\2\u0253\u0258")
        buf.write("\5b\62\2\u0254\u0258\5X-\2\u0255\u0258\5Z.\2\u0256\u0258")
        buf.write("\5:\36\2\u0257\u0252\3\2\2\2\u0257\u0253\3\2\2\2\u0257")
        buf.write("\u0254\3\2\2\2\u0257\u0255\3\2\2\2\u0257\u0256\3\2\2\2")
        buf.write("\u0258\u0263\3\2\2\2\u0259\u025f\7\23\2\2\u025a\u0260")
        buf.write("\5`\61\2\u025b\u0260\5b\62\2\u025c\u0260\5X-\2\u025d\u0260")
        buf.write("\5Z.\2\u025e\u0260\5:\36\2\u025f\u025a\3\2\2\2\u025f\u025b")
        buf.write("\3\2\2\2\u025f\u025c\3\2\2\2\u025f\u025d\3\2\2\2\u025f")
        buf.write("\u025e\3\2\2\2\u0260\u0262\3\2\2\2\u0261\u0259\3\2\2\2")
        buf.write("\u0262\u0265\3\2\2\2\u0263\u0261\3\2\2\2\u0263\u0264\3")
        buf.write("\2\2\2\u0264\u0266\3\2\2\2\u0265\u0263\3\2\2\2\u0266\u0267")
        buf.write("\7\b\2\2\u0267W\3\2\2\2\u0268\u0269\7M\2\2\u0269\u026a")
        buf.write("\7\7\2\2\u026a\u026f\5\\/\2\u026b\u026c\7\5\2\2\u026c")
        buf.write("\u026e\5\\/\2\u026d\u026b\3\2\2\2\u026e\u0271\3\2\2\2")
        buf.write("\u026f\u026d\3\2\2\2\u026f\u0270\3\2\2\2\u0270Y\3\2\2")
        buf.write("\2\u0271\u026f\3\2\2\2\u0272\u0273\7N\2\2\u0273\u0274")
        buf.write("\7\7\2\2\u0274\u0279\5\\/\2\u0275\u0276\7\5\2\2\u0276")
        buf.write("\u0278\5\\/\2\u0277\u0275\3\2\2\2\u0278\u027b\3\2\2\2")
        buf.write("\u0279\u0277\3\2\2\2\u0279\u027a\3\2\2\2\u027a[\3\2\2")
        buf.write("\2\u027b\u0279\3\2\2\2\u027c\u027d\7\33\2\2\u027d\u0282")
        buf.write("\5n8\2\u027e\u027f\7\5\2\2\u027f\u0281\5n8\2\u0280\u027e")
        buf.write("\3\2\2\2\u0281\u0284\3\2\2\2\u0282\u0280\3\2\2\2\u0282")
        buf.write("\u0283\3\2\2\2\u0283]\3\2\2\2\u0284\u0282\3\2\2\2\u0285")
        buf.write("\u0286\7[\2\2\u0286_\3\2\2\2\u0287\u0288\7O\2\2\u0288")
        buf.write("\u0289\7\7\2\2\u0289\u028a\5^\60\2\u028aa\3\2\2\2\u028b")
        buf.write("\u028c\7P\2\2\u028c\u028d\7\7\2\2\u028d\u0292\5n8\2\u028e")
        buf.write("\u028f\7\5\2\2\u028f\u0291\5n8\2\u0290\u028e\3\2\2\2\u0291")
        buf.write("\u0294\3\2\2\2\u0292\u0290\3\2\2\2\u0292\u0293\3\2\2\2")
        buf.write("\u0293c\3\2\2\2\u0294\u0292\3\2\2\2\u0295\u0296\7^\2\2")
        buf.write("\u0296e\3\2\2\2\u0297\u0298\7_\2\2\u0298g\3\2\2\2\u0299")
        buf.write("\u029a\7a\2\2\u029ai\3\2\2\2\u029b\u029c\7b\2\2\u029c")
        buf.write("k\3\2\2\2\u029d\u029e\t\13\2\2\u029em\3\2\2\2\u029f\u02a0")
        buf.write("\7V\2\2\u02a0\u02a1\5d\63\2\u02a1\u02a2\7W\2\2\u02a2\u02a3")
        buf.write("\5h\65\2\u02a3\u02af\3\2\2\2\u02a4\u02a5\7V\2\2\u02a5")
        buf.write("\u02a6\5d\63\2\u02a6\u02a7\7\7\2\2\u02a7\u02a8\5d\63\2")
        buf.write("\u02a8\u02aa\7W\2\2\u02a9\u02ab\5p9\2\u02aa\u02a9\3\2")
        buf.write("\2\2\u02aa\u02ab\3\2\2\2\u02ab\u02ac\3\2\2\2\u02ac\u02ad")
        buf.write("\5h\65\2\u02ad\u02af\3\2\2\2\u02ae\u029f\3\2\2\2\u02ae")
        buf.write("\u02a4\3\2\2\2\u02afo\3\2\2\2\u02b0\u02b2\t\f\2\2\u02b1")
        buf.write("\u02b0\3\2\2\2\u02b2\u02b3\3\2\2\2\u02b3\u02b1\3\2\2\2")
        buf.write("\u02b3\u02b4\3\2\2\2\u02b4q\3\2\2\2Fwy\u0085\u0093\u0097")
        buf.write("\u009b\u00a2\u00ab\u00b0\u00b4\u00ba\u00c7\u00cb\u00d4")
        buf.write("\u00d8\u00e3\u00e7\u00ee\u00f3\u00f5\u00f8\u0102\u0107")
        buf.write("\u010a\u010d\u0111\u0117\u0128\u0134\u013d\u0149\u0155")
        buf.write("\u0160\u0165\u016e\u0178\u017d\u0182\u0187\u018b\u0193")
        buf.write("\u019b\u01a4\u01a8\u01af\u01b5\u01c2\u01cb\u01f6\u01ff")
        buf.write("\u0215\u021b\u0220\u0224\u0229\u0230\u0237\u0246\u0257")
        buf.write("\u025f\u0263\u026f\u0279\u0282\u0292\u02aa\u02ae\u02b3")
        return buf.getvalue()


class kismetParser ( Parser ):

    grammarFileName = "kismet.ebnv"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'pattern'", "'('", "','", "')'", "':'", 
                     "'.'", "'opposes'", "'/'", "'default'", "'trait'", 
                     "'status'", "'scalar'", "'visibility'", "'@'", "'+'", 
                     "'action'", "';'", "'costs'", "'response'", "'result'", 
                     "'location:'", "'?'", "'role'", "'extends'", "'cast'", 
                     "'<'", "'^'", "'*'", "'>'", "'tags'", "'if'", "'does not know'", 
                     "'doesnt know'", "'doesn't know'", "'did'", "'not'", 
                     "'hear'", "'didnt'", "'didn't'", "'see'", "'do'", "'receive'", 
                     "'forgets'", "'forgot'", "'forget'", "'knows'", "'hears'", 
                     "'heard'", "'saw'", "'received'", "''s'", "'s'", "'do not'", 
                     "'dont'", "'don't'", "'does not'", "'doesn't'", "'doesnt'", 
                     "'and'", "'each'", "'other'", "'eachother'", "'have'", 
                     "'has'", "'is'", "'to'", "'with'", "'is missing'", 
                     "'is not'", "'isn't'", "'isnt'", "'aint'", "'missing'", 
                     "'location'", "'initialization'", "'each_turn'", "'name'", 
                     "'supports'", "'='", "'=='", "'<='", "'>='", "'!='", 
                     "'['", "']'", "'_'", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "'-'" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "MINUS", "PLUS", 
                      "RANDOM_TEXT", "WS", "LINE_COMMENT", "NUMBER", "POSITIVE_NUMBER", 
                      "NEG", "NAME", "VAR" ]

    RULE_world = 0
    RULE_pattern = 1
    RULE_opposition = 2
    RULE_trait = 3
    RULE_default = 4
    RULE_trait_type = 5
    RULE_is_num = 6
    RULE_propensity = 7
    RULE_propensity_name = 8
    RULE_modifier = 9
    RULE_goto = 10
    RULE_valence = 11
    RULE_action = 12
    RULE_cost = 13
    RULE_response = 14
    RULE_add = 15
    RULE_change = 16
    RULE_visibility = 17
    RULE_action_location = 18
    RULE_loc = 19
    RULE_locWildCard = 20
    RULE_action_item = 21
    RULE_role = 22
    RULE_extension = 23
    RULE_cast_name = 24
    RULE_arg = 25
    RULE_sub = 26
    RULE_arg_type = 27
    RULE_tags = 28
    RULE_comparison = 29
    RULE_knowledge = 30
    RULE_condition = 31
    RULE_cond3 = 32
    RULE_cond1 = 33
    RULE_cond4 = 34
    RULE_inversion = 35
    RULE_cond5 = 36
    RULE_cond6 = 37
    RULE_cond7 = 38
    RULE_condpattern = 39
    RULE_tag_compare = 40
    RULE_operator = 41
    RULE_location = 42
    RULE_initialization = 43
    RULE_each_turn = 44
    RULE_cast = 45
    RULE_random_text = 46
    RULE_l_name = 47
    RULE_supports = 48
    RULE_num = 49
    RULE_pos_num = 50
    RULE_name = 51
    RULE_var = 52
    RULE_comparator = 53
    RULE_num_choice = 54
    RULE_pdf = 55

    ruleNames =  [ "world", "pattern", "opposition", "trait", "default", 
                   "trait_type", "is_num", "propensity", "propensity_name", 
                   "modifier", "goto", "valence", "action", "cost", "response", 
                   "add", "change", "visibility", "action_location", "loc", 
                   "locWildCard", "action_item", "role", "extension", "cast_name", 
                   "arg", "sub", "arg_type", "tags", "comparison", "knowledge", 
                   "condition", "cond3", "cond1", "cond4", "inversion", 
                   "cond5", "cond6", "cond7", "condpattern", "tag_compare", 
                   "operator", "location", "initialization", "each_turn", 
                   "cast", "random_text", "l_name", "supports", "num", "pos_num", 
                   "name", "var", "comparator", "num_choice", "pdf" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    T__2=3
    T__3=4
    T__4=5
    T__5=6
    T__6=7
    T__7=8
    T__8=9
    T__9=10
    T__10=11
    T__11=12
    T__12=13
    T__13=14
    T__14=15
    T__15=16
    T__16=17
    T__17=18
    T__18=19
    T__19=20
    T__20=21
    T__21=22
    T__22=23
    T__23=24
    T__24=25
    T__25=26
    T__26=27
    T__27=28
    T__28=29
    T__29=30
    T__30=31
    T__31=32
    T__32=33
    T__33=34
    T__34=35
    T__35=36
    T__36=37
    T__37=38
    T__38=39
    T__39=40
    T__40=41
    T__41=42
    T__42=43
    T__43=44
    T__44=45
    T__45=46
    T__46=47
    T__47=48
    T__48=49
    T__49=50
    T__50=51
    T__51=52
    T__52=53
    T__53=54
    T__54=55
    T__55=56
    T__56=57
    T__57=58
    T__58=59
    T__59=60
    T__60=61
    T__61=62
    T__62=63
    T__63=64
    T__64=65
    T__65=66
    T__66=67
    T__67=68
    T__68=69
    T__69=70
    T__70=71
    T__71=72
    T__72=73
    T__73=74
    T__74=75
    T__75=76
    T__76=77
    T__77=78
    T__78=79
    T__79=80
    T__80=81
    T__81=82
    T__82=83
    T__83=84
    T__84=85
    T__85=86
    MINUS=87
    PLUS=88
    RANDOM_TEXT=89
    WS=90
    LINE_COMMENT=91
    NUMBER=92
    POSITIVE_NUMBER=93
    NEG=94
    NAME=95
    VAR=96

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.7.2")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class WorldContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOF(self):
            return self.getToken(kismetParser.EOF, 0)

        def location(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.LocationContext)
            else:
                return self.getTypedRuleContext(kismetParser.LocationContext,i)


        def role(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.RoleContext)
            else:
                return self.getTypedRuleContext(kismetParser.RoleContext,i)


        def action(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.ActionContext)
            else:
                return self.getTypedRuleContext(kismetParser.ActionContext,i)


        def trait(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.TraitContext)
            else:
                return self.getTypedRuleContext(kismetParser.TraitContext,i)


        def pattern(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.PatternContext)
            else:
                return self.getTypedRuleContext(kismetParser.PatternContext,i)


        def getRuleIndex(self):
            return kismetParser.RULE_world

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWorld" ):
                listener.enterWorld(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWorld" ):
                listener.exitWorld(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWorld" ):
                return visitor.visitWorld(self)
            else:
                return visitor.visitChildren(self)




    def world(self):

        localctx = kismetParser.WorldContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_world)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 117 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 117
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [kismetParser.T__73]:
                    self.state = 112
                    self.location()
                    pass
                elif token in [kismetParser.T__22]:
                    self.state = 113
                    self.role()
                    pass
                elif token in [kismetParser.T__15, kismetParser.T__18]:
                    self.state = 114
                    self.action()
                    pass
                elif token in [kismetParser.T__8, kismetParser.T__9, kismetParser.T__10]:
                    self.state = 115
                    self.trait()
                    pass
                elif token in [kismetParser.T__0]:
                    self.state = 116
                    self.pattern()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 119 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << kismetParser.T__0) | (1 << kismetParser.T__8) | (1 << kismetParser.T__9) | (1 << kismetParser.T__10) | (1 << kismetParser.T__15) | (1 << kismetParser.T__18) | (1 << kismetParser.T__22))) != 0) or _la==kismetParser.T__73):
                    break

            self.state = 121
            self.match(kismetParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PatternContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def name(self):
            return self.getTypedRuleContext(kismetParser.NameContext,0)


        def arg(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.ArgContext)
            else:
                return self.getTypedRuleContext(kismetParser.ArgContext,i)


        def comparison(self):
            return self.getTypedRuleContext(kismetParser.ComparisonContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_pattern

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPattern" ):
                listener.enterPattern(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPattern" ):
                listener.exitPattern(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPattern" ):
                return visitor.visitPattern(self)
            else:
                return visitor.visitChildren(self)




    def pattern(self):

        localctx = kismetParser.PatternContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_pattern)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 123
            self.match(kismetParser.T__0)
            self.state = 124
            self.name()
            self.state = 125
            self.match(kismetParser.T__1)
            self.state = 126
            self.arg()
            self.state = 131
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__2:
                self.state = 127
                self.match(kismetParser.T__2)
                self.state = 128
                self.arg()
                self.state = 133
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 134
            self.match(kismetParser.T__3)
            self.state = 135
            self.match(kismetParser.T__4)
            self.state = 136
            self.comparison()
            self.state = 137
            self.match(kismetParser.T__5)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OppositionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.NameContext)
            else:
                return self.getTypedRuleContext(kismetParser.NameContext,i)


        def getRuleIndex(self):
            return kismetParser.RULE_opposition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOpposition" ):
                listener.enterOpposition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOpposition" ):
                listener.exitOpposition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOpposition" ):
                return visitor.visitOpposition(self)
            else:
                return visitor.visitChildren(self)




    def opposition(self):

        localctx = kismetParser.OppositionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_opposition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 139
            self.match(kismetParser.T__6)
            self.state = 140
            self.name()
            self.state = 145
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__7:
                self.state = 141
                self.match(kismetParser.T__7)
                self.state = 142
                self.name()
                self.state = 147
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraitContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def trait_type(self):
            return self.getTypedRuleContext(kismetParser.Trait_typeContext,0)


        def name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.NameContext)
            else:
                return self.getTypedRuleContext(kismetParser.NameContext,i)


        def arg(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.ArgContext)
            else:
                return self.getTypedRuleContext(kismetParser.ArgContext,i)


        def default(self):
            return self.getTypedRuleContext(kismetParser.DefaultContext,0)


        def is_num(self):
            return self.getTypedRuleContext(kismetParser.Is_numContext,0)


        def opposition(self):
            return self.getTypedRuleContext(kismetParser.OppositionContext,0)


        def propensity(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.PropensityContext)
            else:
                return self.getTypedRuleContext(kismetParser.PropensityContext,i)


        def getRuleIndex(self):
            return kismetParser.RULE_trait

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTrait" ):
                listener.enterTrait(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTrait" ):
                listener.exitTrait(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTrait" ):
                return visitor.visitTrait(self)
            else:
                return visitor.visitChildren(self)




    def trait(self):

        localctx = kismetParser.TraitContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_trait)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 149
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==kismetParser.T__8:
                self.state = 148
                self.default()


            self.state = 151
            self.trait_type()
            self.state = 153
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==kismetParser.T__11:
                self.state = 152
                self.is_num()


            self.state = 155
            self.name()
            self.state = 160
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__7:
                self.state = 156
                self.match(kismetParser.T__7)
                self.state = 157
                self.name()
                self.state = 162
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 163
            self.match(kismetParser.T__1)
            self.state = 164
            self.arg()
            self.state = 169
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__2:
                self.state = 165
                self.match(kismetParser.T__2)
                self.state = 166
                self.arg()
                self.state = 171
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 172
            self.match(kismetParser.T__3)
            self.state = 174
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==kismetParser.T__6:
                self.state = 173
                self.opposition()


            self.state = 176
            self.match(kismetParser.T__4)
            self.state = 178
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==kismetParser.T__14 or _la==kismetParser.NEG:
                self.state = 177
                self.propensity()


            self.state = 184
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__2:
                self.state = 180
                self.match(kismetParser.T__2)
                self.state = 181
                self.propensity()
                self.state = 186
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 187
            self.match(kismetParser.T__5)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DefaultContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return kismetParser.RULE_default

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDefault" ):
                listener.enterDefault(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDefault" ):
                listener.exitDefault(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDefault" ):
                return visitor.visitDefault(self)
            else:
                return visitor.visitChildren(self)




    def default(self):

        localctx = kismetParser.DefaultContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_default)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 189
            self.match(kismetParser.T__8)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Trait_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return kismetParser.RULE_trait_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTrait_type" ):
                listener.enterTrait_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTrait_type" ):
                listener.exitTrait_type(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTrait_type" ):
                return visitor.visitTrait_type(self)
            else:
                return visitor.visitChildren(self)




    def trait_type(self):

        localctx = kismetParser.Trait_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_trait_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 191
            _la = self._input.LA(1)
            if not(_la==kismetParser.T__9 or _la==kismetParser.T__10):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Is_numContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return kismetParser.RULE_is_num

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIs_num" ):
                listener.enterIs_num(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIs_num" ):
                listener.exitIs_num(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIs_num" ):
                return visitor.visitIs_num(self)
            else:
                return visitor.visitChildren(self)




    def is_num(self):

        localctx = kismetParser.Is_numContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_is_num)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 193
            self.match(kismetParser.T__11)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PropensityContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def modifier(self):
            return self.getTypedRuleContext(kismetParser.ModifierContext,0)


        def goto(self):
            return self.getTypedRuleContext(kismetParser.GotoContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_propensity

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPropensity" ):
                listener.enterPropensity(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPropensity" ):
                listener.exitPropensity(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPropensity" ):
                return visitor.visitPropensity(self)
            else:
                return visitor.visitChildren(self)




    def propensity(self):

        localctx = kismetParser.PropensityContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_propensity)
        try:
            self.state = 197
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,11,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 195
                self.modifier()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 196
                self.goto()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Propensity_nameContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def name(self):
            return self.getTypedRuleContext(kismetParser.NameContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_propensity_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPropensity_name" ):
                listener.enterPropensity_name(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPropensity_name" ):
                listener.exitPropensity_name(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPropensity_name" ):
                return visitor.visitPropensity_name(self)
            else:
                return visitor.visitChildren(self)




    def propensity_name(self):

        localctx = kismetParser.Propensity_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_propensity_name)
        try:
            self.state = 201
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [kismetParser.T__12]:
                self.enterOuterAlt(localctx, 1)
                self.state = 199
                self.match(kismetParser.T__12)
                pass
            elif token in [kismetParser.NAME]:
                self.enterOuterAlt(localctx, 2)
                self.state = 200
                self.name()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ModifierContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def valence(self):
            return self.getTypedRuleContext(kismetParser.ValenceContext,0)


        def propensity_name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.Propensity_nameContext)
            else:
                return self.getTypedRuleContext(kismetParser.Propensity_nameContext,i)


        def comparison(self):
            return self.getTypedRuleContext(kismetParser.ComparisonContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_modifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterModifier" ):
                listener.enterModifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitModifier" ):
                listener.exitModifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitModifier" ):
                return visitor.visitModifier(self)
            else:
                return visitor.visitChildren(self)




    def modifier(self):

        localctx = kismetParser.ModifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_modifier)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 203
            self.valence()
            self.state = 204
            self.match(kismetParser.T__1)
            self.state = 205
            self.propensity_name()
            self.state = 210
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__2:
                self.state = 206
                self.match(kismetParser.T__2)
                self.state = 207
                self.propensity_name()
                self.state = 212
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 214
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==kismetParser.T__30:
                self.state = 213
                self.comparison()


            self.state = 216
            self.match(kismetParser.T__3)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GotoContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def valence(self):
            return self.getTypedRuleContext(kismetParser.ValenceContext,0)


        def name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.NameContext)
            else:
                return self.getTypedRuleContext(kismetParser.NameContext,i)


        def comparison(self):
            return self.getTypedRuleContext(kismetParser.ComparisonContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_goto

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGoto" ):
                listener.enterGoto(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGoto" ):
                listener.exitGoto(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGoto" ):
                return visitor.visitGoto(self)
            else:
                return visitor.visitChildren(self)




    def goto(self):

        localctx = kismetParser.GotoContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_goto)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 218
            self.valence()
            self.state = 219
            self.match(kismetParser.T__13)
            self.state = 220
            self.name()
            self.state = 225
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__2:
                self.state = 221
                self.match(kismetParser.T__2)
                self.state = 222
                self.name()
                self.state = 227
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 229
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==kismetParser.T__30:
                self.state = 228
                self.comparison()


            self.state = 231
            self.match(kismetParser.T__13)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ValenceContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NEG(self, i:int=None):
            if i is None:
                return self.getTokens(kismetParser.NEG)
            else:
                return self.getToken(kismetParser.NEG, i)

        def getRuleIndex(self):
            return kismetParser.RULE_valence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterValence" ):
                listener.enterValence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitValence" ):
                listener.exitValence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitValence" ):
                return visitor.visitValence(self)
            else:
                return visitor.visitChildren(self)




    def valence(self):

        localctx = kismetParser.ValenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_valence)
        self._la = 0 # Token type
        try:
            self.state = 243
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [kismetParser.T__14]:
                self.enterOuterAlt(localctx, 1)
                self.state = 234 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 233
                    self.match(kismetParser.T__14)
                    self.state = 236 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==kismetParser.T__14):
                        break

                pass
            elif token in [kismetParser.NEG]:
                self.enterOuterAlt(localctx, 2)
                self.state = 239 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 238
                    self.match(kismetParser.NEG)
                    self.state = 241 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==kismetParser.NEG):
                        break

                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ActionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def name(self):
            return self.getTypedRuleContext(kismetParser.NameContext,0)


        def arg(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.ArgContext)
            else:
                return self.getTypedRuleContext(kismetParser.ArgContext,i)


        def response(self):
            return self.getTypedRuleContext(kismetParser.ResponseContext,0)


        def cost(self):
            return self.getTypedRuleContext(kismetParser.CostContext,0)


        def extension(self):
            return self.getTypedRuleContext(kismetParser.ExtensionContext,0)


        def random_text(self):
            return self.getTypedRuleContext(kismetParser.Random_textContext,0)


        def action_item(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.Action_itemContext)
            else:
                return self.getTypedRuleContext(kismetParser.Action_itemContext,i)


        def getRuleIndex(self):
            return kismetParser.RULE_action

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAction" ):
                listener.enterAction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAction" ):
                listener.exitAction(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAction" ):
                return visitor.visitAction(self)
            else:
                return visitor.visitChildren(self)




    def action(self):

        localctx = kismetParser.ActionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_action)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 246
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==kismetParser.T__18:
                self.state = 245
                self.response()


            self.state = 248
            self.match(kismetParser.T__15)
            self.state = 249
            self.name()
            self.state = 250
            self.match(kismetParser.T__1)
            self.state = 251
            self.arg()
            self.state = 256
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__2:
                self.state = 252
                self.match(kismetParser.T__2)
                self.state = 253
                self.arg()
                self.state = 258
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 259
            self.match(kismetParser.T__3)
            self.state = 261
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==kismetParser.T__17:
                self.state = 260
                self.cost()


            self.state = 264
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==kismetParser.T__23:
                self.state = 263
                self.extension()


            self.state = 267
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==kismetParser.RANDOM_TEXT:
                self.state = 266
                self.random_text()


            self.state = 269
            self.match(kismetParser.T__4)
            self.state = 271
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << kismetParser.T__12) | (1 << kismetParser.T__19) | (1 << kismetParser.T__20) | (1 << kismetParser.T__29) | (1 << kismetParser.T__30))) != 0):
                self.state = 270
                self.action_item()


            self.state = 277
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__16:
                self.state = 273
                self.match(kismetParser.T__16)

                self.state = 274
                self.action_item()
                self.state = 279
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 280
            self.match(kismetParser.T__5)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CostContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def num(self):
            return self.getTypedRuleContext(kismetParser.NumContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_cost

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCost" ):
                listener.enterCost(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCost" ):
                listener.exitCost(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCost" ):
                return visitor.visitCost(self)
            else:
                return visitor.visitChildren(self)




    def cost(self):

        localctx = kismetParser.CostContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_cost)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 282
            self.match(kismetParser.T__17)
            self.state = 283
            self.num()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ResponseContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return kismetParser.RULE_response

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterResponse" ):
                listener.enterResponse(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitResponse" ):
                listener.exitResponse(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitResponse" ):
                return visitor.visitResponse(self)
            else:
                return visitor.visitChildren(self)




    def response(self):

        localctx = kismetParser.ResponseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_response)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 285
            self.match(kismetParser.T__18)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AddContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def change(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.ChangeContext)
            else:
                return self.getTypedRuleContext(kismetParser.ChangeContext,i)


        def getRuleIndex(self):
            return kismetParser.RULE_add

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAdd" ):
                listener.enterAdd(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAdd" ):
                listener.exitAdd(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAdd" ):
                return visitor.visitAdd(self)
            else:
                return visitor.visitChildren(self)




    def add(self):

        localctx = kismetParser.AddContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_add)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 287
            self.match(kismetParser.T__19)
            self.state = 288
            self.match(kismetParser.T__4)
            self.state = 289
            self.change()
            self.state = 294
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__2:
                self.state = 290
                self.match(kismetParser.T__2)
                self.state = 291
                self.change()
                self.state = 296
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ChangeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def condition(self):
            return self.getTypedRuleContext(kismetParser.ConditionContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_change

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterChange" ):
                listener.enterChange(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitChange" ):
                listener.exitChange(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitChange" ):
                return visitor.visitChange(self)
            else:
                return visitor.visitChildren(self)




    def change(self):

        localctx = kismetParser.ChangeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_change)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 297
            self.condition()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VisibilityContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def valence(self):
            return self.getTypedRuleContext(kismetParser.ValenceContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_visibility

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVisibility" ):
                listener.enterVisibility(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVisibility" ):
                listener.exitVisibility(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVisibility" ):
                return visitor.visitVisibility(self)
            else:
                return visitor.visitChildren(self)




    def visibility(self):

        localctx = kismetParser.VisibilityContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_visibility)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 299
            self.match(kismetParser.T__12)
            self.state = 300
            self.valence()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Action_locationContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def loc(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.LocContext)
            else:
                return self.getTypedRuleContext(kismetParser.LocContext,i)


        def getRuleIndex(self):
            return kismetParser.RULE_action_location

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAction_location" ):
                listener.enterAction_location(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAction_location" ):
                listener.exitAction_location(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAction_location" ):
                return visitor.visitAction_location(self)
            else:
                return visitor.visitChildren(self)




    def action_location(self):

        localctx = kismetParser.Action_locationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_action_location)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 302
            self.match(kismetParser.T__20)
            self.state = 304 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 303
                self.loc()
                self.state = 306 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==kismetParser.T__1 or _la==kismetParser.T__21 or _la==kismetParser.NAME or _la==kismetParser.VAR):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LocContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def var(self):
            return self.getTypedRuleContext(kismetParser.VarContext,0)


        def arg(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.ArgContext)
            else:
                return self.getTypedRuleContext(kismetParser.ArgContext,i)


        def name(self):
            return self.getTypedRuleContext(kismetParser.NameContext,0)


        def locWildCard(self):
            return self.getTypedRuleContext(kismetParser.LocWildCardContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_loc

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLoc" ):
                listener.enterLoc(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLoc" ):
                listener.exitLoc(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLoc" ):
                return visitor.visitLoc(self)
            else:
                return visitor.visitChildren(self)




    def loc(self):

        localctx = kismetParser.LocContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_loc)
        self._la = 0 # Token type
        try:
            self.state = 355
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [kismetParser.VAR]:
                self.enterOuterAlt(localctx, 1)
                self.state = 308
                self.var()
                self.state = 309
                self.match(kismetParser.T__1)
                self.state = 310
                self.arg()
                self.state = 315
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==kismetParser.T__2:
                    self.state = 311
                    self.match(kismetParser.T__2)
                    self.state = 312
                    self.arg()
                    self.state = 317
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 318
                self.match(kismetParser.T__3)
                pass
            elif token in [kismetParser.NAME]:
                self.enterOuterAlt(localctx, 2)
                self.state = 320
                self.name()
                self.state = 321
                self.match(kismetParser.T__1)
                self.state = 322
                self.arg()
                self.state = 327
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==kismetParser.T__2:
                    self.state = 323
                    self.match(kismetParser.T__2)
                    self.state = 324
                    self.arg()
                    self.state = 329
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 330
                self.match(kismetParser.T__3)
                pass
            elif token in [kismetParser.T__21]:
                self.enterOuterAlt(localctx, 3)
                self.state = 332
                self.locWildCard()
                self.state = 333
                self.match(kismetParser.T__1)
                self.state = 334
                self.arg()
                self.state = 339
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==kismetParser.T__2:
                    self.state = 335
                    self.match(kismetParser.T__2)
                    self.state = 336
                    self.arg()
                    self.state = 341
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 342
                self.match(kismetParser.T__3)
                pass
            elif token in [kismetParser.T__1]:
                self.enterOuterAlt(localctx, 4)
                self.state = 344
                self.match(kismetParser.T__1)
                self.state = 345
                self.arg()
                self.state = 350
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==kismetParser.T__2:
                    self.state = 346
                    self.match(kismetParser.T__2)
                    self.state = 347
                    self.arg()
                    self.state = 352
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 353
                self.match(kismetParser.T__3)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LocWildCardContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return kismetParser.RULE_locWildCard

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLocWildCard" ):
                listener.enterLocWildCard(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLocWildCard" ):
                listener.exitLocWildCard(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLocWildCard" ):
                return visitor.visitLocWildCard(self)
            else:
                return visitor.visitChildren(self)




    def locWildCard(self):

        localctx = kismetParser.LocWildCardContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_locWildCard)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 357
            self.match(kismetParser.T__21)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Action_itemContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def tags(self):
            return self.getTypedRuleContext(kismetParser.TagsContext,0)


        def comparison(self):
            return self.getTypedRuleContext(kismetParser.ComparisonContext,0)


        def action_location(self):
            return self.getTypedRuleContext(kismetParser.Action_locationContext,0)


        def add(self):
            return self.getTypedRuleContext(kismetParser.AddContext,0)


        def visibility(self):
            return self.getTypedRuleContext(kismetParser.VisibilityContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_action_item

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAction_item" ):
                listener.enterAction_item(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAction_item" ):
                listener.exitAction_item(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAction_item" ):
                return visitor.visitAction_item(self)
            else:
                return visitor.visitChildren(self)




    def action_item(self):

        localctx = kismetParser.Action_itemContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_action_item)
        try:
            self.state = 364
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [kismetParser.T__29]:
                self.enterOuterAlt(localctx, 1)
                self.state = 359
                self.tags()
                pass
            elif token in [kismetParser.T__30]:
                self.enterOuterAlt(localctx, 2)
                self.state = 360
                self.comparison()
                pass
            elif token in [kismetParser.T__20]:
                self.enterOuterAlt(localctx, 3)
                self.state = 361
                self.action_location()
                pass
            elif token in [kismetParser.T__19]:
                self.enterOuterAlt(localctx, 4)
                self.state = 362
                self.add()
                pass
            elif token in [kismetParser.T__12]:
                self.enterOuterAlt(localctx, 5)
                self.state = 363
                self.visibility()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RoleContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def name(self):
            return self.getTypedRuleContext(kismetParser.NameContext,0)


        def arg(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.ArgContext)
            else:
                return self.getTypedRuleContext(kismetParser.ArgContext,i)


        def tags(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.TagsContext)
            else:
                return self.getTypedRuleContext(kismetParser.TagsContext,i)


        def comparison(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.ComparisonContext)
            else:
                return self.getTypedRuleContext(kismetParser.ComparisonContext,i)


        def extension(self):
            return self.getTypedRuleContext(kismetParser.ExtensionContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_role

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRole" ):
                listener.enterRole(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRole" ):
                listener.exitRole(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRole" ):
                return visitor.visitRole(self)
            else:
                return visitor.visitChildren(self)




    def role(self):

        localctx = kismetParser.RoleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_role)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 366
            self.match(kismetParser.T__22)
            self.state = 367
            self.name()
            self.state = 368
            self.match(kismetParser.T__1)
            self.state = 369
            self.arg()
            self.state = 374
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__2:
                self.state = 370
                self.match(kismetParser.T__2)
                self.state = 371
                self.arg()
                self.state = 376
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 377
            self.match(kismetParser.T__3)
            self.state = 379
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==kismetParser.T__23:
                self.state = 378
                self.extension()


            self.state = 381
            self.match(kismetParser.T__4)
            self.state = 384
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [kismetParser.T__29]:
                self.state = 382
                self.tags()
                pass
            elif token in [kismetParser.T__30]:
                self.state = 383
                self.comparison()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 393
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__16:
                self.state = 386
                self.match(kismetParser.T__16)
                self.state = 389
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [kismetParser.T__29]:
                    self.state = 387
                    self.tags()
                    pass
                elif token in [kismetParser.T__30]:
                    self.state = 388
                    self.comparison()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 395
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 396
            self.match(kismetParser.T__5)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExtensionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def arg(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.ArgContext)
            else:
                return self.getTypedRuleContext(kismetParser.ArgContext,i)


        def cast_name(self):
            return self.getTypedRuleContext(kismetParser.Cast_nameContext,0)


        def name(self):
            return self.getTypedRuleContext(kismetParser.NameContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_extension

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExtension" ):
                listener.enterExtension(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExtension" ):
                listener.exitExtension(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExtension" ):
                return visitor.visitExtension(self)
            else:
                return visitor.visitChildren(self)




    def extension(self):

        localctx = kismetParser.ExtensionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_extension)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 398
            self.match(kismetParser.T__23)
            self.state = 401
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [kismetParser.T__24]:
                self.state = 399
                self.cast_name()
                pass
            elif token in [kismetParser.NAME]:
                self.state = 400
                self.name()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 403
            self.match(kismetParser.T__1)
            self.state = 404
            self.arg()
            self.state = 409
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__2:
                self.state = 405
                self.match(kismetParser.T__2)
                self.state = 406
                self.arg()
                self.state = 411
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 412
            self.match(kismetParser.T__3)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Cast_nameContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def name(self):
            return self.getTypedRuleContext(kismetParser.NameContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_cast_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCast_name" ):
                listener.enterCast_name(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCast_name" ):
                listener.exitCast_name(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCast_name" ):
                return visitor.visitCast_name(self)
            else:
                return visitor.visitChildren(self)




    def cast_name(self):

        localctx = kismetParser.Cast_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_cast_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 414
            self.match(kismetParser.T__24)
            self.state = 415
            self.name()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ArgContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def var(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.VarContext)
            else:
                return self.getTypedRuleContext(kismetParser.VarContext,i)


        def arg_type(self):
            return self.getTypedRuleContext(kismetParser.Arg_typeContext,0)


        def sub(self):
            return self.getTypedRuleContext(kismetParser.SubContext,0)


        def name(self):
            return self.getTypedRuleContext(kismetParser.NameContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_arg

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArg" ):
                listener.enterArg(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArg" ):
                listener.exitArg(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitArg" ):
                return visitor.visitArg(self)
            else:
                return visitor.visitChildren(self)




    def arg(self):

        localctx = kismetParser.ArgContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_arg)
        self._la = 0 # Token type
        try:
            self.state = 435
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,45,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 418
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << kismetParser.T__13) | (1 << kismetParser.T__25) | (1 << kismetParser.T__26) | (1 << kismetParser.T__27) | (1 << kismetParser.T__28))) != 0):
                    self.state = 417
                    self.arg_type()


                self.state = 420
                self.var()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 422
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << kismetParser.T__13) | (1 << kismetParser.T__25) | (1 << kismetParser.T__26) | (1 << kismetParser.T__27) | (1 << kismetParser.T__28))) != 0):
                    self.state = 421
                    self.arg_type()


                self.state = 424
                self.var()
                self.state = 425
                self.sub()
                self.state = 426
                self.name()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 429
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << kismetParser.T__13) | (1 << kismetParser.T__25) | (1 << kismetParser.T__26) | (1 << kismetParser.T__27) | (1 << kismetParser.T__28))) != 0):
                    self.state = 428
                    self.arg_type()


                self.state = 431
                self.var()
                self.state = 432
                self.sub()
                self.state = 433
                self.var()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SubContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return kismetParser.RULE_sub

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSub" ):
                listener.enterSub(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSub" ):
                listener.exitSub(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSub" ):
                return visitor.visitSub(self)
            else:
                return visitor.visitChildren(self)




    def sub(self):

        localctx = kismetParser.SubContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_sub)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 437
            _la = self._input.LA(1)
            if not(_la==kismetParser.T__4 or _la==kismetParser.T__5):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Arg_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return kismetParser.RULE_arg_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArg_type" ):
                listener.enterArg_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArg_type" ):
                listener.exitArg_type(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitArg_type" ):
                return visitor.visitArg_type(self)
            else:
                return visitor.visitChildren(self)




    def arg_type(self):

        localctx = kismetParser.Arg_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_arg_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 439
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << kismetParser.T__13) | (1 << kismetParser.T__25) | (1 << kismetParser.T__26) | (1 << kismetParser.T__27) | (1 << kismetParser.T__28))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TagsContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.NameContext)
            else:
                return self.getTypedRuleContext(kismetParser.NameContext,i)


        def getRuleIndex(self):
            return kismetParser.RULE_tags

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTags" ):
                listener.enterTags(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTags" ):
                listener.exitTags(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTags" ):
                return visitor.visitTags(self)
            else:
                return visitor.visitChildren(self)




    def tags(self):

        localctx = kismetParser.TagsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_tags)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 441
            self.match(kismetParser.T__29)
            self.state = 442
            self.match(kismetParser.T__4)
            self.state = 443
            self.name()
            self.state = 448
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__2:
                self.state = 444
                self.match(kismetParser.T__2)
                self.state = 445
                self.name()
                self.state = 450
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ComparisonContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def condition(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.ConditionContext)
            else:
                return self.getTypedRuleContext(kismetParser.ConditionContext,i)


        def getRuleIndex(self):
            return kismetParser.RULE_comparison

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterComparison" ):
                listener.enterComparison(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitComparison" ):
                listener.exitComparison(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitComparison" ):
                return visitor.visitComparison(self)
            else:
                return visitor.visitChildren(self)




    def comparison(self):

        localctx = kismetParser.ComparisonContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_comparison)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 451
            self.match(kismetParser.T__30)
            self.state = 452
            self.condition()
            self.state = 457
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__2:
                self.state = 453
                self.match(kismetParser.T__2)
                self.state = 454
                self.condition()
                self.state = 459
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class KnowledgeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return kismetParser.RULE_knowledge

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterKnowledge" ):
                listener.enterKnowledge(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitKnowledge" ):
                listener.exitKnowledge(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitKnowledge" ):
                return visitor.visitKnowledge(self)
            else:
                return visitor.visitChildren(self)




    def knowledge(self):

        localctx = kismetParser.KnowledgeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_knowledge)
        try:
            self.state = 500
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,48,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 460
                self.match(kismetParser.T__31)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 461
                self.match(kismetParser.T__32)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 462
                self.match(kismetParser.T__33)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 463
                self.match(kismetParser.T__34)
                self.state = 464
                self.match(kismetParser.T__35)
                self.state = 465
                self.match(kismetParser.T__36)
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 466
                self.match(kismetParser.T__37)
                self.state = 467
                self.match(kismetParser.T__36)
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 468
                self.match(kismetParser.T__38)
                self.state = 469
                self.match(kismetParser.T__36)
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 470
                self.match(kismetParser.T__34)
                self.state = 471
                self.match(kismetParser.T__35)
                self.state = 472
                self.match(kismetParser.T__39)
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 473
                self.match(kismetParser.T__37)
                self.state = 474
                self.match(kismetParser.T__39)
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 475
                self.match(kismetParser.T__38)
                self.state = 476
                self.match(kismetParser.T__39)
                pass

            elif la_ == 10:
                self.enterOuterAlt(localctx, 10)
                self.state = 477
                self.match(kismetParser.T__34)
                self.state = 478
                self.match(kismetParser.T__35)
                self.state = 479
                self.match(kismetParser.T__40)
                pass

            elif la_ == 11:
                self.enterOuterAlt(localctx, 11)
                self.state = 480
                self.match(kismetParser.T__37)
                self.state = 481
                self.match(kismetParser.T__40)
                pass

            elif la_ == 12:
                self.enterOuterAlt(localctx, 12)
                self.state = 482
                self.match(kismetParser.T__38)
                self.state = 483
                self.match(kismetParser.T__40)
                pass

            elif la_ == 13:
                self.enterOuterAlt(localctx, 13)
                self.state = 484
                self.match(kismetParser.T__34)
                self.state = 485
                self.match(kismetParser.T__35)
                self.state = 486
                self.match(kismetParser.T__41)
                pass

            elif la_ == 14:
                self.enterOuterAlt(localctx, 14)
                self.state = 487
                self.match(kismetParser.T__37)
                self.state = 488
                self.match(kismetParser.T__41)
                pass

            elif la_ == 15:
                self.enterOuterAlt(localctx, 15)
                self.state = 489
                self.match(kismetParser.T__38)
                self.state = 490
                self.match(kismetParser.T__41)
                pass

            elif la_ == 16:
                self.enterOuterAlt(localctx, 16)
                self.state = 491
                self.match(kismetParser.T__42)
                pass

            elif la_ == 17:
                self.enterOuterAlt(localctx, 17)
                self.state = 492
                self.match(kismetParser.T__43)
                pass

            elif la_ == 18:
                self.enterOuterAlt(localctx, 18)
                self.state = 493
                self.match(kismetParser.T__44)
                pass

            elif la_ == 19:
                self.enterOuterAlt(localctx, 19)
                self.state = 494
                self.match(kismetParser.T__45)
                pass

            elif la_ == 20:
                self.enterOuterAlt(localctx, 20)
                self.state = 495
                self.match(kismetParser.T__46)
                pass

            elif la_ == 21:
                self.enterOuterAlt(localctx, 21)
                self.state = 496
                self.match(kismetParser.T__47)
                pass

            elif la_ == 22:
                self.enterOuterAlt(localctx, 22)
                self.state = 497
                self.match(kismetParser.T__48)
                pass

            elif la_ == 23:
                self.enterOuterAlt(localctx, 23)
                self.state = 498
                self.match(kismetParser.T__34)
                pass

            elif la_ == 24:
                self.enterOuterAlt(localctx, 24)
                self.state = 499
                self.match(kismetParser.T__49)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConditionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def cond3(self):
            return self.getTypedRuleContext(kismetParser.Cond3Context,0)


        def cond1(self):
            return self.getTypedRuleContext(kismetParser.Cond1Context,0)


        def cond4(self):
            return self.getTypedRuleContext(kismetParser.Cond4Context,0)


        def cond5(self):
            return self.getTypedRuleContext(kismetParser.Cond5Context,0)


        def cond6(self):
            return self.getTypedRuleContext(kismetParser.Cond6Context,0)


        def cond7(self):
            return self.getTypedRuleContext(kismetParser.Cond7Context,0)


        def condpattern(self):
            return self.getTypedRuleContext(kismetParser.CondpatternContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_condition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCondition" ):
                listener.enterCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCondition" ):
                listener.exitCondition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCondition" ):
                return visitor.visitCondition(self)
            else:
                return visitor.visitChildren(self)




    def condition(self):

        localctx = kismetParser.ConditionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_condition)
        try:
            self.state = 509
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,49,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 502
                self.cond3()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 503
                self.cond1()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 504
                self.cond4()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 505
                self.cond5()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 506
                self.cond6()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 507
                self.cond7()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 508
                self.condpattern()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Cond3Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def arg(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.ArgContext)
            else:
                return self.getTypedRuleContext(kismetParser.ArgContext,i)


        def knowledge(self):
            return self.getTypedRuleContext(kismetParser.KnowledgeContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_cond3

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCond3" ):
                listener.enterCond3(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCond3" ):
                listener.exitCond3(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCond3" ):
                return visitor.visitCond3(self)
            else:
                return visitor.visitChildren(self)




    def cond3(self):

        localctx = kismetParser.Cond3Context(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_cond3)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 511
            self.arg()
            self.state = 512
            self.knowledge()
            self.state = 513
            self.arg()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Cond1Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def arg(self):
            return self.getTypedRuleContext(kismetParser.ArgContext,0)


        def tag_compare(self):
            return self.getTypedRuleContext(kismetParser.Tag_compareContext,0)


        def name(self):
            return self.getTypedRuleContext(kismetParser.NameContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_cond1

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCond1" ):
                listener.enterCond1(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCond1" ):
                listener.exitCond1(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCond1" ):
                return visitor.visitCond1(self)
            else:
                return visitor.visitChildren(self)




    def cond1(self):

        localctx = kismetParser.Cond1Context(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_cond1)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 515
            self.arg()
            self.state = 516
            self.tag_compare()
            self.state = 517
            self.name()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Cond4Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def arg(self):
            return self.getTypedRuleContext(kismetParser.ArgContext,0)


        def name(self):
            return self.getTypedRuleContext(kismetParser.NameContext,0)


        def comparator(self):
            return self.getTypedRuleContext(kismetParser.ComparatorContext,0)


        def num(self):
            return self.getTypedRuleContext(kismetParser.NumContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_cond4

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCond4" ):
                listener.enterCond4(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCond4" ):
                listener.exitCond4(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCond4" ):
                return visitor.visitCond4(self)
            else:
                return visitor.visitChildren(self)




    def cond4(self):

        localctx = kismetParser.Cond4Context(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_cond4)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 519
            self.arg()
            self.state = 520
            _la = self._input.LA(1)
            if not(_la==kismetParser.T__50 or _la==kismetParser.T__51):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 521
            self.name()
            self.state = 522
            self.comparator()
            self.state = 523
            self.num()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InversionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return kismetParser.RULE_inversion

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInversion" ):
                listener.enterInversion(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInversion" ):
                listener.exitInversion(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInversion" ):
                return visitor.visitInversion(self)
            else:
                return visitor.visitChildren(self)




    def inversion(self):

        localctx = kismetParser.InversionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_inversion)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 525
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << kismetParser.T__52) | (1 << kismetParser.T__53) | (1 << kismetParser.T__54) | (1 << kismetParser.T__55) | (1 << kismetParser.T__56) | (1 << kismetParser.T__57))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Cond5Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def arg(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.ArgContext)
            else:
                return self.getTypedRuleContext(kismetParser.ArgContext,i)


        def name(self):
            return self.getTypedRuleContext(kismetParser.NameContext,0)


        def inversion(self):
            return self.getTypedRuleContext(kismetParser.InversionContext,0)


        def operator(self):
            return self.getTypedRuleContext(kismetParser.OperatorContext,0)


        def num(self):
            return self.getTypedRuleContext(kismetParser.NumContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_cond5

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCond5" ):
                listener.enterCond5(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCond5" ):
                listener.exitCond5(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCond5" ):
                return visitor.visitCond5(self)
            else:
                return visitor.visitChildren(self)




    def cond5(self):

        localctx = kismetParser.Cond5Context(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_cond5)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 527
            self.arg()
            self.state = 528
            self.match(kismetParser.T__58)
            self.state = 529
            self.arg()
            self.state = 531
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << kismetParser.T__52) | (1 << kismetParser.T__53) | (1 << kismetParser.T__54) | (1 << kismetParser.T__55) | (1 << kismetParser.T__56) | (1 << kismetParser.T__57))) != 0):
                self.state = 530
                self.inversion()


            self.state = 533
            self.name()
            self.state = 537
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [kismetParser.T__59]:
                self.state = 534
                self.match(kismetParser.T__59)
                self.state = 535
                self.match(kismetParser.T__60)
                pass
            elif token in [kismetParser.T__61]:
                self.state = 536
                self.match(kismetParser.T__61)
                pass
            else:
                raise NoViableAltException(self)

            self.state = 542
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==kismetParser.MINUS or _la==kismetParser.PLUS:
                self.state = 539
                self.operator()
                self.state = 540
                self.num()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Cond6Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def arg(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.ArgContext)
            else:
                return self.getTypedRuleContext(kismetParser.ArgContext,i)


        def name(self):
            return self.getTypedRuleContext(kismetParser.NameContext,0)


        def inversion(self):
            return self.getTypedRuleContext(kismetParser.InversionContext,0)


        def operator(self):
            return self.getTypedRuleContext(kismetParser.OperatorContext,0)


        def num(self):
            return self.getTypedRuleContext(kismetParser.NumContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_cond6

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCond6" ):
                listener.enterCond6(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCond6" ):
                listener.exitCond6(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCond6" ):
                return visitor.visitCond6(self)
            else:
                return visitor.visitChildren(self)




    def cond6(self):

        localctx = kismetParser.Cond6Context(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_cond6)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 544
            self.arg()
            self.state = 546
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << kismetParser.T__52) | (1 << kismetParser.T__53) | (1 << kismetParser.T__54) | (1 << kismetParser.T__55) | (1 << kismetParser.T__56) | (1 << kismetParser.T__57))) != 0):
                self.state = 545
                self.inversion()


            self.state = 551
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((((_la - 63)) & ~0x3f) == 0 and ((1 << (_la - 63)) & ((1 << (kismetParser.T__62 - 63)) | (1 << (kismetParser.T__63 - 63)) | (1 << (kismetParser.T__64 - 63)))) != 0):
                self.state = 548
                _la = self._input.LA(1)
                if not(((((_la - 63)) & ~0x3f) == 0 and ((1 << (_la - 63)) & ((1 << (kismetParser.T__62 - 63)) | (1 << (kismetParser.T__63 - 63)) | (1 << (kismetParser.T__64 - 63)))) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 553
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 554
            self.name()
            self.state = 558
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__65 or _la==kismetParser.T__66:
                self.state = 555
                _la = self._input.LA(1)
                if not(_la==kismetParser.T__65 or _la==kismetParser.T__66):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 560
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 561
            self.arg()
            self.state = 565
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==kismetParser.MINUS or _la==kismetParser.PLUS:
                self.state = 562
                self.operator()
                self.state = 563
                self.num()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Cond7Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def arg(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.ArgContext)
            else:
                return self.getTypedRuleContext(kismetParser.ArgContext,i)


        def name(self):
            return self.getTypedRuleContext(kismetParser.NameContext,0)


        def comparator(self):
            return self.getTypedRuleContext(kismetParser.ComparatorContext,0)


        def num(self):
            return self.getTypedRuleContext(kismetParser.NumContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_cond7

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCond7" ):
                listener.enterCond7(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCond7" ):
                listener.exitCond7(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCond7" ):
                return visitor.visitCond7(self)
            else:
                return visitor.visitChildren(self)




    def cond7(self):

        localctx = kismetParser.Cond7Context(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_cond7)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 567
            self.arg()
            self.state = 568
            self.name()
            self.state = 569
            self.arg()
            self.state = 570
            self.comparator()
            self.state = 571
            self.num()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CondpatternContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def name(self):
            return self.getTypedRuleContext(kismetParser.NameContext,0)


        def arg(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.ArgContext)
            else:
                return self.getTypedRuleContext(kismetParser.ArgContext,i)


        def getRuleIndex(self):
            return kismetParser.RULE_condpattern

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCondpattern" ):
                listener.enterCondpattern(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCondpattern" ):
                listener.exitCondpattern(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCondpattern" ):
                return visitor.visitCondpattern(self)
            else:
                return visitor.visitChildren(self)




    def condpattern(self):

        localctx = kismetParser.CondpatternContext(self, self._ctx, self.state)
        self.enterRule(localctx, 78, self.RULE_condpattern)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 573
            self.match(kismetParser.T__0)
            self.state = 574
            self.match(kismetParser.T__1)
            self.state = 575
            self.name()
            self.state = 580
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__2:
                self.state = 576
                self.match(kismetParser.T__2)
                self.state = 577
                self.arg()
                self.state = 582
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 583
            self.match(kismetParser.T__3)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Tag_compareContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return kismetParser.RULE_tag_compare

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTag_compare" ):
                listener.enterTag_compare(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTag_compare" ):
                listener.exitTag_compare(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTag_compare" ):
                return visitor.visitTag_compare(self)
            else:
                return visitor.visitChildren(self)




    def tag_compare(self):

        localctx = kismetParser.Tag_compareContext(self, self._ctx, self.state)
        self.enterRule(localctx, 80, self.RULE_tag_compare)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 585
            _la = self._input.LA(1)
            if not(((((_la - 65)) & ~0x3f) == 0 and ((1 << (_la - 65)) & ((1 << (kismetParser.T__64 - 65)) | (1 << (kismetParser.T__67 - 65)) | (1 << (kismetParser.T__68 - 65)) | (1 << (kismetParser.T__69 - 65)) | (1 << (kismetParser.T__70 - 65)) | (1 << (kismetParser.T__71 - 65)) | (1 << (kismetParser.T__72 - 65)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OperatorContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MINUS(self):
            return self.getToken(kismetParser.MINUS, 0)

        def PLUS(self):
            return self.getToken(kismetParser.PLUS, 0)

        def getRuleIndex(self):
            return kismetParser.RULE_operator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOperator" ):
                listener.enterOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOperator" ):
                listener.exitOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOperator" ):
                return visitor.visitOperator(self)
            else:
                return visitor.visitChildren(self)




    def operator(self):

        localctx = kismetParser.OperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 82, self.RULE_operator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 587
            _la = self._input.LA(1)
            if not(_la==kismetParser.MINUS or _la==kismetParser.PLUS):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LocationContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def name(self):
            return self.getTypedRuleContext(kismetParser.NameContext,0)


        def l_name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.L_nameContext)
            else:
                return self.getTypedRuleContext(kismetParser.L_nameContext,i)


        def supports(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.SupportsContext)
            else:
                return self.getTypedRuleContext(kismetParser.SupportsContext,i)


        def initialization(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.InitializationContext)
            else:
                return self.getTypedRuleContext(kismetParser.InitializationContext,i)


        def each_turn(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.Each_turnContext)
            else:
                return self.getTypedRuleContext(kismetParser.Each_turnContext,i)


        def tags(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.TagsContext)
            else:
                return self.getTypedRuleContext(kismetParser.TagsContext,i)


        def getRuleIndex(self):
            return kismetParser.RULE_location

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLocation" ):
                listener.enterLocation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLocation" ):
                listener.exitLocation(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLocation" ):
                return visitor.visitLocation(self)
            else:
                return visitor.visitChildren(self)




    def location(self):

        localctx = kismetParser.LocationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 84, self.RULE_location)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 589
            self.match(kismetParser.T__73)
            self.state = 590
            self.name()
            self.state = 591
            self.match(kismetParser.T__4)
            self.state = 597
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [kismetParser.T__76]:
                self.state = 592
                self.l_name()
                pass
            elif token in [kismetParser.T__77]:
                self.state = 593
                self.supports()
                pass
            elif token in [kismetParser.T__74]:
                self.state = 594
                self.initialization()
                pass
            elif token in [kismetParser.T__75]:
                self.state = 595
                self.each_turn()
                pass
            elif token in [kismetParser.T__29]:
                self.state = 596
                self.tags()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 609
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__16:
                self.state = 599
                self.match(kismetParser.T__16)
                self.state = 605
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [kismetParser.T__76]:
                    self.state = 600
                    self.l_name()
                    pass
                elif token in [kismetParser.T__77]:
                    self.state = 601
                    self.supports()
                    pass
                elif token in [kismetParser.T__74]:
                    self.state = 602
                    self.initialization()
                    pass
                elif token in [kismetParser.T__75]:
                    self.state = 603
                    self.each_turn()
                    pass
                elif token in [kismetParser.T__29]:
                    self.state = 604
                    self.tags()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 611
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 612
            self.match(kismetParser.T__5)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InitializationContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def cast(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.CastContext)
            else:
                return self.getTypedRuleContext(kismetParser.CastContext,i)


        def getRuleIndex(self):
            return kismetParser.RULE_initialization

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInitialization" ):
                listener.enterInitialization(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInitialization" ):
                listener.exitInitialization(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInitialization" ):
                return visitor.visitInitialization(self)
            else:
                return visitor.visitChildren(self)




    def initialization(self):

        localctx = kismetParser.InitializationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 86, self.RULE_initialization)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 614
            self.match(kismetParser.T__74)
            self.state = 615
            self.match(kismetParser.T__4)
            self.state = 616
            self.cast()
            self.state = 621
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__2:
                self.state = 617
                self.match(kismetParser.T__2)
                self.state = 618
                self.cast()
                self.state = 623
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Each_turnContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def cast(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.CastContext)
            else:
                return self.getTypedRuleContext(kismetParser.CastContext,i)


        def getRuleIndex(self):
            return kismetParser.RULE_each_turn

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEach_turn" ):
                listener.enterEach_turn(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEach_turn" ):
                listener.exitEach_turn(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEach_turn" ):
                return visitor.visitEach_turn(self)
            else:
                return visitor.visitChildren(self)




    def each_turn(self):

        localctx = kismetParser.Each_turnContext(self, self._ctx, self.state)
        self.enterRule(localctx, 88, self.RULE_each_turn)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 624
            self.match(kismetParser.T__75)
            self.state = 625
            self.match(kismetParser.T__4)
            self.state = 626
            self.cast()
            self.state = 631
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__2:
                self.state = 627
                self.match(kismetParser.T__2)
                self.state = 628
                self.cast()
                self.state = 633
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CastContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def num_choice(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.Num_choiceContext)
            else:
                return self.getTypedRuleContext(kismetParser.Num_choiceContext,i)


        def getRuleIndex(self):
            return kismetParser.RULE_cast

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCast" ):
                listener.enterCast(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCast" ):
                listener.exitCast(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCast" ):
                return visitor.visitCast(self)
            else:
                return visitor.visitChildren(self)




    def cast(self):

        localctx = kismetParser.CastContext(self, self._ctx, self.state)
        self.enterRule(localctx, 90, self.RULE_cast)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 634
            self.match(kismetParser.T__24)
            self.state = 635
            self.num_choice()
            self.state = 640
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,63,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 636
                    self.match(kismetParser.T__2)
                    self.state = 637
                    self.num_choice() 
                self.state = 642
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,63,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Random_textContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RANDOM_TEXT(self):
            return self.getToken(kismetParser.RANDOM_TEXT, 0)

        def getRuleIndex(self):
            return kismetParser.RULE_random_text

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRandom_text" ):
                listener.enterRandom_text(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRandom_text" ):
                listener.exitRandom_text(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRandom_text" ):
                return visitor.visitRandom_text(self)
            else:
                return visitor.visitChildren(self)




    def random_text(self):

        localctx = kismetParser.Random_textContext(self, self._ctx, self.state)
        self.enterRule(localctx, 92, self.RULE_random_text)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 643
            self.match(kismetParser.RANDOM_TEXT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class L_nameContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def random_text(self):
            return self.getTypedRuleContext(kismetParser.Random_textContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_l_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterL_name" ):
                listener.enterL_name(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitL_name" ):
                listener.exitL_name(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitL_name" ):
                return visitor.visitL_name(self)
            else:
                return visitor.visitChildren(self)




    def l_name(self):

        localctx = kismetParser.L_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 94, self.RULE_l_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 645
            self.match(kismetParser.T__76)
            self.state = 646
            self.match(kismetParser.T__4)
            self.state = 647
            self.random_text()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SupportsContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def num_choice(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.Num_choiceContext)
            else:
                return self.getTypedRuleContext(kismetParser.Num_choiceContext,i)


        def getRuleIndex(self):
            return kismetParser.RULE_supports

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSupports" ):
                listener.enterSupports(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSupports" ):
                listener.exitSupports(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSupports" ):
                return visitor.visitSupports(self)
            else:
                return visitor.visitChildren(self)




    def supports(self):

        localctx = kismetParser.SupportsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 96, self.RULE_supports)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 649
            self.match(kismetParser.T__77)
            self.state = 650
            self.match(kismetParser.T__4)
            self.state = 651
            self.num_choice()
            self.state = 656
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__2:
                self.state = 652
                self.match(kismetParser.T__2)
                self.state = 653
                self.num_choice()
                self.state = 658
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NumContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NUMBER(self):
            return self.getToken(kismetParser.NUMBER, 0)

        def getRuleIndex(self):
            return kismetParser.RULE_num

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNum" ):
                listener.enterNum(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNum" ):
                listener.exitNum(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNum" ):
                return visitor.visitNum(self)
            else:
                return visitor.visitChildren(self)




    def num(self):

        localctx = kismetParser.NumContext(self, self._ctx, self.state)
        self.enterRule(localctx, 98, self.RULE_num)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 659
            self.match(kismetParser.NUMBER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Pos_numContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def POSITIVE_NUMBER(self):
            return self.getToken(kismetParser.POSITIVE_NUMBER, 0)

        def getRuleIndex(self):
            return kismetParser.RULE_pos_num

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPos_num" ):
                listener.enterPos_num(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPos_num" ):
                listener.exitPos_num(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPos_num" ):
                return visitor.visitPos_num(self)
            else:
                return visitor.visitChildren(self)




    def pos_num(self):

        localctx = kismetParser.Pos_numContext(self, self._ctx, self.state)
        self.enterRule(localctx, 100, self.RULE_pos_num)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 661
            self.match(kismetParser.POSITIVE_NUMBER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NameContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NAME(self):
            return self.getToken(kismetParser.NAME, 0)

        def getRuleIndex(self):
            return kismetParser.RULE_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterName" ):
                listener.enterName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitName" ):
                listener.exitName(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitName" ):
                return visitor.visitName(self)
            else:
                return visitor.visitChildren(self)




    def name(self):

        localctx = kismetParser.NameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 102, self.RULE_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 663
            self.match(kismetParser.NAME)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VarContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def VAR(self):
            return self.getToken(kismetParser.VAR, 0)

        def getRuleIndex(self):
            return kismetParser.RULE_var

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVar" ):
                listener.enterVar(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVar" ):
                listener.exitVar(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVar" ):
                return visitor.visitVar(self)
            else:
                return visitor.visitChildren(self)




    def var(self):

        localctx = kismetParser.VarContext(self, self._ctx, self.state)
        self.enterRule(localctx, 104, self.RULE_var)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 665
            self.match(kismetParser.VAR)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ComparatorContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return kismetParser.RULE_comparator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterComparator" ):
                listener.enterComparator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitComparator" ):
                listener.exitComparator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitComparator" ):
                return visitor.visitComparator(self)
            else:
                return visitor.visitChildren(self)




    def comparator(self):

        localctx = kismetParser.ComparatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 106, self.RULE_comparator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 667
            _la = self._input.LA(1)
            if not(((((_la - 26)) & ~0x3f) == 0 and ((1 << (_la - 26)) & ((1 << (kismetParser.T__25 - 26)) | (1 << (kismetParser.T__28 - 26)) | (1 << (kismetParser.T__78 - 26)) | (1 << (kismetParser.T__79 - 26)) | (1 << (kismetParser.T__80 - 26)) | (1 << (kismetParser.T__81 - 26)) | (1 << (kismetParser.T__82 - 26)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Num_choiceContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def num(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.NumContext)
            else:
                return self.getTypedRuleContext(kismetParser.NumContext,i)


        def name(self):
            return self.getTypedRuleContext(kismetParser.NameContext,0)


        def pdf(self):
            return self.getTypedRuleContext(kismetParser.PdfContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_num_choice

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNum_choice" ):
                listener.enterNum_choice(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNum_choice" ):
                listener.exitNum_choice(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNum_choice" ):
                return visitor.visitNum_choice(self)
            else:
                return visitor.visitChildren(self)




    def num_choice(self):

        localctx = kismetParser.Num_choiceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 108, self.RULE_num_choice)
        self._la = 0 # Token type
        try:
            self.state = 684
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,66,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 669
                self.match(kismetParser.T__83)
                self.state = 670
                self.num()
                self.state = 671
                self.match(kismetParser.T__84)
                self.state = 672
                self.name()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 674
                self.match(kismetParser.T__83)
                self.state = 675
                self.num()
                self.state = 676
                self.match(kismetParser.T__4)
                self.state = 677
                self.num()
                self.state = 678
                self.match(kismetParser.T__84)
                self.state = 680
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==kismetParser.T__5 or _la==kismetParser.T__26 or _la==kismetParser.T__85 or _la==kismetParser.NEG:
                    self.state = 679
                    self.pdf()


                self.state = 682
                self.name()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PdfContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NEG(self, i:int=None):
            if i is None:
                return self.getTokens(kismetParser.NEG)
            else:
                return self.getToken(kismetParser.NEG, i)

        def getRuleIndex(self):
            return kismetParser.RULE_pdf

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPdf" ):
                listener.enterPdf(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPdf" ):
                listener.exitPdf(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPdf" ):
                return visitor.visitPdf(self)
            else:
                return visitor.visitChildren(self)




    def pdf(self):

        localctx = kismetParser.PdfContext(self, self._ctx, self.state)
        self.enterRule(localctx, 110, self.RULE_pdf)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 687 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 686
                _la = self._input.LA(1)
                if not(_la==kismetParser.T__5 or _la==kismetParser.T__26 or _la==kismetParser.T__85 or _la==kismetParser.NEG):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 689 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==kismetParser.T__5 or _la==kismetParser.T__26 or _la==kismetParser.T__85 or _la==kismetParser.NEG):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





