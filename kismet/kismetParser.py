# Generated from kismet.ebnv by ANTLR 4.7.2
# encoding: utf-8
from antlr4 import *
from io import StringIO
from typing.io import TextIO
import sys


def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3g")
        buf.write("\u0344\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\4\23\t\23")
        buf.write("\4\24\t\24\4\25\t\25\4\26\t\26\4\27\t\27\4\30\t\30\4\31")
        buf.write("\t\31\4\32\t\32\4\33\t\33\4\34\t\34\4\35\t\35\4\36\t\36")
        buf.write("\4\37\t\37\4 \t \4!\t!\4\"\t\"\4#\t#\4$\t$\4%\t%\4&\t")
        buf.write("&\4\'\t\'\4(\t(\4)\t)\4*\t*\4+\t+\4,\t,\4-\t-\4.\t.\4")
        buf.write("/\t/\4\60\t\60\4\61\t\61\4\62\t\62\4\63\t\63\4\64\t\64")
        buf.write("\4\65\t\65\4\66\t\66\4\67\t\67\48\t8\49\t9\4:\t:\4;\t")
        buf.write(";\4<\t<\4=\t=\4>\t>\4?\t?\4@\t@\4A\tA\4B\tB\4C\tC\4D\t")
        buf.write("D\3\2\3\2\3\2\3\2\3\2\3\2\6\2\u008f\n\2\r\2\16\2\u0090")
        buf.write("\3\2\3\2\3\3\3\3\6\3\u0097\n\3\r\3\16\3\u0098\3\3\3\3")
        buf.write("\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3\4\5\4\u00a7\n\4")
        buf.write("\5\4\u00a9\n\4\3\5\3\5\3\5\5\5\u00ae\n\5\3\5\3\5\5\5\u00b2")
        buf.write("\n\5\3\6\3\6\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3")
        buf.write("\7\5\7\u00c1\n\7\3\b\3\b\3\b\5\b\u00c6\n\b\3\b\3\b\3\b")
        buf.write("\5\b\u00cb\n\b\7\b\u00cd\n\b\f\b\16\b\u00d0\13\b\3\b\3")
        buf.write("\b\3\t\3\t\5\t\u00d6\n\t\3\n\3\n\3\n\3\n\3\n\3\n\7\n\u00de")
        buf.write("\n\n\f\n\16\n\u00e1\13\n\3\n\3\n\5\n\u00e5\n\n\3\n\3\n")
        buf.write("\3\n\3\n\3\13\3\13\3\13\3\13\7\13\u00ef\n\13\f\13\16\13")
        buf.write("\u00f2\13\13\3\f\5\f\u00f5\n\f\3\f\3\f\5\f\u00f9\n\f\3")
        buf.write("\f\3\f\3\f\7\f\u00fe\n\f\f\f\16\f\u0101\13\f\3\f\3\f\3")
        buf.write("\f\3\f\7\f\u0107\n\f\f\f\16\f\u010a\13\f\3\f\3\f\5\f\u010e")
        buf.write("\n\f\3\f\3\f\5\f\u0112\n\f\3\f\3\f\7\f\u0116\n\f\f\f\16")
        buf.write("\f\u0119\13\f\3\f\3\f\3\r\3\r\3\16\3\16\3\17\3\17\3\20")
        buf.write("\3\20\5\20\u0125\n\20\3\21\3\21\5\21\u0129\n\21\3\22\3")
        buf.write("\22\3\22\3\22\3\22\7\22\u0130\n\22\f\22\16\22\u0133\13")
        buf.write("\22\3\22\5\22\u0136\n\22\3\22\3\22\3\23\3\23\3\23\3\23")
        buf.write("\3\23\7\23\u013f\n\23\f\23\16\23\u0142\13\23\3\23\5\23")
        buf.write("\u0145\n\23\3\23\3\23\3\23\3\23\3\23\3\23\3\23\5\23\u014e")
        buf.write("\n\23\3\24\6\24\u0151\n\24\r\24\16\24\u0152\3\24\6\24")
        buf.write("\u0156\n\24\r\24\16\24\u0157\5\24\u015a\n\24\3\25\5\25")
        buf.write("\u015d\n\25\3\25\3\25\3\25\3\25\3\25\3\25\7\25\u0165\n")
        buf.write("\25\f\25\16\25\u0168\13\25\3\25\3\25\5\25\u016c\n\25\3")
        buf.write("\25\5\25\u016f\n\25\3\25\5\25\u0172\n\25\3\25\3\25\5\25")
        buf.write("\u0176\n\25\3\25\3\25\7\25\u017a\n\25\f\25\16\25\u017d")
        buf.write("\13\25\3\25\3\25\3\26\3\26\3\26\3\27\3\27\3\30\3\30\3")
        buf.write("\30\3\30\3\30\7\30\u018b\n\30\f\30\16\30\u018e\13\30\3")
        buf.write("\31\3\31\3\32\3\32\3\32\3\33\3\33\6\33\u0197\n\33\r\33")
        buf.write("\16\33\u0198\3\34\3\34\3\34\3\34\3\34\7\34\u01a0\n\34")
        buf.write("\f\34\16\34\u01a3\13\34\3\34\3\34\3\34\3\34\3\34\3\34")
        buf.write("\3\34\7\34\u01ac\n\34\f\34\16\34\u01af\13\34\3\34\3\34")
        buf.write("\3\34\3\34\3\34\3\34\3\34\7\34\u01b8\n\34\f\34\16\34\u01bb")
        buf.write("\13\34\3\34\3\34\3\34\3\34\3\34\3\34\7\34\u01c3\n\34\f")
        buf.write("\34\16\34\u01c6\13\34\3\34\3\34\5\34\u01ca\n\34\3\35\3")
        buf.write("\35\3\36\3\36\3\36\3\36\3\36\5\36\u01d3\n\36\3\37\3\37")
        buf.write("\3\37\3\37\3\37\3\37\7\37\u01db\n\37\f\37\16\37\u01de")
        buf.write("\13\37\3\37\3\37\5\37\u01e2\n\37\3\37\3\37\3\37\5\37\u01e7")
        buf.write("\n\37\3\37\3\37\3\37\5\37\u01ec\n\37\7\37\u01ee\n\37\f")
        buf.write("\37\16\37\u01f1\13\37\3\37\3\37\3 \3 \3 \5 \u01f8\n \3")
        buf.write(" \3 \3 \3 \7 \u01fe\n \f \16 \u0201\13 \3 \3 \3!\3!\3")
        buf.write("!\3\"\5\"\u0209\n\"\3\"\3\"\5\"\u020d\n\"\3\"\3\"\3\"")
        buf.write("\3\"\3\"\5\"\u0214\n\"\3\"\3\"\3\"\3\"\5\"\u021a\n\"\3")
        buf.write("#\3#\3$\3$\3%\3%\3%\3%\3%\7%\u0225\n%\f%\16%\u0228\13")
        buf.write("%\3&\3&\3&\3&\7&\u022e\n&\f&\16&\u0231\13&\3\'\3\'\3\'")
        buf.write("\3\'\3\'\3\'\3\'\3\'\3\'\3\'\3\'\3\'\3\'\3\'\3\'\3\'\3")
        buf.write("\'\3\'\3\'\3\'\3\'\3\'\3\'\3\'\3\'\3\'\3\'\3\'\3\'\3\'")
        buf.write("\3\'\3\'\3\'\3\'\3\'\3\'\3\'\3\'\3\'\3\'\5\'\u025b\n\'")
        buf.write("\3(\3(\3(\3(\3(\3(\3(\3(\3(\3(\3(\3(\3(\5(\u026a\n(\3")
        buf.write(")\3)\3)\3)\3)\3)\3*\3*\3*\3*\3+\3+\3+\3+\3,\3,\3,\3,\3")
        buf.write(",\3,\3-\3-\3-\3-\3-\3-\3-\3-\3.\3.\3.\3.\3.\3.\3.\3.\3")
        buf.write("/\3/\3\60\3\60\3\60\3\60\5\60\u0296\n\60\3\60\3\60\3\60")
        buf.write("\3\60\5\60\u029c\n\60\3\60\3\60\3\60\5\60\u02a1\n\60\3")
        buf.write("\61\3\61\5\61\u02a5\n\61\3\61\7\61\u02a8\n\61\f\61\16")
        buf.write("\61\u02ab\13\61\3\61\3\61\7\61\u02af\n\61\f\61\16\61\u02b2")
        buf.write("\13\61\3\61\3\61\3\61\3\61\5\61\u02b8\n\61\3\62\3\62\3")
        buf.write("\62\3\62\3\62\3\62\3\63\3\63\3\63\3\63\3\63\7\63\u02c5")
        buf.write("\n\63\f\63\16\63\u02c8\13\63\3\63\3\63\3\64\3\64\5\64")
        buf.write("\u02ce\n\64\3\64\3\64\3\64\3\64\3\64\3\64\3\65\3\65\5")
        buf.write("\65\u02d8\n\65\3\65\3\65\3\65\3\65\3\65\3\65\3\65\3\65")
        buf.write("\3\66\3\66\3\66\3\66\3\66\3\66\3\66\3\66\3\66\3\66\3\66")
        buf.write("\3\66\5\66\u02ee\n\66\3\67\3\67\38\38\39\39\39\39\39\3")
        buf.write("9\59\u02fa\n9\39\39\39\39\59\u0300\n9\79\u0302\n9\f9\16")
        buf.write("9\u0305\139\59\u0307\n9\39\39\3:\3:\3:\3:\3;\3;\3;\3;")
        buf.write("\7;\u0313\n;\f;\16;\u0316\13;\3<\3<\3=\3=\3=\3=\3=\7=")
        buf.write("\u031f\n=\f=\16=\u0322\13=\3>\3>\3?\3?\3@\3@\3A\3A\3B")
        buf.write("\3B\3C\3C\3C\3C\3C\3C\3C\3C\3C\3C\3C\5C\u0339\nC\3C\3")
        buf.write("C\5C\u033d\nC\3D\6D\u0340\nD\rD\16D\u0341\3D\2\2E\2\4")
        buf.write("\6\b\n\f\16\20\22\24\26\30\32\34\36 \"$&(*,.\60\62\64")
        buf.write("\668:<>@BDFHJLNPRTVXZ\\^`bdfhjlnprtvxz|~\u0080\u0082\u0084")
        buf.write("\u0086\2\r\3\2\21\22\3\2\4\5\5\2\b\b\25\25\37!\3\2\67")
        buf.write("8\3\29>\3\2CE\3\2FI\4\2EELQ\3\2]_\5\2\37\37!!UY\6\2\4")
        buf.write("\4  ZZee\2\u0384\2\u008e\3\2\2\2\4\u0094\3\2\2\2\6\u00a8")
        buf.write("\3\2\2\2\b\u00aa\3\2\2\2\n\u00b3\3\2\2\2\f\u00c0\3\2\2")
        buf.write("\2\16\u00c2\3\2\2\2\20\u00d5\3\2\2\2\22\u00d7\3\2\2\2")
        buf.write("\24\u00ea\3\2\2\2\26\u00f4\3\2\2\2\30\u011c\3\2\2\2\32")
        buf.write("\u011e\3\2\2\2\34\u0120\3\2\2\2\36\u0124\3\2\2\2 \u0128")
        buf.write("\3\2\2\2\"\u012a\3\2\2\2$\u014d\3\2\2\2&\u0159\3\2\2\2")
        buf.write("(\u015c\3\2\2\2*\u0180\3\2\2\2,\u0183\3\2\2\2.\u0185\3")
        buf.write("\2\2\2\60\u018f\3\2\2\2\62\u0191\3\2\2\2\64\u0194\3\2")
        buf.write("\2\2\66\u01c9\3\2\2\28\u01cb\3\2\2\2:\u01d2\3\2\2\2<\u01d4")
        buf.write("\3\2\2\2>\u01f4\3\2\2\2@\u0204\3\2\2\2B\u0219\3\2\2\2")
        buf.write("D\u021b\3\2\2\2F\u021d\3\2\2\2H\u021f\3\2\2\2J\u0229\3")
        buf.write("\2\2\2L\u025a\3\2\2\2N\u0269\3\2\2\2P\u026b\3\2\2\2R\u0271")
        buf.write("\3\2\2\2T\u0275\3\2\2\2V\u0279\3\2\2\2X\u027f\3\2\2\2")
        buf.write("Z\u0287\3\2\2\2\\\u028f\3\2\2\2^\u0291\3\2\2\2`\u02a2")
        buf.write("\3\2\2\2b\u02b9\3\2\2\2d\u02bf\3\2\2\2f\u02cb\3\2\2\2")
        buf.write("h\u02d5\3\2\2\2j\u02ed\3\2\2\2l\u02ef\3\2\2\2n\u02f1\3")
        buf.write("\2\2\2p\u02f3\3\2\2\2r\u030a\3\2\2\2t\u030e\3\2\2\2v\u0317")
        buf.write("\3\2\2\2x\u0319\3\2\2\2z\u0323\3\2\2\2|\u0325\3\2\2\2")
        buf.write("~\u0327\3\2\2\2\u0080\u0329\3\2\2\2\u0082\u032b\3\2\2")
        buf.write("\2\u0084\u033c\3\2\2\2\u0086\u033f\3\2\2\2\u0088\u008f")
        buf.write("\5p9\2\u0089\u008f\5<\37\2\u008a\u008f\5(\25\2\u008b\u008f")
        buf.write("\5\26\f\2\u008c\u008f\5\22\n\2\u008d\u008f\5\4\3\2\u008e")
        buf.write("\u0088\3\2\2\2\u008e\u0089\3\2\2\2\u008e\u008a\3\2\2\2")
        buf.write("\u008e\u008b\3\2\2\2\u008e\u008c\3\2\2\2\u008e\u008d\3")
        buf.write("\2\2\2\u008f\u0090\3\2\2\2\u0090\u008e\3\2\2\2\u0090\u0091")
        buf.write("\3\2\2\2\u0091\u0092\3\2\2\2\u0092\u0093\7\2\2\3\u0093")
        buf.write("\3\3\2\2\2\u0094\u0096\7\3\2\2\u0095\u0097\5\b\5\2\u0096")
        buf.write("\u0095\3\2\2\2\u0097\u0098\3\2\2\2\u0098\u0096\3\2\2\2")
        buf.write("\u0098\u0099\3\2\2\2\u0099\u009a\3\2\2\2\u009a\u009b\7")
        buf.write("\4\2\2\u009b\5\3\2\2\2\u009c\u009d\7[\2\2\u009d\u009e")
        buf.write("\5z>\2\u009e\u009f\7\\\2\2\u009f\u00a9\3\2\2\2\u00a0\u00a1")
        buf.write("\7[\2\2\u00a1\u00a2\5z>\2\u00a2\u00a3\7\5\2\2\u00a3\u00a4")
        buf.write("\5z>\2\u00a4\u00a6\7\\\2\2\u00a5\u00a7\5\u0086D\2\u00a6")
        buf.write("\u00a5\3\2\2\2\u00a6\u00a7\3\2\2\2\u00a7\u00a9\3\2\2\2")
        buf.write("\u00a8\u009c\3\2\2\2\u00a8\u00a0\3\2\2\2\u00a9\7\3\2\2")
        buf.write("\2\u00aa\u00ab\5~@\2\u00ab\u00ad\7\5\2\2\u00ac\u00ae\5")
        buf.write("\n\6\2\u00ad\u00ac\3\2\2\2\u00ad\u00ae\3\2\2\2\u00ae\u00af")
        buf.write("\3\2\2\2\u00af\u00b1\5\20\t\2\u00b0\u00b2\5\f\7\2\u00b1")
        buf.write("\u00b0\3\2\2\2\u00b1\u00b2\3\2\2\2\u00b2\t\3\2\2\2\u00b3")
        buf.write("\u00b4\7\6\2\2\u00b4\13\3\2\2\2\u00b5\u00c1\7\7\2\2\u00b6")
        buf.write("\u00c1\7\b\2\2\u00b7\u00c1\7\6\2\2\u00b8\u00b9\7\7\2\2")
        buf.write("\u00b9\u00c1\5z>\2\u00ba\u00bb\7\7\2\2\u00bb\u00c1\5\6")
        buf.write("\4\2\u00bc\u00bd\7\b\2\2\u00bd\u00c1\5z>\2\u00be\u00bf")
        buf.write("\7\b\2\2\u00bf\u00c1\5\6\4\2\u00c0\u00b5\3\2\2\2\u00c0")
        buf.write("\u00b6\3\2\2\2\u00c0\u00b7\3\2\2\2\u00c0\u00b8\3\2\2\2")
        buf.write("\u00c0\u00ba\3\2\2\2\u00c0\u00bc\3\2\2\2\u00c0\u00be\3")
        buf.write("\2\2\2\u00c1\r\3\2\2\2\u00c2\u00c5\7[\2\2\u00c3\u00c6")
        buf.write("\5~@\2\u00c4\u00c6\5\u0080A\2\u00c5\u00c3\3\2\2\2\u00c5")
        buf.write("\u00c4\3\2\2\2\u00c6\u00ce\3\2\2\2\u00c7\u00ca\7\t\2\2")
        buf.write("\u00c8\u00cb\5~@\2\u00c9\u00cb\5\u0080A\2\u00ca\u00c8")
        buf.write("\3\2\2\2\u00ca\u00c9\3\2\2\2\u00cb\u00cd\3\2\2\2\u00cc")
        buf.write("\u00c7\3\2\2\2\u00cd\u00d0\3\2\2\2\u00ce\u00cc\3\2\2\2")
        buf.write("\u00ce\u00cf\3\2\2\2\u00cf\u00d1\3\2\2\2\u00d0\u00ce\3")
        buf.write("\2\2\2\u00d1\u00d2\7\\\2\2\u00d2\17\3\2\2\2\u00d3\u00d6")
        buf.write("\5\6\4\2\u00d4\u00d6\5\16\b\2\u00d5\u00d3\3\2\2\2\u00d5")
        buf.write("\u00d4\3\2\2\2\u00d6\21\3\2\2\2\u00d7\u00d8\7\n\2\2\u00d8")
        buf.write("\u00d9\5~@\2\u00d9\u00da\7\13\2\2\u00da\u00df\5B\"\2\u00db")
        buf.write("\u00dc\7\f\2\2\u00dc\u00de\5B\"\2\u00dd\u00db\3\2\2\2")
        buf.write("\u00de\u00e1\3\2\2\2\u00df\u00dd\3\2\2\2\u00df\u00e0\3")
        buf.write("\2\2\2\u00e0\u00e2\3\2\2\2\u00e1\u00df\3\2\2\2\u00e2\u00e4")
        buf.write("\7\r\2\2\u00e3\u00e5\5v<\2\u00e4\u00e3\3\2\2\2\u00e4\u00e5")
        buf.write("\3\2\2\2\u00e5\u00e6\3\2\2\2\u00e6\u00e7\7\5\2\2\u00e7")
        buf.write("\u00e8\5J&\2\u00e8\u00e9\7\4\2\2\u00e9\23\3\2\2\2\u00ea")
        buf.write("\u00eb\7\16\2\2\u00eb\u00f0\5~@\2\u00ec\u00ed\7\17\2\2")
        buf.write("\u00ed\u00ef\5~@\2\u00ee\u00ec\3\2\2\2\u00ef\u00f2\3\2")
        buf.write("\2\2\u00f0\u00ee\3\2\2\2\u00f0\u00f1\3\2\2\2\u00f1\25")
        buf.write("\3\2\2\2\u00f2\u00f0\3\2\2\2\u00f3\u00f5\5\30\r\2\u00f4")
        buf.write("\u00f3\3\2\2\2\u00f4\u00f5\3\2\2\2\u00f5\u00f6\3\2\2\2")
        buf.write("\u00f6\u00f8\5\32\16\2\u00f7\u00f9\5\34\17\2\u00f8\u00f7")
        buf.write("\3\2\2\2\u00f8\u00f9\3\2\2\2\u00f9\u00fa\3\2\2\2\u00fa")
        buf.write("\u00ff\5~@\2\u00fb\u00fc\7\17\2\2\u00fc\u00fe\5~@\2\u00fd")
        buf.write("\u00fb\3\2\2\2\u00fe\u0101\3\2\2\2\u00ff\u00fd\3\2\2\2")
        buf.write("\u00ff\u0100\3\2\2\2\u0100\u0102\3\2\2\2\u0101\u00ff\3")
        buf.write("\2\2\2\u0102\u0103\7\13\2\2\u0103\u0108\5B\"\2\u0104\u0105")
        buf.write("\7\f\2\2\u0105\u0107\5B\"\2\u0106\u0104\3\2\2\2\u0107")
        buf.write("\u010a\3\2\2\2\u0108\u0106\3\2\2\2\u0108\u0109\3\2\2\2")
        buf.write("\u0109\u010b\3\2\2\2\u010a\u0108\3\2\2\2\u010b\u010d\7")
        buf.write("\r\2\2\u010c\u010e\5\24\13\2\u010d\u010c\3\2\2\2\u010d")
        buf.write("\u010e\3\2\2\2\u010e\u010f\3\2\2\2\u010f\u0111\7\5\2\2")
        buf.write("\u0110\u0112\5\36\20\2\u0111\u0110\3\2\2\2\u0111\u0112")
        buf.write("\3\2\2\2\u0112\u0117\3\2\2\2\u0113\u0114\7\f\2\2\u0114")
        buf.write("\u0116\5\36\20\2\u0115\u0113\3\2\2\2\u0116\u0119\3\2\2")
        buf.write("\2\u0117\u0115\3\2\2\2\u0117\u0118\3\2\2\2\u0118\u011a")
        buf.write("\3\2\2\2\u0119\u0117\3\2\2\2\u011a\u011b\7\4\2\2\u011b")
        buf.write("\27\3\2\2\2\u011c\u011d\7\20\2\2\u011d\31\3\2\2\2\u011e")
        buf.write("\u011f\t\2\2\2\u011f\33\3\2\2\2\u0120\u0121\7\23\2\2\u0121")
        buf.write("\35\3\2\2\2\u0122\u0125\5\"\22\2\u0123\u0125\5$\23\2\u0124")
        buf.write("\u0122\3\2\2\2\u0124\u0123\3\2\2\2\u0125\37\3\2\2\2\u0126")
        buf.write("\u0129\7\24\2\2\u0127\u0129\5~@\2\u0128\u0126\3\2\2\2")
        buf.write("\u0128\u0127\3\2\2\2\u0129!\3\2\2\2\u012a\u012b\5&\24")
        buf.write("\2\u012b\u012c\7\13\2\2\u012c\u0131\5 \21\2\u012d\u012e")
        buf.write("\7\f\2\2\u012e\u0130\5 \21\2\u012f\u012d\3\2\2\2\u0130")
        buf.write("\u0133\3\2\2\2\u0131\u012f\3\2\2\2\u0131\u0132\3\2\2\2")
        buf.write("\u0132\u0135\3\2\2\2\u0133\u0131\3\2\2\2\u0134\u0136\5")
        buf.write("J&\2\u0135\u0134\3\2\2\2\u0135\u0136\3\2\2\2\u0136\u0137")
        buf.write("\3\2\2\2\u0137\u0138\7\r\2\2\u0138#\3\2\2\2\u0139\u013a")
        buf.write("\5&\24\2\u013a\u013b\7\25\2\2\u013b\u0140\5~@\2\u013c")
        buf.write("\u013d\7\f\2\2\u013d\u013f\5~@\2\u013e\u013c\3\2\2\2\u013f")
        buf.write("\u0142\3\2\2\2\u0140\u013e\3\2\2\2\u0140\u0141\3\2\2\2")
        buf.write("\u0141\u0144\3\2\2\2\u0142\u0140\3\2\2\2\u0143\u0145\5")
        buf.write("J&\2\u0144\u0143\3\2\2\2\u0144\u0145\3\2\2\2\u0145\u0146")
        buf.write("\3\2\2\2\u0146\u0147\7\25\2\2\u0147\u014e\3\2\2\2\u0148")
        buf.write("\u0149\5&\24\2\u0149\u014a\7\25\2\2\u014a\u014b\5J&\2")
        buf.write("\u014b\u014c\7\25\2\2\u014c\u014e\3\2\2\2\u014d\u0139")
        buf.write("\3\2\2\2\u014d\u0148\3\2\2\2\u014e%\3\2\2\2\u014f\u0151")
        buf.write("\7\7\2\2\u0150\u014f\3\2\2\2\u0151\u0152\3\2\2\2\u0152")
        buf.write("\u0150\3\2\2\2\u0152\u0153\3\2\2\2\u0153\u015a\3\2\2\2")
        buf.write("\u0154\u0156\7e\2\2\u0155\u0154\3\2\2\2\u0156\u0157\3")
        buf.write("\2\2\2\u0157\u0155\3\2\2\2\u0157\u0158\3\2\2\2\u0158\u015a")
        buf.write("\3\2\2\2\u0159\u0150\3\2\2\2\u0159\u0155\3\2\2\2\u015a")
        buf.write("\'\3\2\2\2\u015b\u015d\5,\27\2\u015c\u015b\3\2\2\2\u015c")
        buf.write("\u015d\3\2\2\2\u015d\u015e\3\2\2\2\u015e\u015f\7\26\2")
        buf.write("\2\u015f\u0160\5~@\2\u0160\u0161\7\13\2\2\u0161\u0166")
        buf.write("\5B\"\2\u0162\u0163\7\f\2\2\u0163\u0165\5B\"\2\u0164\u0162")
        buf.write("\3\2\2\2\u0165\u0168\3\2\2\2\u0166\u0164\3\2\2\2\u0166")
        buf.write("\u0167\3\2\2\2\u0167\u0169\3\2\2\2\u0168\u0166\3\2\2\2")
        buf.write("\u0169\u016b\7\r\2\2\u016a\u016c\5*\26\2\u016b\u016a\3")
        buf.write("\2\2\2\u016b\u016c\3\2\2\2\u016c\u016e\3\2\2\2\u016d\u016f")
        buf.write("\5> \2\u016e\u016d\3\2\2\2\u016e\u016f\3\2\2\2\u016f\u0171")
        buf.write("\3\2\2\2\u0170\u0172\5v<\2\u0171\u0170\3\2\2\2\u0171\u0172")
        buf.write("\3\2\2\2\u0172\u0173\3\2\2\2\u0173\u0175\7\5\2\2\u0174")
        buf.write("\u0176\5:\36\2\u0175\u0174\3\2\2\2\u0175\u0176\3\2\2\2")
        buf.write("\u0176\u017b\3\2\2\2\u0177\u0178\7\27\2\2\u0178\u017a")
        buf.write("\5:\36\2\u0179\u0177\3\2\2\2\u017a\u017d\3\2\2\2\u017b")
        buf.write("\u0179\3\2\2\2\u017b\u017c\3\2\2\2\u017c\u017e\3\2\2\2")
        buf.write("\u017d\u017b\3\2\2\2\u017e\u017f\7\4\2\2\u017f)\3\2\2")
        buf.write("\2\u0180\u0181\7\30\2\2\u0181\u0182\5z>\2\u0182+\3\2\2")
        buf.write("\2\u0183\u0184\7\31\2\2\u0184-\3\2\2\2\u0185\u0186\7\32")
        buf.write("\2\2\u0186\u0187\7\5\2\2\u0187\u018c\5\60\31\2\u0188\u0189")
        buf.write("\7\f\2\2\u0189\u018b\5\60\31\2\u018a\u0188\3\2\2\2\u018b")
        buf.write("\u018e\3\2\2\2\u018c\u018a\3\2\2\2\u018c\u018d\3\2\2\2")
        buf.write("\u018d/\3\2\2\2\u018e\u018c\3\2\2\2\u018f\u0190\5N(\2")
        buf.write("\u0190\61\3\2\2\2\u0191\u0192\7\24\2\2\u0192\u0193\5&")
        buf.write("\24\2\u0193\63\3\2\2\2\u0194\u0196\7\33\2\2\u0195\u0197")
        buf.write("\5\66\34\2\u0196\u0195\3\2\2\2\u0197\u0198\3\2\2\2\u0198")
        buf.write("\u0196\3\2\2\2\u0198\u0199\3\2\2\2\u0199\65\3\2\2\2\u019a")
        buf.write("\u019b\5\u0080A\2\u019b\u019c\7\13\2\2\u019c\u01a1\5B")
        buf.write("\"\2\u019d\u019e\7\f\2\2\u019e\u01a0\5B\"\2\u019f\u019d")
        buf.write("\3\2\2\2\u01a0\u01a3\3\2\2\2\u01a1\u019f\3\2\2\2\u01a1")
        buf.write("\u01a2\3\2\2\2\u01a2\u01a4\3\2\2\2\u01a3\u01a1\3\2\2\2")
        buf.write("\u01a4\u01a5\7\r\2\2\u01a5\u01ca\3\2\2\2\u01a6\u01a7\5")
        buf.write("~@\2\u01a7\u01a8\7\13\2\2\u01a8\u01ad\5B\"\2\u01a9\u01aa")
        buf.write("\7\f\2\2\u01aa\u01ac\5B\"\2\u01ab\u01a9\3\2\2\2\u01ac")
        buf.write("\u01af\3\2\2\2\u01ad\u01ab\3\2\2\2\u01ad\u01ae\3\2\2\2")
        buf.write("\u01ae\u01b0\3\2\2\2\u01af\u01ad\3\2\2\2\u01b0\u01b1\7")
        buf.write("\r\2\2\u01b1\u01ca\3\2\2\2\u01b2\u01b3\58\35\2\u01b3\u01b4")
        buf.write("\7\13\2\2\u01b4\u01b9\5B\"\2\u01b5\u01b6\7\f\2\2\u01b6")
        buf.write("\u01b8\5B\"\2\u01b7\u01b5\3\2\2\2\u01b8\u01bb\3\2\2\2")
        buf.write("\u01b9\u01b7\3\2\2\2\u01b9\u01ba\3\2\2\2\u01ba\u01bc\3")
        buf.write("\2\2\2\u01bb\u01b9\3\2\2\2\u01bc\u01bd\7\r\2\2\u01bd\u01ca")
        buf.write("\3\2\2\2\u01be\u01bf\7\13\2\2\u01bf\u01c4\5B\"\2\u01c0")
        buf.write("\u01c1\7\f\2\2\u01c1\u01c3\5B\"\2\u01c2\u01c0\3\2\2\2")
        buf.write("\u01c3\u01c6\3\2\2\2\u01c4\u01c2\3\2\2\2\u01c4\u01c5\3")
        buf.write("\2\2\2\u01c5\u01c7\3\2\2\2\u01c6\u01c4\3\2\2\2\u01c7\u01c8")
        buf.write("\7\r\2\2\u01c8\u01ca\3\2\2\2\u01c9\u019a\3\2\2\2\u01c9")
        buf.write("\u01a6\3\2\2\2\u01c9\u01b2\3\2\2\2\u01c9\u01be\3\2\2\2")
        buf.write("\u01ca\67\3\2\2\2\u01cb\u01cc\7\6\2\2\u01cc9\3\2\2\2\u01cd")
        buf.write("\u01d3\5H%\2\u01ce\u01d3\5J&\2\u01cf\u01d3\5\64\33\2\u01d0")
        buf.write("\u01d3\5.\30\2\u01d1\u01d3\5\62\32\2\u01d2\u01cd\3\2\2")
        buf.write("\2\u01d2\u01ce\3\2\2\2\u01d2\u01cf\3\2\2\2\u01d2\u01d0")
        buf.write("\3\2\2\2\u01d2\u01d1\3\2\2\2\u01d3;\3\2\2\2\u01d4\u01d5")
        buf.write("\7\34\2\2\u01d5\u01d6\5~@\2\u01d6\u01d7\7\13\2\2\u01d7")
        buf.write("\u01dc\5B\"\2\u01d8\u01d9\7\f\2\2\u01d9\u01db\5B\"\2\u01da")
        buf.write("\u01d8\3\2\2\2\u01db\u01de\3\2\2\2\u01dc\u01da\3\2\2\2")
        buf.write("\u01dc\u01dd\3\2\2\2\u01dd\u01df\3\2\2\2\u01de\u01dc\3")
        buf.write("\2\2\2\u01df\u01e1\7\r\2\2\u01e0\u01e2\5> \2\u01e1\u01e0")
        buf.write("\3\2\2\2\u01e1\u01e2\3\2\2\2\u01e2\u01e3\3\2\2\2\u01e3")
        buf.write("\u01e6\7\5\2\2\u01e4\u01e7\5H%\2\u01e5\u01e7\5J&\2\u01e6")
        buf.write("\u01e4\3\2\2\2\u01e6\u01e5\3\2\2\2\u01e7\u01ef\3\2\2\2")
        buf.write("\u01e8\u01eb\7\27\2\2\u01e9\u01ec\5H%\2\u01ea\u01ec\5")
        buf.write("J&\2\u01eb\u01e9\3\2\2\2\u01eb\u01ea\3\2\2\2\u01ec\u01ee")
        buf.write("\3\2\2\2\u01ed\u01e8\3\2\2\2\u01ee\u01f1\3\2\2\2\u01ef")
        buf.write("\u01ed\3\2\2\2\u01ef\u01f0\3\2\2\2\u01f0\u01f2\3\2\2\2")
        buf.write("\u01f1\u01ef\3\2\2\2\u01f2\u01f3\7\4\2\2\u01f3=\3\2\2")
        buf.write("\2\u01f4\u01f7\7\35\2\2\u01f5\u01f8\5@!\2\u01f6\u01f8")
        buf.write("\5~@\2\u01f7\u01f5\3\2\2\2\u01f7\u01f6\3\2\2\2\u01f8\u01f9")
        buf.write("\3\2\2\2\u01f9\u01fa\7\13\2\2\u01fa\u01ff\5B\"\2\u01fb")
        buf.write("\u01fc\7\f\2\2\u01fc\u01fe\5B\"\2\u01fd\u01fb\3\2\2\2")
        buf.write("\u01fe\u0201\3\2\2\2\u01ff\u01fd\3\2\2\2\u01ff\u0200\3")
        buf.write("\2\2\2\u0200\u0202\3\2\2\2\u0201\u01ff\3\2\2\2\u0202\u0203")
        buf.write("\7\r\2\2\u0203?\3\2\2\2\u0204\u0205\7\36\2\2\u0205\u0206")
        buf.write("\5~@\2\u0206A\3\2\2\2\u0207\u0209\5F$\2\u0208\u0207\3")
        buf.write("\2\2\2\u0208\u0209\3\2\2\2\u0209\u020a\3\2\2\2\u020a\u021a")
        buf.write("\5\u0080A\2\u020b\u020d\5F$\2\u020c\u020b\3\2\2\2\u020c")
        buf.write("\u020d\3\2\2\2\u020d\u020e\3\2\2\2\u020e\u020f\5\u0080")
        buf.write("A\2\u020f\u0210\5D#\2\u0210\u0211\5~@\2\u0211\u021a\3")
        buf.write("\2\2\2\u0212\u0214\5F$\2\u0213\u0212\3\2\2\2\u0213\u0214")
        buf.write("\3\2\2\2\u0214\u0215\3\2\2\2\u0215\u0216\5\u0080A\2\u0216")
        buf.write("\u0217\5D#\2\u0217\u0218\5\u0080A\2\u0218\u021a\3\2\2")
        buf.write("\2\u0219\u0208\3\2\2\2\u0219\u020c\3\2\2\2\u0219\u0213")
        buf.write("\3\2\2\2\u021aC\3\2\2\2\u021b\u021c\t\3\2\2\u021cE\3\2")
        buf.write("\2\2\u021d\u021e\t\4\2\2\u021eG\3\2\2\2\u021f\u0220\7")
        buf.write("\"\2\2\u0220\u0221\7\5\2\2\u0221\u0226\5~@\2\u0222\u0223")
        buf.write("\7\f\2\2\u0223\u0225\5~@\2\u0224\u0222\3\2\2\2\u0225\u0228")
        buf.write("\3\2\2\2\u0226\u0224\3\2\2\2\u0226\u0227\3\2\2\2\u0227")
        buf.write("I\3\2\2\2\u0228\u0226\3\2\2\2\u0229\u022a\7#\2\2\u022a")
        buf.write("\u022f\5N(\2\u022b\u022c\7\f\2\2\u022c\u022e\5N(\2\u022d")
        buf.write("\u022b\3\2\2\2\u022e\u0231\3\2\2\2\u022f\u022d\3\2\2\2")
        buf.write("\u022f\u0230\3\2\2\2\u0230K\3\2\2\2\u0231\u022f\3\2\2")
        buf.write("\2\u0232\u025b\7$\2\2\u0233\u025b\7%\2\2\u0234\u025b\7")
        buf.write("&\2\2\u0235\u0236\7\'\2\2\u0236\u0237\7(\2\2\u0237\u025b")
        buf.write("\7)\2\2\u0238\u0239\7*\2\2\u0239\u025b\7)\2\2\u023a\u023b")
        buf.write("\7+\2\2\u023b\u025b\7)\2\2\u023c\u023d\7\'\2\2\u023d\u023e")
        buf.write("\7(\2\2\u023e\u025b\7,\2\2\u023f\u0240\7*\2\2\u0240\u025b")
        buf.write("\7,\2\2\u0241\u0242\7+\2\2\u0242\u025b\7,\2\2\u0243\u0244")
        buf.write("\7\'\2\2\u0244\u0245\7(\2\2\u0245\u025b\7-\2\2\u0246\u0247")
        buf.write("\7*\2\2\u0247\u025b\7-\2\2\u0248\u0249\7+\2\2\u0249\u025b")
        buf.write("\7-\2\2\u024a\u024b\7\'\2\2\u024b\u024c\7(\2\2\u024c\u025b")
        buf.write("\7.\2\2\u024d\u024e\7*\2\2\u024e\u025b\7.\2\2\u024f\u0250")
        buf.write("\7+\2\2\u0250\u025b\7.\2\2\u0251\u025b\7/\2\2\u0252\u025b")
        buf.write("\7\60\2\2\u0253\u025b\7\61\2\2\u0254\u025b\7\62\2\2\u0255")
        buf.write("\u025b\7\63\2\2\u0256\u025b\7\64\2\2\u0257\u025b\7\65")
        buf.write("\2\2\u0258\u025b\7\'\2\2\u0259\u025b\7\66\2\2\u025a\u0232")
        buf.write("\3\2\2\2\u025a\u0233\3\2\2\2\u025a\u0234\3\2\2\2\u025a")
        buf.write("\u0235\3\2\2\2\u025a\u0238\3\2\2\2\u025a\u023a\3\2\2\2")
        buf.write("\u025a\u023c\3\2\2\2\u025a\u023f\3\2\2\2\u025a\u0241\3")
        buf.write("\2\2\2\u025a\u0243\3\2\2\2\u025a\u0246\3\2\2\2\u025a\u0248")
        buf.write("\3\2\2\2\u025a\u024a\3\2\2\2\u025a\u024d\3\2\2\2\u025a")
        buf.write("\u024f\3\2\2\2\u025a\u0251\3\2\2\2\u025a\u0252\3\2\2\2")
        buf.write("\u025a\u0253\3\2\2\2\u025a\u0254\3\2\2\2\u025a\u0255\3")
        buf.write("\2\2\2\u025a\u0256\3\2\2\2\u025a\u0257\3\2\2\2\u025a\u0258")
        buf.write("\3\2\2\2\u025a\u0259\3\2\2\2\u025bM\3\2\2\2\u025c\u026a")
        buf.write("\5Z.\2\u025d\u026a\5X-\2\u025e\u026a\5P)\2\u025f\u026a")
        buf.write("\5R*\2\u0260\u026a\5T+\2\u0261\u026a\5V,\2\u0262\u026a")
        buf.write("\5^\60\2\u0263\u026a\5`\61\2\u0264\u026a\5b\62\2\u0265")
        buf.write("\u026a\5d\63\2\u0266\u026a\5f\64\2\u0267\u026a\5h\65\2")
        buf.write("\u0268\u026a\5j\66\2\u0269\u025c\3\2\2\2\u0269\u025d\3")
        buf.write("\2\2\2\u0269\u025e\3\2\2\2\u0269\u025f\3\2\2\2\u0269\u0260")
        buf.write("\3\2\2\2\u0269\u0261\3\2\2\2\u0269\u0262\3\2\2\2\u0269")
        buf.write("\u0263\3\2\2\2\u0269\u0264\3\2\2\2\u0269\u0265\3\2\2\2")
        buf.write("\u0269\u0266\3\2\2\2\u0269\u0267\3\2\2\2\u0269\u0268\3")
        buf.write("\2\2\2\u026aO\3\2\2\2\u026b\u026c\5B\"\2\u026c\u026d\t")
        buf.write("\5\2\2\u026d\u026e\5~@\2\u026e\u026f\5n8\2\u026f\u0270")
        buf.write("\5z>\2\u0270Q\3\2\2\2\u0271\u0272\5B\"\2\u0272\u0273\5")
        buf.write("L\'\2\u0273\u0274\5B\"\2\u0274S\3\2\2\2\u0275\u0276\5")
        buf.write("B\"\2\u0276\u0277\5l\67\2\u0277\u0278\5~@\2\u0278U\3\2")
        buf.write("\2\2\u0279\u027a\5B\"\2\u027a\u027b\t\5\2\2\u027b\u027c")
        buf.write("\5~@\2\u027c\u027d\5\u0082B\2\u027d\u027e\5z>\2\u027e")
        buf.write("W\3\2\2\2\u027f\u0280\5B\"\2\u0280\u0281\t\5\2\2\u0281")
        buf.write("\u0282\5~@\2\u0282\u0283\5\u0082B\2\u0283\u0284\5B\"\2")
        buf.write("\u0284\u0285\t\5\2\2\u0285\u0286\5~@\2\u0286Y\3\2\2\2")
        buf.write("\u0287\u0288\5B\"\2\u0288\u0289\5~@\2\u0289\u028a\5B\"")
        buf.write("\2\u028a\u028b\5\u0082B\2\u028b\u028c\5B\"\2\u028c\u028d")
        buf.write("\5~@\2\u028d\u028e\5B\"\2\u028e[\3\2\2\2\u028f\u0290\t")
        buf.write("\6\2\2\u0290]\3\2\2\2\u0291\u0292\5B\"\2\u0292\u0293\7")
        buf.write("?\2\2\u0293\u0295\5B\"\2\u0294\u0296\5\\/\2\u0295\u0294")
        buf.write("\3\2\2\2\u0295\u0296\3\2\2\2\u0296\u0297\3\2\2\2\u0297")
        buf.write("\u029b\5~@\2\u0298\u0299\7@\2\2\u0299\u029c\7A\2\2\u029a")
        buf.write("\u029c\7B\2\2\u029b\u0298\3\2\2\2\u029b\u029a\3\2\2\2")
        buf.write("\u029c\u02a0\3\2\2\2\u029d\u029e\5n8\2\u029e\u029f\5z")
        buf.write(">\2\u029f\u02a1\3\2\2\2\u02a0\u029d\3\2\2\2\u02a0\u02a1")
        buf.write("\3\2\2\2\u02a1_\3\2\2\2\u02a2\u02a4\5B\"\2\u02a3\u02a5")
        buf.write("\5\\/\2\u02a4\u02a3\3\2\2\2\u02a4\u02a5\3\2\2\2\u02a5")
        buf.write("\u02a9\3\2\2\2\u02a6\u02a8\t\7\2\2\u02a7\u02a6\3\2\2\2")
        buf.write("\u02a8\u02ab\3\2\2\2\u02a9\u02a7\3\2\2\2\u02a9\u02aa\3")
        buf.write("\2\2\2\u02aa\u02ac\3\2\2\2\u02ab\u02a9\3\2\2\2\u02ac\u02b0")
        buf.write("\5~@\2\u02ad\u02af\t\b\2\2\u02ae\u02ad\3\2\2\2\u02af\u02b2")
        buf.write("\3\2\2\2\u02b0\u02ae\3\2\2\2\u02b0\u02b1\3\2\2\2\u02b1")
        buf.write("\u02b3\3\2\2\2\u02b2\u02b0\3\2\2\2\u02b3\u02b7\5B\"\2")
        buf.write("\u02b4\u02b5\5n8\2\u02b5\u02b6\5z>\2\u02b6\u02b8\3\2\2")
        buf.write("\2\u02b7\u02b4\3\2\2\2\u02b7\u02b8\3\2\2\2\u02b8a\3\2")
        buf.write("\2\2\u02b9\u02ba\5B\"\2\u02ba\u02bb\5~@\2\u02bb\u02bc")
        buf.write("\5B\"\2\u02bc\u02bd\5\u0082B\2\u02bd\u02be\5z>\2\u02be")
        buf.write("c\3\2\2\2\u02bf\u02c0\7\n\2\2\u02c0\u02c1\7\13\2\2\u02c1")
        buf.write("\u02c6\5~@\2\u02c2\u02c3\7\f\2\2\u02c3\u02c5\5B\"\2\u02c4")
        buf.write("\u02c2\3\2\2\2\u02c5\u02c8\3\2\2\2\u02c6\u02c4\3\2\2\2")
        buf.write("\u02c6\u02c7\3\2\2\2\u02c7\u02c9\3\2\2\2\u02c8\u02c6\3")
        buf.write("\2\2\2\u02c9\u02ca\7\r\2\2\u02cae\3\2\2\2\u02cb\u02cd")
        buf.write("\7J\2\2\u02cc\u02ce\7E\2\2\u02cd\u02cc\3\2\2\2\u02cd\u02ce")
        buf.write("\3\2\2\2\u02ce\u02cf\3\2\2\2\u02cf\u02d0\5\u0082B\2\u02d0")
        buf.write("\u02d1\5z>\2\u02d1\u02d2\5~@\2\u02d2\u02d3\7K\2\2\u02d3")
        buf.write("\u02d4\5B\"\2\u02d4g\3\2\2\2\u02d5\u02d7\7J\2\2\u02d6")
        buf.write("\u02d8\7E\2\2\u02d7\u02d6\3\2\2\2\u02d7\u02d8\3\2\2\2")
        buf.write("\u02d8\u02d9\3\2\2\2\u02d9\u02da\5\u0082B\2\u02da\u02db")
        buf.write("\5z>\2\u02db\u02dc\5~@\2\u02dc\u02dd\7K\2\2\u02dd\u02de")
        buf.write("\5B\"\2\u02de\u02df\7\67\2\2\u02df\u02e0\5~@\2\u02e0i")
        buf.write("\3\2\2\2\u02e1\u02e2\7J\2\2\u02e2\u02e3\7E\2\2\u02e3\u02e4")
        buf.write("\5B\"\2\u02e4\u02e5\7\67\2\2\u02e5\u02e6\5~@\2\u02e6\u02ee")
        buf.write("\3\2\2\2\u02e7\u02e8\5B\"\2\u02e8\u02e9\7\67\2\2\u02e9")
        buf.write("\u02ea\5~@\2\u02ea\u02eb\7E\2\2\u02eb\u02ec\7J\2\2\u02ec")
        buf.write("\u02ee\3\2\2\2\u02ed\u02e1\3\2\2\2\u02ed\u02e7\3\2\2\2")
        buf.write("\u02eek\3\2\2\2\u02ef\u02f0\t\t\2\2\u02f0m\3\2\2\2\u02f1")
        buf.write("\u02f2\t\n\2\2\u02f2o\3\2\2\2\u02f3\u02f4\7R\2\2\u02f4")
        buf.write("\u02f5\5~@\2\u02f5\u0306\7\5\2\2\u02f6\u02fa\5x=\2\u02f7")
        buf.write("\u02fa\5r:\2\u02f8\u02fa\5H%\2\u02f9\u02f6\3\2\2\2\u02f9")
        buf.write("\u02f7\3\2\2\2\u02f9\u02f8\3\2\2\2\u02fa\u0303\3\2\2\2")
        buf.write("\u02fb\u02ff\7\27\2\2\u02fc\u0300\5x=\2\u02fd\u0300\5")
        buf.write("r:\2\u02fe\u0300\5H%\2\u02ff\u02fc\3\2\2\2\u02ff\u02fd")
        buf.write("\3\2\2\2\u02ff\u02fe\3\2\2\2\u0300\u0302\3\2\2\2\u0301")
        buf.write("\u02fb\3\2\2\2\u0302\u0305\3\2\2\2\u0303\u0301\3\2\2\2")
        buf.write("\u0303\u0304\3\2\2\2\u0304\u0307\3\2\2\2\u0305\u0303\3")
        buf.write("\2\2\2\u0306\u02f9\3\2\2\2\u0306\u0307\3\2\2\2\u0307\u0308")
        buf.write("\3\2\2\2\u0308\u0309\7\4\2\2\u0309q\3\2\2\2\u030a\u030b")
        buf.write("\7S\2\2\u030b\u030c\7\5\2\2\u030c\u030d\5t;\2\u030ds\3")
        buf.write("\2\2\2\u030e\u030f\7\36\2\2\u030f\u0314\5~@\2\u0310\u0311")
        buf.write("\7\f\2\2\u0311\u0313\5~@\2\u0312\u0310\3\2\2\2\u0313\u0316")
        buf.write("\3\2\2\2\u0314\u0312\3\2\2\2\u0314\u0315\3\2\2\2\u0315")
        buf.write("u\3\2\2\2\u0316\u0314\3\2\2\2\u0317\u0318\7`\2\2\u0318")
        buf.write("w\3\2\2\2\u0319\u031a\7T\2\2\u031a\u031b\7\5\2\2\u031b")
        buf.write("\u0320\5\u0084C\2\u031c\u031d\7\f\2\2\u031d\u031f\5\u0084")
        buf.write("C\2\u031e\u031c\3\2\2\2\u031f\u0322\3\2\2\2\u0320\u031e")
        buf.write("\3\2\2\2\u0320\u0321\3\2\2\2\u0321y\3\2\2\2\u0322\u0320")
        buf.write("\3\2\2\2\u0323\u0324\7c\2\2\u0324{\3\2\2\2\u0325\u0326")
        buf.write("\7d\2\2\u0326}\3\2\2\2\u0327\u0328\7f\2\2\u0328\177\3")
        buf.write("\2\2\2\u0329\u032a\7g\2\2\u032a\u0081\3\2\2\2\u032b\u032c")
        buf.write("\t\13\2\2\u032c\u0083\3\2\2\2\u032d\u032e\7[\2\2\u032e")
        buf.write("\u032f\5z>\2\u032f\u0330\7\\\2\2\u0330\u0331\5~@\2\u0331")
        buf.write("\u033d\3\2\2\2\u0332\u0333\7[\2\2\u0333\u0334\5z>\2\u0334")
        buf.write("\u0335\7\5\2\2\u0335\u0336\5z>\2\u0336\u0338\7\\\2\2\u0337")
        buf.write("\u0339\5\u0086D\2\u0338\u0337\3\2\2\2\u0338\u0339\3\2")
        buf.write("\2\2\u0339\u033a\3\2\2\2\u033a\u033b\5~@\2\u033b\u033d")
        buf.write("\3\2\2\2\u033c\u032d\3\2\2\2\u033c\u0332\3\2\2\2\u033d")
        buf.write("\u0085\3\2\2\2\u033e\u0340\t\f\2\2\u033f\u033e\3\2\2\2")
        buf.write("\u0340\u0341\3\2\2\2\u0341\u033f\3\2\2\2\u0341\u0342\3")
        buf.write("\2\2\2\u0342\u0087\3\2\2\2T\u008e\u0090\u0098\u00a6\u00a8")
        buf.write("\u00ad\u00b1\u00c0\u00c5\u00ca\u00ce\u00d5\u00df\u00e4")
        buf.write("\u00f0\u00f4\u00f8\u00ff\u0108\u010d\u0111\u0117\u0124")
        buf.write("\u0128\u0131\u0135\u0140\u0144\u014d\u0152\u0157\u0159")
        buf.write("\u015c\u0166\u016b\u016e\u0171\u0175\u017b\u018c\u0198")
        buf.write("\u01a1\u01ad\u01b9\u01c4\u01c9\u01d2\u01dc\u01e1\u01e6")
        buf.write("\u01eb\u01ef\u01f7\u01ff\u0208\u020c\u0213\u0219\u0226")
        buf.write("\u022f\u025a\u0269\u0295\u029b\u02a0\u02a4\u02a9\u02b0")
        buf.write("\u02b7\u02c6\u02cd\u02d7\u02ed\u02f9\u02ff\u0303\u0306")
        buf.write("\u0314\u0320\u0338\u033c\u0341")
        return buf.getvalue()


class kismetParser ( Parser ):

    grammarFileName = "kismet.ebnv"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'time'", "'.'", "':'", "'?'", "'+'", 
                     "'*'", "'|'", "'pattern'", "'('", "','", "')'", "'opposes'", 
                     "'/'", "'default'", "'trait'", "'status'", "'scalar'", 
                     "'visibility'", "'@'", "'action'", "';'", "'costs'", 
                     "'response'", "'result'", "'location:'", "'role'", 
                     "'extends'", "'cast'", "'<'", "'^'", "'>'", "'tags'", 
                     "'if'", "'does not know'", "'doesnt know'", "'doesn't know'", 
                     "'did'", "'not'", "'hear'", "'didnt'", "'didn't'", 
                     "'see'", "'do'", "'receive'", "'forgets'", "'forgot'", 
                     "'forget'", "'knows'", "'hears'", "'heard'", "'saw'", 
                     "'received'", "''s'", "'s'", "'do not'", "'dont'", 
                     "'don't'", "'does not'", "'doesn't'", "'doesnt'", "'and'", 
                     "'each'", "'other'", "'eachother'", "'have'", "'has'", 
                     "'is'", "'of'", "'to'", "'with'", "'at'", "'now'", 
                     "'since'", "'is missing'", "'is not'", "'isn't'", "'isnt'", 
                     "'aint'", "'missing'", "'location'", "'each_turn'", 
                     "'supports'", "'='", "'=='", "'<='", "'>='", "'!='", 
                     "'_'", "'['", "']'", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "'-'" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "OPEN", "CLOSE", "MINUS", "PLUS", "EQUALS", 
                      "RANDOM_TEXT", "WS", "LINE_COMMENT", "NUMBER", "POSITIVE_NUMBER", 
                      "NEG", "NAME", "VAR" ]

    RULE_world = 0
    RULE_time = 1
    RULE_num_range = 2
    RULE_time_statement = 3
    RULE_time_start_modifier = 4
    RULE_time_iteration_modifier = 5
    RULE_list_range = 6
    RULE_time_type = 7
    RULE_pattern = 8
    RULE_opposition = 9
    RULE_trait = 10
    RULE_default = 11
    RULE_trait_type = 12
    RULE_is_num = 13
    RULE_propensity = 14
    RULE_propensity_name = 15
    RULE_modifier = 16
    RULE_goto = 17
    RULE_valence = 18
    RULE_action = 19
    RULE_cost = 20
    RULE_response = 21
    RULE_add = 22
    RULE_change = 23
    RULE_visibility = 24
    RULE_action_location = 25
    RULE_loc = 26
    RULE_locWildCard = 27
    RULE_action_item = 28
    RULE_role = 29
    RULE_extension = 30
    RULE_cast_name = 31
    RULE_arg = 32
    RULE_sub = 33
    RULE_arg_type = 34
    RULE_tags = 35
    RULE_comparison = 36
    RULE_knowledge = 37
    RULE_condition = 38
    RULE_cond8 = 39
    RULE_cond3 = 40
    RULE_cond1 = 41
    RULE_cond4 = 42
    RULE_cond9 = 43
    RULE_cond10 = 44
    RULE_inversion = 45
    RULE_cond5 = 46
    RULE_cond6 = 47
    RULE_cond7 = 48
    RULE_condpattern = 49
    RULE_condTimeHistory = 50
    RULE_condTimePersonal = 51
    RULE_condTimePersonalAssignment = 52
    RULE_tag_compare = 53
    RULE_operator = 54
    RULE_location = 55
    RULE_each_turn = 56
    RULE_cast = 57
    RULE_random_text = 58
    RULE_supports = 59
    RULE_num = 60
    RULE_pos_num = 61
    RULE_name = 62
    RULE_var = 63
    RULE_comparator = 64
    RULE_num_choice = 65
    RULE_pdf = 66

    ruleNames =  [ "world", "time", "num_range", "time_statement", "time_start_modifier", 
                   "time_iteration_modifier", "list_range", "time_type", 
                   "pattern", "opposition", "trait", "default", "trait_type", 
                   "is_num", "propensity", "propensity_name", "modifier", 
                   "goto", "valence", "action", "cost", "response", "add", 
                   "change", "visibility", "action_location", "loc", "locWildCard", 
                   "action_item", "role", "extension", "cast_name", "arg", 
                   "sub", "arg_type", "tags", "comparison", "knowledge", 
                   "condition", "cond8", "cond3", "cond1", "cond4", "cond9", 
                   "cond10", "inversion", "cond5", "cond6", "cond7", "condpattern", 
                   "condTimeHistory", "condTimePersonal", "condTimePersonalAssignment", 
                   "tag_compare", "operator", "location", "each_turn", "cast", 
                   "random_text", "supports", "num", "pos_num", "name", 
                   "var", "comparator", "num_choice", "pdf" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    T__2=3
    T__3=4
    T__4=5
    T__5=6
    T__6=7
    T__7=8
    T__8=9
    T__9=10
    T__10=11
    T__11=12
    T__12=13
    T__13=14
    T__14=15
    T__15=16
    T__16=17
    T__17=18
    T__18=19
    T__19=20
    T__20=21
    T__21=22
    T__22=23
    T__23=24
    T__24=25
    T__25=26
    T__26=27
    T__27=28
    T__28=29
    T__29=30
    T__30=31
    T__31=32
    T__32=33
    T__33=34
    T__34=35
    T__35=36
    T__36=37
    T__37=38
    T__38=39
    T__39=40
    T__40=41
    T__41=42
    T__42=43
    T__43=44
    T__44=45
    T__45=46
    T__46=47
    T__47=48
    T__48=49
    T__49=50
    T__50=51
    T__51=52
    T__52=53
    T__53=54
    T__54=55
    T__55=56
    T__56=57
    T__57=58
    T__58=59
    T__59=60
    T__60=61
    T__61=62
    T__62=63
    T__63=64
    T__64=65
    T__65=66
    T__66=67
    T__67=68
    T__68=69
    T__69=70
    T__70=71
    T__71=72
    T__72=73
    T__73=74
    T__74=75
    T__75=76
    T__76=77
    T__77=78
    T__78=79
    T__79=80
    T__80=81
    T__81=82
    T__82=83
    T__83=84
    T__84=85
    T__85=86
    T__86=87
    T__87=88
    OPEN=89
    CLOSE=90
    MINUS=91
    PLUS=92
    EQUALS=93
    RANDOM_TEXT=94
    WS=95
    LINE_COMMENT=96
    NUMBER=97
    POSITIVE_NUMBER=98
    NEG=99
    NAME=100
    VAR=101

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.7.2")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class WorldContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOF(self):
            return self.getToken(kismetParser.EOF, 0)

        def location(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.LocationContext)
            else:
                return self.getTypedRuleContext(kismetParser.LocationContext,i)


        def role(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.RoleContext)
            else:
                return self.getTypedRuleContext(kismetParser.RoleContext,i)


        def action(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.ActionContext)
            else:
                return self.getTypedRuleContext(kismetParser.ActionContext,i)


        def trait(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.TraitContext)
            else:
                return self.getTypedRuleContext(kismetParser.TraitContext,i)


        def pattern(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.PatternContext)
            else:
                return self.getTypedRuleContext(kismetParser.PatternContext,i)


        def time(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.TimeContext)
            else:
                return self.getTypedRuleContext(kismetParser.TimeContext,i)


        def getRuleIndex(self):
            return kismetParser.RULE_world

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWorld" ):
                listener.enterWorld(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWorld" ):
                listener.exitWorld(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWorld" ):
                return visitor.visitWorld(self)
            else:
                return visitor.visitChildren(self)




    def world(self):

        localctx = kismetParser.WorldContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_world)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 140 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 140
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [kismetParser.T__79]:
                    self.state = 134
                    self.location()
                    pass
                elif token in [kismetParser.T__25]:
                    self.state = 135
                    self.role()
                    pass
                elif token in [kismetParser.T__19, kismetParser.T__22]:
                    self.state = 136
                    self.action()
                    pass
                elif token in [kismetParser.T__13, kismetParser.T__14, kismetParser.T__15]:
                    self.state = 137
                    self.trait()
                    pass
                elif token in [kismetParser.T__7]:
                    self.state = 138
                    self.pattern()
                    pass
                elif token in [kismetParser.T__0]:
                    self.state = 139
                    self.time()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 142 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << kismetParser.T__0) | (1 << kismetParser.T__7) | (1 << kismetParser.T__13) | (1 << kismetParser.T__14) | (1 << kismetParser.T__15) | (1 << kismetParser.T__19) | (1 << kismetParser.T__22) | (1 << kismetParser.T__25))) != 0) or _la==kismetParser.T__79):
                    break

            self.state = 144
            self.match(kismetParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TimeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def time_statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.Time_statementContext)
            else:
                return self.getTypedRuleContext(kismetParser.Time_statementContext,i)


        def getRuleIndex(self):
            return kismetParser.RULE_time

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTime" ):
                listener.enterTime(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTime" ):
                listener.exitTime(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTime" ):
                return visitor.visitTime(self)
            else:
                return visitor.visitChildren(self)




    def time(self):

        localctx = kismetParser.TimeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_time)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 146
            self.match(kismetParser.T__0)
            self.state = 148 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 147
                self.time_statement()
                self.state = 150 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==kismetParser.NAME):
                    break

            self.state = 152
            self.match(kismetParser.T__1)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Num_rangeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OPEN(self):
            return self.getToken(kismetParser.OPEN, 0)

        def num(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.NumContext)
            else:
                return self.getTypedRuleContext(kismetParser.NumContext,i)


        def CLOSE(self):
            return self.getToken(kismetParser.CLOSE, 0)

        def pdf(self):
            return self.getTypedRuleContext(kismetParser.PdfContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_num_range

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNum_range" ):
                listener.enterNum_range(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNum_range" ):
                listener.exitNum_range(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNum_range" ):
                return visitor.visitNum_range(self)
            else:
                return visitor.visitChildren(self)




    def num_range(self):

        localctx = kismetParser.Num_rangeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_num_range)
        try:
            self.state = 166
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,4,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 154
                self.match(kismetParser.OPEN)
                self.state = 155
                self.num()
                self.state = 156
                self.match(kismetParser.CLOSE)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 158
                self.match(kismetParser.OPEN)
                self.state = 159
                self.num()
                self.state = 160
                self.match(kismetParser.T__2)
                self.state = 161
                self.num()
                self.state = 162
                self.match(kismetParser.CLOSE)
                self.state = 164
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,3,self._ctx)
                if la_ == 1:
                    self.state = 163
                    self.pdf()


                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Time_statementContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def name(self):
            return self.getTypedRuleContext(kismetParser.NameContext,0)


        def time_type(self):
            return self.getTypedRuleContext(kismetParser.Time_typeContext,0)


        def time_start_modifier(self):
            return self.getTypedRuleContext(kismetParser.Time_start_modifierContext,0)


        def time_iteration_modifier(self):
            return self.getTypedRuleContext(kismetParser.Time_iteration_modifierContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_time_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTime_statement" ):
                listener.enterTime_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTime_statement" ):
                listener.exitTime_statement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTime_statement" ):
                return visitor.visitTime_statement(self)
            else:
                return visitor.visitChildren(self)




    def time_statement(self):

        localctx = kismetParser.Time_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_time_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 168
            self.name()
            self.state = 169
            self.match(kismetParser.T__2)
            self.state = 171
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==kismetParser.T__3:
                self.state = 170
                self.time_start_modifier()


            self.state = 173
            self.time_type()
            self.state = 175
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << kismetParser.T__3) | (1 << kismetParser.T__4) | (1 << kismetParser.T__5))) != 0):
                self.state = 174
                self.time_iteration_modifier()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Time_start_modifierContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return kismetParser.RULE_time_start_modifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTime_start_modifier" ):
                listener.enterTime_start_modifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTime_start_modifier" ):
                listener.exitTime_start_modifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTime_start_modifier" ):
                return visitor.visitTime_start_modifier(self)
            else:
                return visitor.visitChildren(self)




    def time_start_modifier(self):

        localctx = kismetParser.Time_start_modifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_time_start_modifier)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 177
            self.match(kismetParser.T__3)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Time_iteration_modifierContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def num(self):
            return self.getTypedRuleContext(kismetParser.NumContext,0)


        def num_range(self):
            return self.getTypedRuleContext(kismetParser.Num_rangeContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_time_iteration_modifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTime_iteration_modifier" ):
                listener.enterTime_iteration_modifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTime_iteration_modifier" ):
                listener.exitTime_iteration_modifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTime_iteration_modifier" ):
                return visitor.visitTime_iteration_modifier(self)
            else:
                return visitor.visitChildren(self)




    def time_iteration_modifier(self):

        localctx = kismetParser.Time_iteration_modifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_time_iteration_modifier)
        try:
            self.state = 190
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,7,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 179
                self.match(kismetParser.T__4)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 180
                self.match(kismetParser.T__5)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 181
                self.match(kismetParser.T__3)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 182
                self.match(kismetParser.T__4)
                self.state = 183
                self.num()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 184
                self.match(kismetParser.T__4)
                self.state = 185
                self.num_range()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 186
                self.match(kismetParser.T__5)
                self.state = 187
                self.num()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 188
                self.match(kismetParser.T__5)
                self.state = 189
                self.num_range()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class List_rangeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OPEN(self):
            return self.getToken(kismetParser.OPEN, 0)

        def CLOSE(self):
            return self.getToken(kismetParser.CLOSE, 0)

        def name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.NameContext)
            else:
                return self.getTypedRuleContext(kismetParser.NameContext,i)


        def var(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.VarContext)
            else:
                return self.getTypedRuleContext(kismetParser.VarContext,i)


        def getRuleIndex(self):
            return kismetParser.RULE_list_range

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterList_range" ):
                listener.enterList_range(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitList_range" ):
                listener.exitList_range(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitList_range" ):
                return visitor.visitList_range(self)
            else:
                return visitor.visitChildren(self)




    def list_range(self):

        localctx = kismetParser.List_rangeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_list_range)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 192
            self.match(kismetParser.OPEN)
            self.state = 195
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [kismetParser.NAME]:
                self.state = 193
                self.name()
                pass
            elif token in [kismetParser.VAR]:
                self.state = 194
                self.var()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 204
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__6:
                self.state = 197
                self.match(kismetParser.T__6)
                self.state = 200
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [kismetParser.NAME]:
                    self.state = 198
                    self.name()
                    pass
                elif token in [kismetParser.VAR]:
                    self.state = 199
                    self.var()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 206
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 207
            self.match(kismetParser.CLOSE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Time_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def num_range(self):
            return self.getTypedRuleContext(kismetParser.Num_rangeContext,0)


        def list_range(self):
            return self.getTypedRuleContext(kismetParser.List_rangeContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_time_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTime_type" ):
                listener.enterTime_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTime_type" ):
                listener.exitTime_type(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTime_type" ):
                return visitor.visitTime_type(self)
            else:
                return visitor.visitChildren(self)




    def time_type(self):

        localctx = kismetParser.Time_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_time_type)
        try:
            self.state = 211
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,11,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 209
                self.num_range()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 210
                self.list_range()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PatternContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def name(self):
            return self.getTypedRuleContext(kismetParser.NameContext,0)


        def arg(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.ArgContext)
            else:
                return self.getTypedRuleContext(kismetParser.ArgContext,i)


        def comparison(self):
            return self.getTypedRuleContext(kismetParser.ComparisonContext,0)


        def random_text(self):
            return self.getTypedRuleContext(kismetParser.Random_textContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_pattern

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPattern" ):
                listener.enterPattern(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPattern" ):
                listener.exitPattern(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPattern" ):
                return visitor.visitPattern(self)
            else:
                return visitor.visitChildren(self)




    def pattern(self):

        localctx = kismetParser.PatternContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_pattern)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 213
            self.match(kismetParser.T__7)
            self.state = 214
            self.name()
            self.state = 215
            self.match(kismetParser.T__8)
            self.state = 216
            self.arg()
            self.state = 221
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__9:
                self.state = 217
                self.match(kismetParser.T__9)
                self.state = 218
                self.arg()
                self.state = 223
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 224
            self.match(kismetParser.T__10)
            self.state = 226
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==kismetParser.RANDOM_TEXT:
                self.state = 225
                self.random_text()


            self.state = 228
            self.match(kismetParser.T__2)
            self.state = 229
            self.comparison()
            self.state = 230
            self.match(kismetParser.T__1)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OppositionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.NameContext)
            else:
                return self.getTypedRuleContext(kismetParser.NameContext,i)


        def getRuleIndex(self):
            return kismetParser.RULE_opposition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOpposition" ):
                listener.enterOpposition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOpposition" ):
                listener.exitOpposition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOpposition" ):
                return visitor.visitOpposition(self)
            else:
                return visitor.visitChildren(self)




    def opposition(self):

        localctx = kismetParser.OppositionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_opposition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 232
            self.match(kismetParser.T__11)
            self.state = 233
            self.name()
            self.state = 238
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__12:
                self.state = 234
                self.match(kismetParser.T__12)
                self.state = 235
                self.name()
                self.state = 240
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraitContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def trait_type(self):
            return self.getTypedRuleContext(kismetParser.Trait_typeContext,0)


        def name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.NameContext)
            else:
                return self.getTypedRuleContext(kismetParser.NameContext,i)


        def arg(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.ArgContext)
            else:
                return self.getTypedRuleContext(kismetParser.ArgContext,i)


        def default(self):
            return self.getTypedRuleContext(kismetParser.DefaultContext,0)


        def is_num(self):
            return self.getTypedRuleContext(kismetParser.Is_numContext,0)


        def opposition(self):
            return self.getTypedRuleContext(kismetParser.OppositionContext,0)


        def propensity(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.PropensityContext)
            else:
                return self.getTypedRuleContext(kismetParser.PropensityContext,i)


        def getRuleIndex(self):
            return kismetParser.RULE_trait

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTrait" ):
                listener.enterTrait(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTrait" ):
                listener.exitTrait(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTrait" ):
                return visitor.visitTrait(self)
            else:
                return visitor.visitChildren(self)




    def trait(self):

        localctx = kismetParser.TraitContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_trait)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 242
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==kismetParser.T__13:
                self.state = 241
                self.default()


            self.state = 244
            self.trait_type()
            self.state = 246
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==kismetParser.T__16:
                self.state = 245
                self.is_num()


            self.state = 248
            self.name()
            self.state = 253
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__12:
                self.state = 249
                self.match(kismetParser.T__12)
                self.state = 250
                self.name()
                self.state = 255
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 256
            self.match(kismetParser.T__8)
            self.state = 257
            self.arg()
            self.state = 262
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__9:
                self.state = 258
                self.match(kismetParser.T__9)
                self.state = 259
                self.arg()
                self.state = 264
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 265
            self.match(kismetParser.T__10)
            self.state = 267
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==kismetParser.T__11:
                self.state = 266
                self.opposition()


            self.state = 269
            self.match(kismetParser.T__2)
            self.state = 271
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==kismetParser.T__4 or _la==kismetParser.NEG:
                self.state = 270
                self.propensity()


            self.state = 277
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__9:
                self.state = 273
                self.match(kismetParser.T__9)
                self.state = 274
                self.propensity()
                self.state = 279
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 280
            self.match(kismetParser.T__1)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DefaultContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return kismetParser.RULE_default

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDefault" ):
                listener.enterDefault(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDefault" ):
                listener.exitDefault(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDefault" ):
                return visitor.visitDefault(self)
            else:
                return visitor.visitChildren(self)




    def default(self):

        localctx = kismetParser.DefaultContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_default)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 282
            self.match(kismetParser.T__13)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Trait_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return kismetParser.RULE_trait_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTrait_type" ):
                listener.enterTrait_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTrait_type" ):
                listener.exitTrait_type(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTrait_type" ):
                return visitor.visitTrait_type(self)
            else:
                return visitor.visitChildren(self)




    def trait_type(self):

        localctx = kismetParser.Trait_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_trait_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 284
            _la = self._input.LA(1)
            if not(_la==kismetParser.T__14 or _la==kismetParser.T__15):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Is_numContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return kismetParser.RULE_is_num

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIs_num" ):
                listener.enterIs_num(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIs_num" ):
                listener.exitIs_num(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIs_num" ):
                return visitor.visitIs_num(self)
            else:
                return visitor.visitChildren(self)




    def is_num(self):

        localctx = kismetParser.Is_numContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_is_num)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 286
            self.match(kismetParser.T__16)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PropensityContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def modifier(self):
            return self.getTypedRuleContext(kismetParser.ModifierContext,0)


        def goto(self):
            return self.getTypedRuleContext(kismetParser.GotoContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_propensity

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPropensity" ):
                listener.enterPropensity(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPropensity" ):
                listener.exitPropensity(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPropensity" ):
                return visitor.visitPropensity(self)
            else:
                return visitor.visitChildren(self)




    def propensity(self):

        localctx = kismetParser.PropensityContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_propensity)
        try:
            self.state = 290
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,22,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 288
                self.modifier()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 289
                self.goto()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Propensity_nameContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def name(self):
            return self.getTypedRuleContext(kismetParser.NameContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_propensity_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPropensity_name" ):
                listener.enterPropensity_name(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPropensity_name" ):
                listener.exitPropensity_name(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPropensity_name" ):
                return visitor.visitPropensity_name(self)
            else:
                return visitor.visitChildren(self)




    def propensity_name(self):

        localctx = kismetParser.Propensity_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_propensity_name)
        try:
            self.state = 294
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [kismetParser.T__17]:
                self.enterOuterAlt(localctx, 1)
                self.state = 292
                self.match(kismetParser.T__17)
                pass
            elif token in [kismetParser.NAME]:
                self.enterOuterAlt(localctx, 2)
                self.state = 293
                self.name()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ModifierContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def valence(self):
            return self.getTypedRuleContext(kismetParser.ValenceContext,0)


        def propensity_name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.Propensity_nameContext)
            else:
                return self.getTypedRuleContext(kismetParser.Propensity_nameContext,i)


        def comparison(self):
            return self.getTypedRuleContext(kismetParser.ComparisonContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_modifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterModifier" ):
                listener.enterModifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitModifier" ):
                listener.exitModifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitModifier" ):
                return visitor.visitModifier(self)
            else:
                return visitor.visitChildren(self)




    def modifier(self):

        localctx = kismetParser.ModifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_modifier)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 296
            self.valence()
            self.state = 297
            self.match(kismetParser.T__8)
            self.state = 298
            self.propensity_name()
            self.state = 303
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__9:
                self.state = 299
                self.match(kismetParser.T__9)
                self.state = 300
                self.propensity_name()
                self.state = 305
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 307
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==kismetParser.T__32:
                self.state = 306
                self.comparison()


            self.state = 309
            self.match(kismetParser.T__10)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GotoContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def valence(self):
            return self.getTypedRuleContext(kismetParser.ValenceContext,0)


        def name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.NameContext)
            else:
                return self.getTypedRuleContext(kismetParser.NameContext,i)


        def comparison(self):
            return self.getTypedRuleContext(kismetParser.ComparisonContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_goto

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGoto" ):
                listener.enterGoto(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGoto" ):
                listener.exitGoto(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGoto" ):
                return visitor.visitGoto(self)
            else:
                return visitor.visitChildren(self)




    def goto(self):

        localctx = kismetParser.GotoContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_goto)
        self._la = 0 # Token type
        try:
            self.state = 331
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,28,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 311
                self.valence()
                self.state = 312
                self.match(kismetParser.T__18)
                self.state = 313
                self.name()
                self.state = 318
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==kismetParser.T__9:
                    self.state = 314
                    self.match(kismetParser.T__9)
                    self.state = 315
                    self.name()
                    self.state = 320
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 322
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==kismetParser.T__32:
                    self.state = 321
                    self.comparison()


                self.state = 324
                self.match(kismetParser.T__18)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 326
                self.valence()
                self.state = 327
                self.match(kismetParser.T__18)
                self.state = 328
                self.comparison()
                self.state = 329
                self.match(kismetParser.T__18)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ValenceContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NEG(self, i:int=None):
            if i is None:
                return self.getTokens(kismetParser.NEG)
            else:
                return self.getToken(kismetParser.NEG, i)

        def getRuleIndex(self):
            return kismetParser.RULE_valence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterValence" ):
                listener.enterValence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitValence" ):
                listener.exitValence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitValence" ):
                return visitor.visitValence(self)
            else:
                return visitor.visitChildren(self)




    def valence(self):

        localctx = kismetParser.ValenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_valence)
        self._la = 0 # Token type
        try:
            self.state = 343
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [kismetParser.T__4]:
                self.enterOuterAlt(localctx, 1)
                self.state = 334 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 333
                    self.match(kismetParser.T__4)
                    self.state = 336 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==kismetParser.T__4):
                        break

                pass
            elif token in [kismetParser.NEG]:
                self.enterOuterAlt(localctx, 2)
                self.state = 339 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 338
                    self.match(kismetParser.NEG)
                    self.state = 341 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==kismetParser.NEG):
                        break

                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ActionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def name(self):
            return self.getTypedRuleContext(kismetParser.NameContext,0)


        def arg(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.ArgContext)
            else:
                return self.getTypedRuleContext(kismetParser.ArgContext,i)


        def response(self):
            return self.getTypedRuleContext(kismetParser.ResponseContext,0)


        def cost(self):
            return self.getTypedRuleContext(kismetParser.CostContext,0)


        def extension(self):
            return self.getTypedRuleContext(kismetParser.ExtensionContext,0)


        def random_text(self):
            return self.getTypedRuleContext(kismetParser.Random_textContext,0)


        def action_item(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.Action_itemContext)
            else:
                return self.getTypedRuleContext(kismetParser.Action_itemContext,i)


        def getRuleIndex(self):
            return kismetParser.RULE_action

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAction" ):
                listener.enterAction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAction" ):
                listener.exitAction(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAction" ):
                return visitor.visitAction(self)
            else:
                return visitor.visitChildren(self)




    def action(self):

        localctx = kismetParser.ActionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_action)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 346
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==kismetParser.T__22:
                self.state = 345
                self.response()


            self.state = 348
            self.match(kismetParser.T__19)
            self.state = 349
            self.name()
            self.state = 350
            self.match(kismetParser.T__8)
            self.state = 351
            self.arg()
            self.state = 356
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__9:
                self.state = 352
                self.match(kismetParser.T__9)
                self.state = 353
                self.arg()
                self.state = 358
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 359
            self.match(kismetParser.T__10)
            self.state = 361
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==kismetParser.T__21:
                self.state = 360
                self.cost()


            self.state = 364
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==kismetParser.T__26:
                self.state = 363
                self.extension()


            self.state = 367
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==kismetParser.RANDOM_TEXT:
                self.state = 366
                self.random_text()


            self.state = 369
            self.match(kismetParser.T__2)
            self.state = 371
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << kismetParser.T__17) | (1 << kismetParser.T__23) | (1 << kismetParser.T__24) | (1 << kismetParser.T__31) | (1 << kismetParser.T__32))) != 0):
                self.state = 370
                self.action_item()


            self.state = 377
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__20:
                self.state = 373
                self.match(kismetParser.T__20)

                self.state = 374
                self.action_item()
                self.state = 379
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 380
            self.match(kismetParser.T__1)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CostContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def num(self):
            return self.getTypedRuleContext(kismetParser.NumContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_cost

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCost" ):
                listener.enterCost(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCost" ):
                listener.exitCost(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCost" ):
                return visitor.visitCost(self)
            else:
                return visitor.visitChildren(self)




    def cost(self):

        localctx = kismetParser.CostContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_cost)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 382
            self.match(kismetParser.T__21)
            self.state = 383
            self.num()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ResponseContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return kismetParser.RULE_response

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterResponse" ):
                listener.enterResponse(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitResponse" ):
                listener.exitResponse(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitResponse" ):
                return visitor.visitResponse(self)
            else:
                return visitor.visitChildren(self)




    def response(self):

        localctx = kismetParser.ResponseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_response)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 385
            self.match(kismetParser.T__22)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AddContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def change(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.ChangeContext)
            else:
                return self.getTypedRuleContext(kismetParser.ChangeContext,i)


        def getRuleIndex(self):
            return kismetParser.RULE_add

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAdd" ):
                listener.enterAdd(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAdd" ):
                listener.exitAdd(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAdd" ):
                return visitor.visitAdd(self)
            else:
                return visitor.visitChildren(self)




    def add(self):

        localctx = kismetParser.AddContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_add)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 387
            self.match(kismetParser.T__23)
            self.state = 388
            self.match(kismetParser.T__2)
            self.state = 389
            self.change()
            self.state = 394
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__9:
                self.state = 390
                self.match(kismetParser.T__9)
                self.state = 391
                self.change()
                self.state = 396
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ChangeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def condition(self):
            return self.getTypedRuleContext(kismetParser.ConditionContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_change

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterChange" ):
                listener.enterChange(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitChange" ):
                listener.exitChange(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitChange" ):
                return visitor.visitChange(self)
            else:
                return visitor.visitChildren(self)




    def change(self):

        localctx = kismetParser.ChangeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_change)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 397
            self.condition()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VisibilityContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def valence(self):
            return self.getTypedRuleContext(kismetParser.ValenceContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_visibility

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVisibility" ):
                listener.enterVisibility(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVisibility" ):
                listener.exitVisibility(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVisibility" ):
                return visitor.visitVisibility(self)
            else:
                return visitor.visitChildren(self)




    def visibility(self):

        localctx = kismetParser.VisibilityContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_visibility)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 399
            self.match(kismetParser.T__17)
            self.state = 400
            self.valence()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Action_locationContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def loc(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.LocContext)
            else:
                return self.getTypedRuleContext(kismetParser.LocContext,i)


        def getRuleIndex(self):
            return kismetParser.RULE_action_location

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAction_location" ):
                listener.enterAction_location(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAction_location" ):
                listener.exitAction_location(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAction_location" ):
                return visitor.visitAction_location(self)
            else:
                return visitor.visitChildren(self)




    def action_location(self):

        localctx = kismetParser.Action_locationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_action_location)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 402
            self.match(kismetParser.T__24)
            self.state = 404 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 403
                self.loc()
                self.state = 406 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==kismetParser.T__3 or _la==kismetParser.T__8 or _la==kismetParser.NAME or _la==kismetParser.VAR):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LocContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def var(self):
            return self.getTypedRuleContext(kismetParser.VarContext,0)


        def arg(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.ArgContext)
            else:
                return self.getTypedRuleContext(kismetParser.ArgContext,i)


        def name(self):
            return self.getTypedRuleContext(kismetParser.NameContext,0)


        def locWildCard(self):
            return self.getTypedRuleContext(kismetParser.LocWildCardContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_loc

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLoc" ):
                listener.enterLoc(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLoc" ):
                listener.exitLoc(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLoc" ):
                return visitor.visitLoc(self)
            else:
                return visitor.visitChildren(self)




    def loc(self):

        localctx = kismetParser.LocContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_loc)
        self._la = 0 # Token type
        try:
            self.state = 455
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [kismetParser.VAR]:
                self.enterOuterAlt(localctx, 1)
                self.state = 408
                self.var()
                self.state = 409
                self.match(kismetParser.T__8)
                self.state = 410
                self.arg()
                self.state = 415
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==kismetParser.T__9:
                    self.state = 411
                    self.match(kismetParser.T__9)
                    self.state = 412
                    self.arg()
                    self.state = 417
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 418
                self.match(kismetParser.T__10)
                pass
            elif token in [kismetParser.NAME]:
                self.enterOuterAlt(localctx, 2)
                self.state = 420
                self.name()
                self.state = 421
                self.match(kismetParser.T__8)
                self.state = 422
                self.arg()
                self.state = 427
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==kismetParser.T__9:
                    self.state = 423
                    self.match(kismetParser.T__9)
                    self.state = 424
                    self.arg()
                    self.state = 429
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 430
                self.match(kismetParser.T__10)
                pass
            elif token in [kismetParser.T__3]:
                self.enterOuterAlt(localctx, 3)
                self.state = 432
                self.locWildCard()
                self.state = 433
                self.match(kismetParser.T__8)
                self.state = 434
                self.arg()
                self.state = 439
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==kismetParser.T__9:
                    self.state = 435
                    self.match(kismetParser.T__9)
                    self.state = 436
                    self.arg()
                    self.state = 441
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 442
                self.match(kismetParser.T__10)
                pass
            elif token in [kismetParser.T__8]:
                self.enterOuterAlt(localctx, 4)
                self.state = 444
                self.match(kismetParser.T__8)
                self.state = 445
                self.arg()
                self.state = 450
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==kismetParser.T__9:
                    self.state = 446
                    self.match(kismetParser.T__9)
                    self.state = 447
                    self.arg()
                    self.state = 452
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 453
                self.match(kismetParser.T__10)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LocWildCardContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return kismetParser.RULE_locWildCard

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLocWildCard" ):
                listener.enterLocWildCard(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLocWildCard" ):
                listener.exitLocWildCard(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLocWildCard" ):
                return visitor.visitLocWildCard(self)
            else:
                return visitor.visitChildren(self)




    def locWildCard(self):

        localctx = kismetParser.LocWildCardContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_locWildCard)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 457
            self.match(kismetParser.T__3)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Action_itemContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def tags(self):
            return self.getTypedRuleContext(kismetParser.TagsContext,0)


        def comparison(self):
            return self.getTypedRuleContext(kismetParser.ComparisonContext,0)


        def action_location(self):
            return self.getTypedRuleContext(kismetParser.Action_locationContext,0)


        def add(self):
            return self.getTypedRuleContext(kismetParser.AddContext,0)


        def visibility(self):
            return self.getTypedRuleContext(kismetParser.VisibilityContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_action_item

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAction_item" ):
                listener.enterAction_item(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAction_item" ):
                listener.exitAction_item(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAction_item" ):
                return visitor.visitAction_item(self)
            else:
                return visitor.visitChildren(self)




    def action_item(self):

        localctx = kismetParser.Action_itemContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_action_item)
        try:
            self.state = 464
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [kismetParser.T__31]:
                self.enterOuterAlt(localctx, 1)
                self.state = 459
                self.tags()
                pass
            elif token in [kismetParser.T__32]:
                self.enterOuterAlt(localctx, 2)
                self.state = 460
                self.comparison()
                pass
            elif token in [kismetParser.T__24]:
                self.enterOuterAlt(localctx, 3)
                self.state = 461
                self.action_location()
                pass
            elif token in [kismetParser.T__23]:
                self.enterOuterAlt(localctx, 4)
                self.state = 462
                self.add()
                pass
            elif token in [kismetParser.T__17]:
                self.enterOuterAlt(localctx, 5)
                self.state = 463
                self.visibility()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RoleContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def name(self):
            return self.getTypedRuleContext(kismetParser.NameContext,0)


        def arg(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.ArgContext)
            else:
                return self.getTypedRuleContext(kismetParser.ArgContext,i)


        def tags(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.TagsContext)
            else:
                return self.getTypedRuleContext(kismetParser.TagsContext,i)


        def comparison(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.ComparisonContext)
            else:
                return self.getTypedRuleContext(kismetParser.ComparisonContext,i)


        def extension(self):
            return self.getTypedRuleContext(kismetParser.ExtensionContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_role

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRole" ):
                listener.enterRole(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRole" ):
                listener.exitRole(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRole" ):
                return visitor.visitRole(self)
            else:
                return visitor.visitChildren(self)




    def role(self):

        localctx = kismetParser.RoleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_role)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 466
            self.match(kismetParser.T__25)
            self.state = 467
            self.name()
            self.state = 468
            self.match(kismetParser.T__8)
            self.state = 469
            self.arg()
            self.state = 474
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__9:
                self.state = 470
                self.match(kismetParser.T__9)
                self.state = 471
                self.arg()
                self.state = 476
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 477
            self.match(kismetParser.T__10)
            self.state = 479
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==kismetParser.T__26:
                self.state = 478
                self.extension()


            self.state = 481
            self.match(kismetParser.T__2)
            self.state = 484
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [kismetParser.T__31]:
                self.state = 482
                self.tags()
                pass
            elif token in [kismetParser.T__32]:
                self.state = 483
                self.comparison()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 493
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__20:
                self.state = 486
                self.match(kismetParser.T__20)
                self.state = 489
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [kismetParser.T__31]:
                    self.state = 487
                    self.tags()
                    pass
                elif token in [kismetParser.T__32]:
                    self.state = 488
                    self.comparison()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 495
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 496
            self.match(kismetParser.T__1)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExtensionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def arg(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.ArgContext)
            else:
                return self.getTypedRuleContext(kismetParser.ArgContext,i)


        def cast_name(self):
            return self.getTypedRuleContext(kismetParser.Cast_nameContext,0)


        def name(self):
            return self.getTypedRuleContext(kismetParser.NameContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_extension

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExtension" ):
                listener.enterExtension(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExtension" ):
                listener.exitExtension(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExtension" ):
                return visitor.visitExtension(self)
            else:
                return visitor.visitChildren(self)




    def extension(self):

        localctx = kismetParser.ExtensionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_extension)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 498
            self.match(kismetParser.T__26)
            self.state = 501
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [kismetParser.T__27]:
                self.state = 499
                self.cast_name()
                pass
            elif token in [kismetParser.NAME]:
                self.state = 500
                self.name()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 503
            self.match(kismetParser.T__8)
            self.state = 504
            self.arg()
            self.state = 509
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__9:
                self.state = 505
                self.match(kismetParser.T__9)
                self.state = 506
                self.arg()
                self.state = 511
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 512
            self.match(kismetParser.T__10)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Cast_nameContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def name(self):
            return self.getTypedRuleContext(kismetParser.NameContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_cast_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCast_name" ):
                listener.enterCast_name(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCast_name" ):
                listener.exitCast_name(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCast_name" ):
                return visitor.visitCast_name(self)
            else:
                return visitor.visitChildren(self)




    def cast_name(self):

        localctx = kismetParser.Cast_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_cast_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 514
            self.match(kismetParser.T__27)
            self.state = 515
            self.name()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ArgContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def var(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.VarContext)
            else:
                return self.getTypedRuleContext(kismetParser.VarContext,i)


        def arg_type(self):
            return self.getTypedRuleContext(kismetParser.Arg_typeContext,0)


        def sub(self):
            return self.getTypedRuleContext(kismetParser.SubContext,0)


        def name(self):
            return self.getTypedRuleContext(kismetParser.NameContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_arg

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArg" ):
                listener.enterArg(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArg" ):
                listener.exitArg(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitArg" ):
                return visitor.visitArg(self)
            else:
                return visitor.visitChildren(self)




    def arg(self):

        localctx = kismetParser.ArgContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_arg)
        self._la = 0 # Token type
        try:
            self.state = 535
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,57,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 518
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << kismetParser.T__5) | (1 << kismetParser.T__18) | (1 << kismetParser.T__28) | (1 << kismetParser.T__29) | (1 << kismetParser.T__30))) != 0):
                    self.state = 517
                    self.arg_type()


                self.state = 520
                self.var()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 522
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << kismetParser.T__5) | (1 << kismetParser.T__18) | (1 << kismetParser.T__28) | (1 << kismetParser.T__29) | (1 << kismetParser.T__30))) != 0):
                    self.state = 521
                    self.arg_type()


                self.state = 524
                self.var()
                self.state = 525
                self.sub()
                self.state = 526
                self.name()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 529
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << kismetParser.T__5) | (1 << kismetParser.T__18) | (1 << kismetParser.T__28) | (1 << kismetParser.T__29) | (1 << kismetParser.T__30))) != 0):
                    self.state = 528
                    self.arg_type()


                self.state = 531
                self.var()
                self.state = 532
                self.sub()
                self.state = 533
                self.var()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SubContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return kismetParser.RULE_sub

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSub" ):
                listener.enterSub(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSub" ):
                listener.exitSub(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSub" ):
                return visitor.visitSub(self)
            else:
                return visitor.visitChildren(self)




    def sub(self):

        localctx = kismetParser.SubContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_sub)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 537
            _la = self._input.LA(1)
            if not(_la==kismetParser.T__1 or _la==kismetParser.T__2):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Arg_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return kismetParser.RULE_arg_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArg_type" ):
                listener.enterArg_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArg_type" ):
                listener.exitArg_type(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitArg_type" ):
                return visitor.visitArg_type(self)
            else:
                return visitor.visitChildren(self)




    def arg_type(self):

        localctx = kismetParser.Arg_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_arg_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 539
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << kismetParser.T__5) | (1 << kismetParser.T__18) | (1 << kismetParser.T__28) | (1 << kismetParser.T__29) | (1 << kismetParser.T__30))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TagsContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.NameContext)
            else:
                return self.getTypedRuleContext(kismetParser.NameContext,i)


        def getRuleIndex(self):
            return kismetParser.RULE_tags

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTags" ):
                listener.enterTags(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTags" ):
                listener.exitTags(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTags" ):
                return visitor.visitTags(self)
            else:
                return visitor.visitChildren(self)




    def tags(self):

        localctx = kismetParser.TagsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_tags)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 541
            self.match(kismetParser.T__31)
            self.state = 542
            self.match(kismetParser.T__2)
            self.state = 543
            self.name()
            self.state = 548
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__9:
                self.state = 544
                self.match(kismetParser.T__9)
                self.state = 545
                self.name()
                self.state = 550
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ComparisonContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def condition(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.ConditionContext)
            else:
                return self.getTypedRuleContext(kismetParser.ConditionContext,i)


        def getRuleIndex(self):
            return kismetParser.RULE_comparison

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterComparison" ):
                listener.enterComparison(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitComparison" ):
                listener.exitComparison(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitComparison" ):
                return visitor.visitComparison(self)
            else:
                return visitor.visitChildren(self)




    def comparison(self):

        localctx = kismetParser.ComparisonContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_comparison)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 551
            self.match(kismetParser.T__32)
            self.state = 552
            self.condition()
            self.state = 557
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__9:
                self.state = 553
                self.match(kismetParser.T__9)
                self.state = 554
                self.condition()
                self.state = 559
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class KnowledgeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return kismetParser.RULE_knowledge

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterKnowledge" ):
                listener.enterKnowledge(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitKnowledge" ):
                listener.exitKnowledge(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitKnowledge" ):
                return visitor.visitKnowledge(self)
            else:
                return visitor.visitChildren(self)




    def knowledge(self):

        localctx = kismetParser.KnowledgeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_knowledge)
        try:
            self.state = 600
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,60,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 560
                self.match(kismetParser.T__33)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 561
                self.match(kismetParser.T__34)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 562
                self.match(kismetParser.T__35)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 563
                self.match(kismetParser.T__36)
                self.state = 564
                self.match(kismetParser.T__37)
                self.state = 565
                self.match(kismetParser.T__38)
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 566
                self.match(kismetParser.T__39)
                self.state = 567
                self.match(kismetParser.T__38)
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 568
                self.match(kismetParser.T__40)
                self.state = 569
                self.match(kismetParser.T__38)
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 570
                self.match(kismetParser.T__36)
                self.state = 571
                self.match(kismetParser.T__37)
                self.state = 572
                self.match(kismetParser.T__41)
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 573
                self.match(kismetParser.T__39)
                self.state = 574
                self.match(kismetParser.T__41)
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 575
                self.match(kismetParser.T__40)
                self.state = 576
                self.match(kismetParser.T__41)
                pass

            elif la_ == 10:
                self.enterOuterAlt(localctx, 10)
                self.state = 577
                self.match(kismetParser.T__36)
                self.state = 578
                self.match(kismetParser.T__37)
                self.state = 579
                self.match(kismetParser.T__42)
                pass

            elif la_ == 11:
                self.enterOuterAlt(localctx, 11)
                self.state = 580
                self.match(kismetParser.T__39)
                self.state = 581
                self.match(kismetParser.T__42)
                pass

            elif la_ == 12:
                self.enterOuterAlt(localctx, 12)
                self.state = 582
                self.match(kismetParser.T__40)
                self.state = 583
                self.match(kismetParser.T__42)
                pass

            elif la_ == 13:
                self.enterOuterAlt(localctx, 13)
                self.state = 584
                self.match(kismetParser.T__36)
                self.state = 585
                self.match(kismetParser.T__37)
                self.state = 586
                self.match(kismetParser.T__43)
                pass

            elif la_ == 14:
                self.enterOuterAlt(localctx, 14)
                self.state = 587
                self.match(kismetParser.T__39)
                self.state = 588
                self.match(kismetParser.T__43)
                pass

            elif la_ == 15:
                self.enterOuterAlt(localctx, 15)
                self.state = 589
                self.match(kismetParser.T__40)
                self.state = 590
                self.match(kismetParser.T__43)
                pass

            elif la_ == 16:
                self.enterOuterAlt(localctx, 16)
                self.state = 591
                self.match(kismetParser.T__44)
                pass

            elif la_ == 17:
                self.enterOuterAlt(localctx, 17)
                self.state = 592
                self.match(kismetParser.T__45)
                pass

            elif la_ == 18:
                self.enterOuterAlt(localctx, 18)
                self.state = 593
                self.match(kismetParser.T__46)
                pass

            elif la_ == 19:
                self.enterOuterAlt(localctx, 19)
                self.state = 594
                self.match(kismetParser.T__47)
                pass

            elif la_ == 20:
                self.enterOuterAlt(localctx, 20)
                self.state = 595
                self.match(kismetParser.T__48)
                pass

            elif la_ == 21:
                self.enterOuterAlt(localctx, 21)
                self.state = 596
                self.match(kismetParser.T__49)
                pass

            elif la_ == 22:
                self.enterOuterAlt(localctx, 22)
                self.state = 597
                self.match(kismetParser.T__50)
                pass

            elif la_ == 23:
                self.enterOuterAlt(localctx, 23)
                self.state = 598
                self.match(kismetParser.T__36)
                pass

            elif la_ == 24:
                self.enterOuterAlt(localctx, 24)
                self.state = 599
                self.match(kismetParser.T__51)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConditionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def cond10(self):
            return self.getTypedRuleContext(kismetParser.Cond10Context,0)


        def cond9(self):
            return self.getTypedRuleContext(kismetParser.Cond9Context,0)


        def cond8(self):
            return self.getTypedRuleContext(kismetParser.Cond8Context,0)


        def cond3(self):
            return self.getTypedRuleContext(kismetParser.Cond3Context,0)


        def cond1(self):
            return self.getTypedRuleContext(kismetParser.Cond1Context,0)


        def cond4(self):
            return self.getTypedRuleContext(kismetParser.Cond4Context,0)


        def cond5(self):
            return self.getTypedRuleContext(kismetParser.Cond5Context,0)


        def cond6(self):
            return self.getTypedRuleContext(kismetParser.Cond6Context,0)


        def cond7(self):
            return self.getTypedRuleContext(kismetParser.Cond7Context,0)


        def condpattern(self):
            return self.getTypedRuleContext(kismetParser.CondpatternContext,0)


        def condTimeHistory(self):
            return self.getTypedRuleContext(kismetParser.CondTimeHistoryContext,0)


        def condTimePersonal(self):
            return self.getTypedRuleContext(kismetParser.CondTimePersonalContext,0)


        def condTimePersonalAssignment(self):
            return self.getTypedRuleContext(kismetParser.CondTimePersonalAssignmentContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_condition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCondition" ):
                listener.enterCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCondition" ):
                listener.exitCondition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCondition" ):
                return visitor.visitCondition(self)
            else:
                return visitor.visitChildren(self)




    def condition(self):

        localctx = kismetParser.ConditionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_condition)
        try:
            self.state = 615
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,61,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 602
                self.cond10()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 603
                self.cond9()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 604
                self.cond8()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 605
                self.cond3()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 606
                self.cond1()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 607
                self.cond4()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 608
                self.cond5()
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 609
                self.cond6()
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 610
                self.cond7()
                pass

            elif la_ == 10:
                self.enterOuterAlt(localctx, 10)
                self.state = 611
                self.condpattern()
                pass

            elif la_ == 11:
                self.enterOuterAlt(localctx, 11)
                self.state = 612
                self.condTimeHistory()
                pass

            elif la_ == 12:
                self.enterOuterAlt(localctx, 12)
                self.state = 613
                self.condTimePersonal()
                pass

            elif la_ == 13:
                self.enterOuterAlt(localctx, 13)
                self.state = 614
                self.condTimePersonalAssignment()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Cond8Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def arg(self):
            return self.getTypedRuleContext(kismetParser.ArgContext,0)


        def name(self):
            return self.getTypedRuleContext(kismetParser.NameContext,0)


        def operator(self):
            return self.getTypedRuleContext(kismetParser.OperatorContext,0)


        def num(self):
            return self.getTypedRuleContext(kismetParser.NumContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_cond8

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCond8" ):
                listener.enterCond8(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCond8" ):
                listener.exitCond8(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCond8" ):
                return visitor.visitCond8(self)
            else:
                return visitor.visitChildren(self)




    def cond8(self):

        localctx = kismetParser.Cond8Context(self, self._ctx, self.state)
        self.enterRule(localctx, 78, self.RULE_cond8)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 617
            self.arg()
            self.state = 618
            _la = self._input.LA(1)
            if not(_la==kismetParser.T__52 or _la==kismetParser.T__53):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 619
            self.name()
            self.state = 620
            self.operator()
            self.state = 621
            self.num()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Cond3Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def arg(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.ArgContext)
            else:
                return self.getTypedRuleContext(kismetParser.ArgContext,i)


        def knowledge(self):
            return self.getTypedRuleContext(kismetParser.KnowledgeContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_cond3

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCond3" ):
                listener.enterCond3(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCond3" ):
                listener.exitCond3(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCond3" ):
                return visitor.visitCond3(self)
            else:
                return visitor.visitChildren(self)




    def cond3(self):

        localctx = kismetParser.Cond3Context(self, self._ctx, self.state)
        self.enterRule(localctx, 80, self.RULE_cond3)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 623
            self.arg()
            self.state = 624
            self.knowledge()
            self.state = 625
            self.arg()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Cond1Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def arg(self):
            return self.getTypedRuleContext(kismetParser.ArgContext,0)


        def tag_compare(self):
            return self.getTypedRuleContext(kismetParser.Tag_compareContext,0)


        def name(self):
            return self.getTypedRuleContext(kismetParser.NameContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_cond1

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCond1" ):
                listener.enterCond1(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCond1" ):
                listener.exitCond1(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCond1" ):
                return visitor.visitCond1(self)
            else:
                return visitor.visitChildren(self)




    def cond1(self):

        localctx = kismetParser.Cond1Context(self, self._ctx, self.state)
        self.enterRule(localctx, 82, self.RULE_cond1)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 627
            self.arg()
            self.state = 628
            self.tag_compare()
            self.state = 629
            self.name()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Cond4Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def arg(self):
            return self.getTypedRuleContext(kismetParser.ArgContext,0)


        def name(self):
            return self.getTypedRuleContext(kismetParser.NameContext,0)


        def comparator(self):
            return self.getTypedRuleContext(kismetParser.ComparatorContext,0)


        def num(self):
            return self.getTypedRuleContext(kismetParser.NumContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_cond4

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCond4" ):
                listener.enterCond4(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCond4" ):
                listener.exitCond4(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCond4" ):
                return visitor.visitCond4(self)
            else:
                return visitor.visitChildren(self)




    def cond4(self):

        localctx = kismetParser.Cond4Context(self, self._ctx, self.state)
        self.enterRule(localctx, 84, self.RULE_cond4)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 631
            self.arg()
            self.state = 632
            _la = self._input.LA(1)
            if not(_la==kismetParser.T__52 or _la==kismetParser.T__53):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 633
            self.name()
            self.state = 634
            self.comparator()
            self.state = 635
            self.num()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Cond9Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def arg(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.ArgContext)
            else:
                return self.getTypedRuleContext(kismetParser.ArgContext,i)


        def name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.NameContext)
            else:
                return self.getTypedRuleContext(kismetParser.NameContext,i)


        def comparator(self):
            return self.getTypedRuleContext(kismetParser.ComparatorContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_cond9

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCond9" ):
                listener.enterCond9(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCond9" ):
                listener.exitCond9(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCond9" ):
                return visitor.visitCond9(self)
            else:
                return visitor.visitChildren(self)




    def cond9(self):

        localctx = kismetParser.Cond9Context(self, self._ctx, self.state)
        self.enterRule(localctx, 86, self.RULE_cond9)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 637
            self.arg()
            self.state = 638
            _la = self._input.LA(1)
            if not(_la==kismetParser.T__52 or _la==kismetParser.T__53):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 639
            self.name()
            self.state = 640
            self.comparator()
            self.state = 641
            self.arg()
            self.state = 642
            _la = self._input.LA(1)
            if not(_la==kismetParser.T__52 or _la==kismetParser.T__53):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 643
            self.name()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Cond10Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def arg(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.ArgContext)
            else:
                return self.getTypedRuleContext(kismetParser.ArgContext,i)


        def name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.NameContext)
            else:
                return self.getTypedRuleContext(kismetParser.NameContext,i)


        def comparator(self):
            return self.getTypedRuleContext(kismetParser.ComparatorContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_cond10

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCond10" ):
                listener.enterCond10(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCond10" ):
                listener.exitCond10(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCond10" ):
                return visitor.visitCond10(self)
            else:
                return visitor.visitChildren(self)




    def cond10(self):

        localctx = kismetParser.Cond10Context(self, self._ctx, self.state)
        self.enterRule(localctx, 88, self.RULE_cond10)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 645
            self.arg()
            self.state = 646
            self.name()
            self.state = 647
            self.arg()
            self.state = 648
            self.comparator()
            self.state = 649
            self.arg()
            self.state = 650
            self.name()
            self.state = 651
            self.arg()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InversionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return kismetParser.RULE_inversion

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInversion" ):
                listener.enterInversion(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInversion" ):
                listener.exitInversion(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInversion" ):
                return visitor.visitInversion(self)
            else:
                return visitor.visitChildren(self)




    def inversion(self):

        localctx = kismetParser.InversionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 90, self.RULE_inversion)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 653
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << kismetParser.T__54) | (1 << kismetParser.T__55) | (1 << kismetParser.T__56) | (1 << kismetParser.T__57) | (1 << kismetParser.T__58) | (1 << kismetParser.T__59))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Cond5Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def arg(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.ArgContext)
            else:
                return self.getTypedRuleContext(kismetParser.ArgContext,i)


        def name(self):
            return self.getTypedRuleContext(kismetParser.NameContext,0)


        def inversion(self):
            return self.getTypedRuleContext(kismetParser.InversionContext,0)


        def operator(self):
            return self.getTypedRuleContext(kismetParser.OperatorContext,0)


        def num(self):
            return self.getTypedRuleContext(kismetParser.NumContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_cond5

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCond5" ):
                listener.enterCond5(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCond5" ):
                listener.exitCond5(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCond5" ):
                return visitor.visitCond5(self)
            else:
                return visitor.visitChildren(self)




    def cond5(self):

        localctx = kismetParser.Cond5Context(self, self._ctx, self.state)
        self.enterRule(localctx, 92, self.RULE_cond5)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 655
            self.arg()
            self.state = 656
            self.match(kismetParser.T__60)
            self.state = 657
            self.arg()
            self.state = 659
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << kismetParser.T__54) | (1 << kismetParser.T__55) | (1 << kismetParser.T__56) | (1 << kismetParser.T__57) | (1 << kismetParser.T__58) | (1 << kismetParser.T__59))) != 0):
                self.state = 658
                self.inversion()


            self.state = 661
            self.name()
            self.state = 665
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [kismetParser.T__61]:
                self.state = 662
                self.match(kismetParser.T__61)
                self.state = 663
                self.match(kismetParser.T__62)
                pass
            elif token in [kismetParser.T__63]:
                self.state = 664
                self.match(kismetParser.T__63)
                pass
            else:
                raise NoViableAltException(self)

            self.state = 670
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 91)) & ~0x3f) == 0 and ((1 << (_la - 91)) & ((1 << (kismetParser.MINUS - 91)) | (1 << (kismetParser.PLUS - 91)) | (1 << (kismetParser.EQUALS - 91)))) != 0):
                self.state = 667
                self.operator()
                self.state = 668
                self.num()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Cond6Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def arg(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.ArgContext)
            else:
                return self.getTypedRuleContext(kismetParser.ArgContext,i)


        def name(self):
            return self.getTypedRuleContext(kismetParser.NameContext,0)


        def inversion(self):
            return self.getTypedRuleContext(kismetParser.InversionContext,0)


        def operator(self):
            return self.getTypedRuleContext(kismetParser.OperatorContext,0)


        def num(self):
            return self.getTypedRuleContext(kismetParser.NumContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_cond6

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCond6" ):
                listener.enterCond6(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCond6" ):
                listener.exitCond6(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCond6" ):
                return visitor.visitCond6(self)
            else:
                return visitor.visitChildren(self)




    def cond6(self):

        localctx = kismetParser.Cond6Context(self, self._ctx, self.state)
        self.enterRule(localctx, 94, self.RULE_cond6)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 672
            self.arg()
            self.state = 674
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << kismetParser.T__54) | (1 << kismetParser.T__55) | (1 << kismetParser.T__56) | (1 << kismetParser.T__57) | (1 << kismetParser.T__58) | (1 << kismetParser.T__59))) != 0):
                self.state = 673
                self.inversion()


            self.state = 679
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((((_la - 65)) & ~0x3f) == 0 and ((1 << (_la - 65)) & ((1 << (kismetParser.T__64 - 65)) | (1 << (kismetParser.T__65 - 65)) | (1 << (kismetParser.T__66 - 65)))) != 0):
                self.state = 676
                _la = self._input.LA(1)
                if not(((((_la - 65)) & ~0x3f) == 0 and ((1 << (_la - 65)) & ((1 << (kismetParser.T__64 - 65)) | (1 << (kismetParser.T__65 - 65)) | (1 << (kismetParser.T__66 - 65)))) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 681
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 682
            self.name()
            self.state = 686
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((((_la - 68)) & ~0x3f) == 0 and ((1 << (_la - 68)) & ((1 << (kismetParser.T__67 - 68)) | (1 << (kismetParser.T__68 - 68)) | (1 << (kismetParser.T__69 - 68)) | (1 << (kismetParser.T__70 - 68)))) != 0):
                self.state = 683
                _la = self._input.LA(1)
                if not(((((_la - 68)) & ~0x3f) == 0 and ((1 << (_la - 68)) & ((1 << (kismetParser.T__67 - 68)) | (1 << (kismetParser.T__68 - 68)) | (1 << (kismetParser.T__69 - 68)) | (1 << (kismetParser.T__70 - 68)))) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 688
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 689
            self.arg()
            self.state = 693
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 91)) & ~0x3f) == 0 and ((1 << (_la - 91)) & ((1 << (kismetParser.MINUS - 91)) | (1 << (kismetParser.PLUS - 91)) | (1 << (kismetParser.EQUALS - 91)))) != 0):
                self.state = 690
                self.operator()
                self.state = 691
                self.num()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Cond7Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def arg(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.ArgContext)
            else:
                return self.getTypedRuleContext(kismetParser.ArgContext,i)


        def name(self):
            return self.getTypedRuleContext(kismetParser.NameContext,0)


        def comparator(self):
            return self.getTypedRuleContext(kismetParser.ComparatorContext,0)


        def num(self):
            return self.getTypedRuleContext(kismetParser.NumContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_cond7

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCond7" ):
                listener.enterCond7(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCond7" ):
                listener.exitCond7(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCond7" ):
                return visitor.visitCond7(self)
            else:
                return visitor.visitChildren(self)




    def cond7(self):

        localctx = kismetParser.Cond7Context(self, self._ctx, self.state)
        self.enterRule(localctx, 96, self.RULE_cond7)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 695
            self.arg()
            self.state = 696
            self.name()
            self.state = 697
            self.arg()
            self.state = 698
            self.comparator()
            self.state = 699
            self.num()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CondpatternContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def name(self):
            return self.getTypedRuleContext(kismetParser.NameContext,0)


        def arg(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.ArgContext)
            else:
                return self.getTypedRuleContext(kismetParser.ArgContext,i)


        def getRuleIndex(self):
            return kismetParser.RULE_condpattern

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCondpattern" ):
                listener.enterCondpattern(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCondpattern" ):
                listener.exitCondpattern(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCondpattern" ):
                return visitor.visitCondpattern(self)
            else:
                return visitor.visitChildren(self)




    def condpattern(self):

        localctx = kismetParser.CondpatternContext(self, self._ctx, self.state)
        self.enterRule(localctx, 98, self.RULE_condpattern)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 701
            self.match(kismetParser.T__7)
            self.state = 702
            self.match(kismetParser.T__8)
            self.state = 703
            self.name()
            self.state = 708
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__9:
                self.state = 704
                self.match(kismetParser.T__9)
                self.state = 705
                self.arg()
                self.state = 710
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 711
            self.match(kismetParser.T__10)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CondTimeHistoryContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def comparator(self):
            return self.getTypedRuleContext(kismetParser.ComparatorContext,0)


        def num(self):
            return self.getTypedRuleContext(kismetParser.NumContext,0)


        def name(self):
            return self.getTypedRuleContext(kismetParser.NameContext,0)


        def arg(self):
            return self.getTypedRuleContext(kismetParser.ArgContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_condTimeHistory

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCondTimeHistory" ):
                listener.enterCondTimeHistory(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCondTimeHistory" ):
                listener.exitCondTimeHistory(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCondTimeHistory" ):
                return visitor.visitCondTimeHistory(self)
            else:
                return visitor.visitChildren(self)




    def condTimeHistory(self):

        localctx = kismetParser.CondTimeHistoryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 100, self.RULE_condTimeHistory)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 713
            self.match(kismetParser.T__71)
            self.state = 715
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==kismetParser.T__66:
                self.state = 714
                self.match(kismetParser.T__66)


            self.state = 717
            self.comparator()
            self.state = 718
            self.num()
            self.state = 719
            self.name()
            self.state = 720
            self.match(kismetParser.T__72)
            self.state = 721
            self.arg()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CondTimePersonalContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def comparator(self):
            return self.getTypedRuleContext(kismetParser.ComparatorContext,0)


        def num(self):
            return self.getTypedRuleContext(kismetParser.NumContext,0)


        def name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.NameContext)
            else:
                return self.getTypedRuleContext(kismetParser.NameContext,i)


        def arg(self):
            return self.getTypedRuleContext(kismetParser.ArgContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_condTimePersonal

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCondTimePersonal" ):
                listener.enterCondTimePersonal(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCondTimePersonal" ):
                listener.exitCondTimePersonal(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCondTimePersonal" ):
                return visitor.visitCondTimePersonal(self)
            else:
                return visitor.visitChildren(self)




    def condTimePersonal(self):

        localctx = kismetParser.CondTimePersonalContext(self, self._ctx, self.state)
        self.enterRule(localctx, 102, self.RULE_condTimePersonal)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 723
            self.match(kismetParser.T__71)
            self.state = 725
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==kismetParser.T__66:
                self.state = 724
                self.match(kismetParser.T__66)


            self.state = 727
            self.comparator()
            self.state = 728
            self.num()
            self.state = 729
            self.name()
            self.state = 730
            self.match(kismetParser.T__72)
            self.state = 731
            self.arg()
            self.state = 732
            self.match(kismetParser.T__52)
            self.state = 733
            self.name()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CondTimePersonalAssignmentContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def arg(self):
            return self.getTypedRuleContext(kismetParser.ArgContext,0)


        def name(self):
            return self.getTypedRuleContext(kismetParser.NameContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_condTimePersonalAssignment

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCondTimePersonalAssignment" ):
                listener.enterCondTimePersonalAssignment(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCondTimePersonalAssignment" ):
                listener.exitCondTimePersonalAssignment(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCondTimePersonalAssignment" ):
                return visitor.visitCondTimePersonalAssignment(self)
            else:
                return visitor.visitChildren(self)




    def condTimePersonalAssignment(self):

        localctx = kismetParser.CondTimePersonalAssignmentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 104, self.RULE_condTimePersonalAssignment)
        try:
            self.state = 747
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [kismetParser.T__71]:
                self.enterOuterAlt(localctx, 1)
                self.state = 735
                self.match(kismetParser.T__71)
                self.state = 736
                self.match(kismetParser.T__66)
                self.state = 737
                self.arg()
                self.state = 738
                self.match(kismetParser.T__52)
                self.state = 739
                self.name()
                pass
            elif token in [kismetParser.T__5, kismetParser.T__18, kismetParser.T__28, kismetParser.T__29, kismetParser.T__30, kismetParser.VAR]:
                self.enterOuterAlt(localctx, 2)
                self.state = 741
                self.arg()
                self.state = 742
                self.match(kismetParser.T__52)
                self.state = 743
                self.name()
                self.state = 744
                self.match(kismetParser.T__66)
                self.state = 745
                self.match(kismetParser.T__71)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Tag_compareContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return kismetParser.RULE_tag_compare

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTag_compare" ):
                listener.enterTag_compare(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTag_compare" ):
                listener.exitTag_compare(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTag_compare" ):
                return visitor.visitTag_compare(self)
            else:
                return visitor.visitChildren(self)




    def tag_compare(self):

        localctx = kismetParser.Tag_compareContext(self, self._ctx, self.state)
        self.enterRule(localctx, 106, self.RULE_tag_compare)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 749
            _la = self._input.LA(1)
            if not(((((_la - 67)) & ~0x3f) == 0 and ((1 << (_la - 67)) & ((1 << (kismetParser.T__66 - 67)) | (1 << (kismetParser.T__73 - 67)) | (1 << (kismetParser.T__74 - 67)) | (1 << (kismetParser.T__75 - 67)) | (1 << (kismetParser.T__76 - 67)) | (1 << (kismetParser.T__77 - 67)) | (1 << (kismetParser.T__78 - 67)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OperatorContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MINUS(self):
            return self.getToken(kismetParser.MINUS, 0)

        def PLUS(self):
            return self.getToken(kismetParser.PLUS, 0)

        def EQUALS(self):
            return self.getToken(kismetParser.EQUALS, 0)

        def getRuleIndex(self):
            return kismetParser.RULE_operator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOperator" ):
                listener.enterOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOperator" ):
                listener.exitOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOperator" ):
                return visitor.visitOperator(self)
            else:
                return visitor.visitChildren(self)




    def operator(self):

        localctx = kismetParser.OperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 108, self.RULE_operator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 751
            _la = self._input.LA(1)
            if not(((((_la - 91)) & ~0x3f) == 0 and ((1 << (_la - 91)) & ((1 << (kismetParser.MINUS - 91)) | (1 << (kismetParser.PLUS - 91)) | (1 << (kismetParser.EQUALS - 91)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LocationContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def name(self):
            return self.getTypedRuleContext(kismetParser.NameContext,0)


        def supports(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.SupportsContext)
            else:
                return self.getTypedRuleContext(kismetParser.SupportsContext,i)


        def each_turn(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.Each_turnContext)
            else:
                return self.getTypedRuleContext(kismetParser.Each_turnContext,i)


        def tags(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.TagsContext)
            else:
                return self.getTypedRuleContext(kismetParser.TagsContext,i)


        def getRuleIndex(self):
            return kismetParser.RULE_location

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLocation" ):
                listener.enterLocation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLocation" ):
                listener.exitLocation(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLocation" ):
                return visitor.visitLocation(self)
            else:
                return visitor.visitChildren(self)




    def location(self):

        localctx = kismetParser.LocationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 110, self.RULE_location)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 753
            self.match(kismetParser.T__79)
            self.state = 754
            self.name()
            self.state = 755
            self.match(kismetParser.T__2)
            self.state = 772
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 32)) & ~0x3f) == 0 and ((1 << (_la - 32)) & ((1 << (kismetParser.T__31 - 32)) | (1 << (kismetParser.T__80 - 32)) | (1 << (kismetParser.T__81 - 32)))) != 0):
                self.state = 759
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [kismetParser.T__81]:
                    self.state = 756
                    self.supports()
                    pass
                elif token in [kismetParser.T__80]:
                    self.state = 757
                    self.each_turn()
                    pass
                elif token in [kismetParser.T__31]:
                    self.state = 758
                    self.tags()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 769
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==kismetParser.T__20:
                    self.state = 761
                    self.match(kismetParser.T__20)
                    self.state = 765
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [kismetParser.T__81]:
                        self.state = 762
                        self.supports()
                        pass
                    elif token in [kismetParser.T__80]:
                        self.state = 763
                        self.each_turn()
                        pass
                    elif token in [kismetParser.T__31]:
                        self.state = 764
                        self.tags()
                        pass
                    else:
                        raise NoViableAltException(self)

                    self.state = 771
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



            self.state = 774
            self.match(kismetParser.T__1)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Each_turnContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def cast(self):
            return self.getTypedRuleContext(kismetParser.CastContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_each_turn

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEach_turn" ):
                listener.enterEach_turn(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEach_turn" ):
                listener.exitEach_turn(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEach_turn" ):
                return visitor.visitEach_turn(self)
            else:
                return visitor.visitChildren(self)




    def each_turn(self):

        localctx = kismetParser.Each_turnContext(self, self._ctx, self.state)
        self.enterRule(localctx, 112, self.RULE_each_turn)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 776
            self.match(kismetParser.T__80)
            self.state = 777
            self.match(kismetParser.T__2)
            self.state = 778
            self.cast()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CastContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.NameContext)
            else:
                return self.getTypedRuleContext(kismetParser.NameContext,i)


        def getRuleIndex(self):
            return kismetParser.RULE_cast

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCast" ):
                listener.enterCast(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCast" ):
                listener.exitCast(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCast" ):
                return visitor.visitCast(self)
            else:
                return visitor.visitChildren(self)




    def cast(self):

        localctx = kismetParser.CastContext(self, self._ctx, self.state)
        self.enterRule(localctx, 114, self.RULE_cast)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 780
            self.match(kismetParser.T__27)
            self.state = 781
            self.name()
            self.state = 786
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__9:
                self.state = 782
                self.match(kismetParser.T__9)
                self.state = 783
                self.name()
                self.state = 788
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Random_textContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RANDOM_TEXT(self):
            return self.getToken(kismetParser.RANDOM_TEXT, 0)

        def getRuleIndex(self):
            return kismetParser.RULE_random_text

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRandom_text" ):
                listener.enterRandom_text(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRandom_text" ):
                listener.exitRandom_text(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRandom_text" ):
                return visitor.visitRandom_text(self)
            else:
                return visitor.visitChildren(self)




    def random_text(self):

        localctx = kismetParser.Random_textContext(self, self._ctx, self.state)
        self.enterRule(localctx, 116, self.RULE_random_text)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 789
            self.match(kismetParser.RANDOM_TEXT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SupportsContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def num_choice(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.Num_choiceContext)
            else:
                return self.getTypedRuleContext(kismetParser.Num_choiceContext,i)


        def getRuleIndex(self):
            return kismetParser.RULE_supports

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSupports" ):
                listener.enterSupports(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSupports" ):
                listener.exitSupports(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSupports" ):
                return visitor.visitSupports(self)
            else:
                return visitor.visitChildren(self)




    def supports(self):

        localctx = kismetParser.SupportsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 118, self.RULE_supports)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 791
            self.match(kismetParser.T__81)
            self.state = 792
            self.match(kismetParser.T__2)
            self.state = 793
            self.num_choice()
            self.state = 798
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__9:
                self.state = 794
                self.match(kismetParser.T__9)
                self.state = 795
                self.num_choice()
                self.state = 800
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NumContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NUMBER(self):
            return self.getToken(kismetParser.NUMBER, 0)

        def getRuleIndex(self):
            return kismetParser.RULE_num

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNum" ):
                listener.enterNum(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNum" ):
                listener.exitNum(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNum" ):
                return visitor.visitNum(self)
            else:
                return visitor.visitChildren(self)




    def num(self):

        localctx = kismetParser.NumContext(self, self._ctx, self.state)
        self.enterRule(localctx, 120, self.RULE_num)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 801
            self.match(kismetParser.NUMBER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Pos_numContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def POSITIVE_NUMBER(self):
            return self.getToken(kismetParser.POSITIVE_NUMBER, 0)

        def getRuleIndex(self):
            return kismetParser.RULE_pos_num

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPos_num" ):
                listener.enterPos_num(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPos_num" ):
                listener.exitPos_num(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPos_num" ):
                return visitor.visitPos_num(self)
            else:
                return visitor.visitChildren(self)




    def pos_num(self):

        localctx = kismetParser.Pos_numContext(self, self._ctx, self.state)
        self.enterRule(localctx, 122, self.RULE_pos_num)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 803
            self.match(kismetParser.POSITIVE_NUMBER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NameContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NAME(self):
            return self.getToken(kismetParser.NAME, 0)

        def getRuleIndex(self):
            return kismetParser.RULE_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterName" ):
                listener.enterName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitName" ):
                listener.exitName(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitName" ):
                return visitor.visitName(self)
            else:
                return visitor.visitChildren(self)




    def name(self):

        localctx = kismetParser.NameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 124, self.RULE_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 805
            self.match(kismetParser.NAME)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VarContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def VAR(self):
            return self.getToken(kismetParser.VAR, 0)

        def getRuleIndex(self):
            return kismetParser.RULE_var

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVar" ):
                listener.enterVar(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVar" ):
                listener.exitVar(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVar" ):
                return visitor.visitVar(self)
            else:
                return visitor.visitChildren(self)




    def var(self):

        localctx = kismetParser.VarContext(self, self._ctx, self.state)
        self.enterRule(localctx, 126, self.RULE_var)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 807
            self.match(kismetParser.VAR)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ComparatorContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return kismetParser.RULE_comparator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterComparator" ):
                listener.enterComparator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitComparator" ):
                listener.exitComparator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitComparator" ):
                return visitor.visitComparator(self)
            else:
                return visitor.visitChildren(self)




    def comparator(self):

        localctx = kismetParser.ComparatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 128, self.RULE_comparator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 809
            _la = self._input.LA(1)
            if not(((((_la - 29)) & ~0x3f) == 0 and ((1 << (_la - 29)) & ((1 << (kismetParser.T__28 - 29)) | (1 << (kismetParser.T__30 - 29)) | (1 << (kismetParser.T__82 - 29)) | (1 << (kismetParser.T__83 - 29)) | (1 << (kismetParser.T__84 - 29)) | (1 << (kismetParser.T__85 - 29)) | (1 << (kismetParser.T__86 - 29)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Num_choiceContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OPEN(self):
            return self.getToken(kismetParser.OPEN, 0)

        def num(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.NumContext)
            else:
                return self.getTypedRuleContext(kismetParser.NumContext,i)


        def CLOSE(self):
            return self.getToken(kismetParser.CLOSE, 0)

        def name(self):
            return self.getTypedRuleContext(kismetParser.NameContext,0)


        def pdf(self):
            return self.getTypedRuleContext(kismetParser.PdfContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_num_choice

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNum_choice" ):
                listener.enterNum_choice(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNum_choice" ):
                listener.exitNum_choice(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNum_choice" ):
                return visitor.visitNum_choice(self)
            else:
                return visitor.visitChildren(self)




    def num_choice(self):

        localctx = kismetParser.Num_choiceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 130, self.RULE_num_choice)
        self._la = 0 # Token type
        try:
            self.state = 826
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,80,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 811
                self.match(kismetParser.OPEN)
                self.state = 812
                self.num()
                self.state = 813
                self.match(kismetParser.CLOSE)
                self.state = 814
                self.name()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 816
                self.match(kismetParser.OPEN)
                self.state = 817
                self.num()
                self.state = 818
                self.match(kismetParser.T__2)
                self.state = 819
                self.num()
                self.state = 820
                self.match(kismetParser.CLOSE)
                self.state = 822
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==kismetParser.T__1 or _la==kismetParser.T__29 or _la==kismetParser.T__87 or _la==kismetParser.NEG:
                    self.state = 821
                    self.pdf()


                self.state = 824
                self.name()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PdfContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NEG(self, i:int=None):
            if i is None:
                return self.getTokens(kismetParser.NEG)
            else:
                return self.getToken(kismetParser.NEG, i)

        def getRuleIndex(self):
            return kismetParser.RULE_pdf

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPdf" ):
                listener.enterPdf(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPdf" ):
                listener.exitPdf(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPdf" ):
                return visitor.visitPdf(self)
            else:
                return visitor.visitChildren(self)




    def pdf(self):

        localctx = kismetParser.PdfContext(self, self._ctx, self.state)
        self.enterRule(localctx, 132, self.RULE_pdf)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 829 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 828
                    _la = self._input.LA(1)
                    if not(_la==kismetParser.T__1 or _la==kismetParser.T__29 or _la==kismetParser.T__87 or _la==kismetParser.NEG):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()

                else:
                    raise NoViableAltException(self)
                self.state = 831 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,81,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





