# Generated from kismet.ebnv by ANTLR 4.7.2
# encoding: utf-8
from antlr4 import *
from io import StringIO
from typing.io import TextIO
import sys


def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3b")
        buf.write("\u02b9\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\4\23\t\23")
        buf.write("\4\24\t\24\4\25\t\25\4\26\t\26\4\27\t\27\4\30\t\30\4\31")
        buf.write("\t\31\4\32\t\32\4\33\t\33\4\34\t\34\4\35\t\35\4\36\t\36")
        buf.write("\4\37\t\37\4 \t \4!\t!\4\"\t\"\4#\t#\4$\t$\4%\t%\4&\t")
        buf.write("&\4\'\t\'\4(\t(\4)\t)\4*\t*\4+\t+\4,\t,\4-\t-\4.\t.\4")
        buf.write("/\t/\4\60\t\60\4\61\t\61\4\62\t\62\4\63\t\63\4\64\t\64")
        buf.write("\4\65\t\65\4\66\t\66\4\67\t\67\48\t8\49\t9\3\2\3\2\3\2")
        buf.write("\3\2\3\2\6\2x\n\2\r\2\16\2y\3\2\3\2\3\3\3\3\3\3\3\3\3")
        buf.write("\3\3\3\7\3\u0084\n\3\f\3\16\3\u0087\13\3\3\3\3\3\5\3\u008b")
        buf.write("\n\3\3\3\3\3\3\3\3\3\3\4\3\4\3\4\3\4\7\4\u0095\n\4\f\4")
        buf.write("\16\4\u0098\13\4\3\5\5\5\u009b\n\5\3\5\3\5\5\5\u009f\n")
        buf.write("\5\3\5\3\5\3\5\7\5\u00a4\n\5\f\5\16\5\u00a7\13\5\3\5\3")
        buf.write("\5\3\5\3\5\7\5\u00ad\n\5\f\5\16\5\u00b0\13\5\3\5\3\5\5")
        buf.write("\5\u00b4\n\5\3\5\3\5\5\5\u00b8\n\5\3\5\3\5\7\5\u00bc\n")
        buf.write("\5\f\5\16\5\u00bf\13\5\3\5\3\5\3\6\3\6\3\7\3\7\3\b\3\b")
        buf.write("\3\t\3\t\5\t\u00cb\n\t\3\n\3\n\5\n\u00cf\n\n\3\13\3\13")
        buf.write("\3\13\3\13\3\13\7\13\u00d6\n\13\f\13\16\13\u00d9\13\13")
        buf.write("\3\13\5\13\u00dc\n\13\3\13\3\13\3\f\3\f\3\f\3\f\3\f\7")
        buf.write("\f\u00e5\n\f\f\f\16\f\u00e8\13\f\3\f\5\f\u00eb\n\f\3\f")
        buf.write("\3\f\3\r\6\r\u00f0\n\r\r\r\16\r\u00f1\3\r\6\r\u00f5\n")
        buf.write("\r\r\r\16\r\u00f6\5\r\u00f9\n\r\3\16\5\16\u00fc\n\16\3")
        buf.write("\16\3\16\3\16\3\16\3\16\3\16\7\16\u0104\n\16\f\16\16\16")
        buf.write("\u0107\13\16\3\16\3\16\5\16\u010b\n\16\3\16\5\16\u010e")
        buf.write("\n\16\3\16\5\16\u0111\n\16\3\16\3\16\5\16\u0115\n\16\3")
        buf.write("\16\3\16\7\16\u0119\n\16\f\16\16\16\u011c\13\16\3\16\3")
        buf.write("\16\3\17\3\17\3\17\3\20\3\20\3\21\3\21\3\21\3\21\3\21")
        buf.write("\7\21\u012a\n\21\f\21\16\21\u012d\13\21\3\22\3\22\3\23")
        buf.write("\3\23\3\23\3\24\3\24\6\24\u0136\n\24\r\24\16\24\u0137")
        buf.write("\3\25\3\25\3\25\3\25\3\25\7\25\u013f\n\25\f\25\16\25\u0142")
        buf.write("\13\25\3\25\3\25\3\25\3\25\3\25\3\25\3\25\7\25\u014b\n")
        buf.write("\25\f\25\16\25\u014e\13\25\3\25\3\25\3\25\3\25\3\25\3")
        buf.write("\25\3\25\7\25\u0157\n\25\f\25\16\25\u015a\13\25\3\25\3")
        buf.write("\25\3\25\3\25\3\25\3\25\7\25\u0162\n\25\f\25\16\25\u0165")
        buf.write("\13\25\3\25\3\25\5\25\u0169\n\25\3\26\3\26\3\27\3\27\3")
        buf.write("\27\3\27\3\27\5\27\u0172\n\27\3\30\3\30\3\30\3\30\3\30")
        buf.write("\3\30\7\30\u017a\n\30\f\30\16\30\u017d\13\30\3\30\3\30")
        buf.write("\5\30\u0181\n\30\3\30\3\30\3\30\5\30\u0186\n\30\3\30\3")
        buf.write("\30\3\30\5\30\u018b\n\30\7\30\u018d\n\30\f\30\16\30\u0190")
        buf.write("\13\30\3\30\3\30\3\31\3\31\3\31\5\31\u0197\n\31\3\31\3")
        buf.write("\31\3\31\3\31\7\31\u019d\n\31\f\31\16\31\u01a0\13\31\3")
        buf.write("\31\3\31\3\32\3\32\3\32\3\33\5\33\u01a8\n\33\3\33\3\33")
        buf.write("\5\33\u01ac\n\33\3\33\3\33\3\33\3\33\3\33\5\33\u01b3\n")
        buf.write("\33\3\33\3\33\3\33\3\33\5\33\u01b9\n\33\3\34\3\34\3\35")
        buf.write("\3\35\3\36\3\36\3\36\3\36\3\36\7\36\u01c4\n\36\f\36\16")
        buf.write("\36\u01c7\13\36\3\37\3\37\3\37\3\37\7\37\u01cd\n\37\f")
        buf.write("\37\16\37\u01d0\13\37\3 \3 \3 \3 \3 \3 \3 \3 \3 \3 \3")
        buf.write(" \3 \3 \3 \3 \3 \3 \3 \3 \3 \3 \3 \3 \3 \3 \3 \3 \3 \3")
        buf.write(" \3 \3 \3 \3 \3 \3 \3 \3 \3 \3 \3 \5 \u01fa\n \3!\3!\3")
        buf.write("!\3!\3!\3!\3!\5!\u0203\n!\3\"\3\"\3\"\3\"\3#\3#\3#\3#")
        buf.write("\3$\3$\3$\3$\3$\3$\3%\3%\3&\3&\3&\3&\5&\u0219\n&\3&\3")
        buf.write("&\3&\3&\5&\u021f\n&\3&\3&\3&\5&\u0224\n&\3\'\3\'\5\'\u0228")
        buf.write("\n\'\3\'\7\'\u022b\n\'\f\'\16\'\u022e\13\'\3\'\3\'\7\'")
        buf.write("\u0232\n\'\f\'\16\'\u0235\13\'\3\'\3\'\3\'\3\'\5\'\u023b")
        buf.write("\n\'\3(\3(\3(\3(\3(\3(\3)\3)\3)\3)\3)\7)\u0248\n)\f)\16")
        buf.write(")\u024b\13)\3)\3)\3*\3*\3+\3+\3,\3,\3,\3,\3,\3,\3,\3,")
        buf.write("\5,\u025b\n,\3,\3,\3,\3,\3,\3,\5,\u0263\n,\7,\u0265\n")
        buf.write(",\f,\16,\u0268\13,\3,\3,\3-\3-\3-\3-\3-\7-\u0271\n-\f")
        buf.write("-\16-\u0274\13-\3.\3.\3.\3.\3.\7.\u027b\n.\f.\16.\u027e")
        buf.write("\13.\3/\3/\3/\3/\7/\u0284\n/\f/\16/\u0287\13/\3\60\3\60")
        buf.write("\3\61\3\61\3\61\3\61\3\62\3\62\3\62\3\62\3\62\7\62\u0294")
        buf.write("\n\62\f\62\16\62\u0297\13\62\3\63\3\63\3\64\3\64\3\65")
        buf.write("\3\65\3\66\3\66\3\67\3\67\38\38\38\38\38\38\38\38\38\3")
        buf.write("8\38\58\u02ae\n8\38\38\58\u02b2\n8\39\69\u02b5\n9\r9\16")
        buf.write("9\u02b6\39\2\2:\2\4\6\b\n\f\16\20\22\24\26\30\32\34\36")
        buf.write(" \"$&(*,.\60\62\64\668:<>@BDFHJLNPRTVXZ\\^`bdfhjlnp\2")
        buf.write("\r\3\2\f\r\3\2\7\b\4\2\20\20\34\37\3\2\65\66\3\2\67<\3")
        buf.write("\2AC\3\2DE\4\2CCFK\3\2YZ\5\2\34\34\37\37QU\6\2\b\b\35")
        buf.write("\35XX``\2\u02ef\2w\3\2\2\2\4}\3\2\2\2\6\u0090\3\2\2\2")
        buf.write("\b\u009a\3\2\2\2\n\u00c2\3\2\2\2\f\u00c4\3\2\2\2\16\u00c6")
        buf.write("\3\2\2\2\20\u00ca\3\2\2\2\22\u00ce\3\2\2\2\24\u00d0\3")
        buf.write("\2\2\2\26\u00df\3\2\2\2\30\u00f8\3\2\2\2\32\u00fb\3\2")
        buf.write("\2\2\34\u011f\3\2\2\2\36\u0122\3\2\2\2 \u0124\3\2\2\2")
        buf.write("\"\u012e\3\2\2\2$\u0130\3\2\2\2&\u0133\3\2\2\2(\u0168")
        buf.write("\3\2\2\2*\u016a\3\2\2\2,\u0171\3\2\2\2.\u0173\3\2\2\2")
        buf.write("\60\u0193\3\2\2\2\62\u01a3\3\2\2\2\64\u01b8\3\2\2\2\66")
        buf.write("\u01ba\3\2\2\28\u01bc\3\2\2\2:\u01be\3\2\2\2<\u01c8\3")
        buf.write("\2\2\2>\u01f9\3\2\2\2@\u0202\3\2\2\2B\u0204\3\2\2\2D\u0208")
        buf.write("\3\2\2\2F\u020c\3\2\2\2H\u0212\3\2\2\2J\u0214\3\2\2\2")
        buf.write("L\u0225\3\2\2\2N\u023c\3\2\2\2P\u0242\3\2\2\2R\u024e\3")
        buf.write("\2\2\2T\u0250\3\2\2\2V\u0252\3\2\2\2X\u026b\3\2\2\2Z\u0275")
        buf.write("\3\2\2\2\\\u027f\3\2\2\2^\u0288\3\2\2\2`\u028a\3\2\2\2")
        buf.write("b\u028e\3\2\2\2d\u0298\3\2\2\2f\u029a\3\2\2\2h\u029c\3")
        buf.write("\2\2\2j\u029e\3\2\2\2l\u02a0\3\2\2\2n\u02b1\3\2\2\2p\u02b4")
        buf.write("\3\2\2\2rx\5V,\2sx\5.\30\2tx\5\32\16\2ux\5\b\5\2vx\5\4")
        buf.write("\3\2wr\3\2\2\2ws\3\2\2\2wt\3\2\2\2wu\3\2\2\2wv\3\2\2\2")
        buf.write("xy\3\2\2\2yw\3\2\2\2yz\3\2\2\2z{\3\2\2\2{|\7\2\2\3|\3")
        buf.write("\3\2\2\2}~\7\3\2\2~\177\5h\65\2\177\u0080\7\4\2\2\u0080")
        buf.write("\u0085\5\64\33\2\u0081\u0082\7\5\2\2\u0082\u0084\5\64")
        buf.write("\33\2\u0083\u0081\3\2\2\2\u0084\u0087\3\2\2\2\u0085\u0083")
        buf.write("\3\2\2\2\u0085\u0086\3\2\2\2\u0086\u0088\3\2\2\2\u0087")
        buf.write("\u0085\3\2\2\2\u0088\u008a\7\6\2\2\u0089\u008b\5^\60\2")
        buf.write("\u008a\u0089\3\2\2\2\u008a\u008b\3\2\2\2\u008b\u008c\3")
        buf.write("\2\2\2\u008c\u008d\7\7\2\2\u008d\u008e\5<\37\2\u008e\u008f")
        buf.write("\7\b\2\2\u008f\5\3\2\2\2\u0090\u0091\7\t\2\2\u0091\u0096")
        buf.write("\5h\65\2\u0092\u0093\7\n\2\2\u0093\u0095\5h\65\2\u0094")
        buf.write("\u0092\3\2\2\2\u0095\u0098\3\2\2\2\u0096\u0094\3\2\2\2")
        buf.write("\u0096\u0097\3\2\2\2\u0097\7\3\2\2\2\u0098\u0096\3\2\2")
        buf.write("\2\u0099\u009b\5\n\6\2\u009a\u0099\3\2\2\2\u009a\u009b")
        buf.write("\3\2\2\2\u009b\u009c\3\2\2\2\u009c\u009e\5\f\7\2\u009d")
        buf.write("\u009f\5\16\b\2\u009e\u009d\3\2\2\2\u009e\u009f\3\2\2")
        buf.write("\2\u009f\u00a0\3\2\2\2\u00a0\u00a5\5h\65\2\u00a1\u00a2")
        buf.write("\7\n\2\2\u00a2\u00a4\5h\65\2\u00a3\u00a1\3\2\2\2\u00a4")
        buf.write("\u00a7\3\2\2\2\u00a5\u00a3\3\2\2\2\u00a5\u00a6\3\2\2\2")
        buf.write("\u00a6\u00a8\3\2\2\2\u00a7\u00a5\3\2\2\2\u00a8\u00a9\7")
        buf.write("\4\2\2\u00a9\u00ae\5\64\33\2\u00aa\u00ab\7\5\2\2\u00ab")
        buf.write("\u00ad\5\64\33\2\u00ac\u00aa\3\2\2\2\u00ad\u00b0\3\2\2")
        buf.write("\2\u00ae\u00ac\3\2\2\2\u00ae\u00af\3\2\2\2\u00af\u00b1")
        buf.write("\3\2\2\2\u00b0\u00ae\3\2\2\2\u00b1\u00b3\7\6\2\2\u00b2")
        buf.write("\u00b4\5\6\4\2\u00b3\u00b2\3\2\2\2\u00b3\u00b4\3\2\2\2")
        buf.write("\u00b4\u00b5\3\2\2\2\u00b5\u00b7\7\7\2\2\u00b6\u00b8\5")
        buf.write("\20\t\2\u00b7\u00b6\3\2\2\2\u00b7\u00b8\3\2\2\2\u00b8")
        buf.write("\u00bd\3\2\2\2\u00b9\u00ba\7\5\2\2\u00ba\u00bc\5\20\t")
        buf.write("\2\u00bb\u00b9\3\2\2\2\u00bc\u00bf\3\2\2\2\u00bd\u00bb")
        buf.write("\3\2\2\2\u00bd\u00be\3\2\2\2\u00be\u00c0\3\2\2\2\u00bf")
        buf.write("\u00bd\3\2\2\2\u00c0\u00c1\7\b\2\2\u00c1\t\3\2\2\2\u00c2")
        buf.write("\u00c3\7\13\2\2\u00c3\13\3\2\2\2\u00c4\u00c5\t\2\2\2\u00c5")
        buf.write("\r\3\2\2\2\u00c6\u00c7\7\16\2\2\u00c7\17\3\2\2\2\u00c8")
        buf.write("\u00cb\5\24\13\2\u00c9\u00cb\5\26\f\2\u00ca\u00c8\3\2")
        buf.write("\2\2\u00ca\u00c9\3\2\2\2\u00cb\21\3\2\2\2\u00cc\u00cf")
        buf.write("\7\17\2\2\u00cd\u00cf\5h\65\2\u00ce\u00cc\3\2\2\2\u00ce")
        buf.write("\u00cd\3\2\2\2\u00cf\23\3\2\2\2\u00d0\u00d1\5\30\r\2\u00d1")
        buf.write("\u00d2\7\4\2\2\u00d2\u00d7\5\22\n\2\u00d3\u00d4\7\5\2")
        buf.write("\2\u00d4\u00d6\5\22\n\2\u00d5\u00d3\3\2\2\2\u00d6\u00d9")
        buf.write("\3\2\2\2\u00d7\u00d5\3\2\2\2\u00d7\u00d8\3\2\2\2\u00d8")
        buf.write("\u00db\3\2\2\2\u00d9\u00d7\3\2\2\2\u00da\u00dc\5<\37\2")
        buf.write("\u00db\u00da\3\2\2\2\u00db\u00dc\3\2\2\2\u00dc\u00dd\3")
        buf.write("\2\2\2\u00dd\u00de\7\6\2\2\u00de\25\3\2\2\2\u00df\u00e0")
        buf.write("\5\30\r\2\u00e0\u00e1\7\20\2\2\u00e1\u00e6\5h\65\2\u00e2")
        buf.write("\u00e3\7\5\2\2\u00e3\u00e5\5h\65\2\u00e4\u00e2\3\2\2\2")
        buf.write("\u00e5\u00e8\3\2\2\2\u00e6\u00e4\3\2\2\2\u00e6\u00e7\3")
        buf.write("\2\2\2\u00e7\u00ea\3\2\2\2\u00e8\u00e6\3\2\2\2\u00e9\u00eb")
        buf.write("\5<\37\2\u00ea\u00e9\3\2\2\2\u00ea\u00eb\3\2\2\2\u00eb")
        buf.write("\u00ec\3\2\2\2\u00ec\u00ed\7\20\2\2\u00ed\27\3\2\2\2\u00ee")
        buf.write("\u00f0\7\21\2\2\u00ef\u00ee\3\2\2\2\u00f0\u00f1\3\2\2")
        buf.write("\2\u00f1\u00ef\3\2\2\2\u00f1\u00f2\3\2\2\2\u00f2\u00f9")
        buf.write("\3\2\2\2\u00f3\u00f5\7`\2\2\u00f4\u00f3\3\2\2\2\u00f5")
        buf.write("\u00f6\3\2\2\2\u00f6\u00f4\3\2\2\2\u00f6\u00f7\3\2\2\2")
        buf.write("\u00f7\u00f9\3\2\2\2\u00f8\u00ef\3\2\2\2\u00f8\u00f4\3")
        buf.write("\2\2\2\u00f9\31\3\2\2\2\u00fa\u00fc\5\36\20\2\u00fb\u00fa")
        buf.write("\3\2\2\2\u00fb\u00fc\3\2\2\2\u00fc\u00fd\3\2\2\2\u00fd")
        buf.write("\u00fe\7\22\2\2\u00fe\u00ff\5h\65\2\u00ff\u0100\7\4\2")
        buf.write("\2\u0100\u0105\5\64\33\2\u0101\u0102\7\5\2\2\u0102\u0104")
        buf.write("\5\64\33\2\u0103\u0101\3\2\2\2\u0104\u0107\3\2\2\2\u0105")
        buf.write("\u0103\3\2\2\2\u0105\u0106\3\2\2\2\u0106\u0108\3\2\2\2")
        buf.write("\u0107\u0105\3\2\2\2\u0108\u010a\7\6\2\2\u0109\u010b\5")
        buf.write("\34\17\2\u010a\u0109\3\2\2\2\u010a\u010b\3\2\2\2\u010b")
        buf.write("\u010d\3\2\2\2\u010c\u010e\5\60\31\2\u010d\u010c\3\2\2")
        buf.write("\2\u010d\u010e\3\2\2\2\u010e\u0110\3\2\2\2\u010f\u0111")
        buf.write("\5^\60\2\u0110\u010f\3\2\2\2\u0110\u0111\3\2\2\2\u0111")
        buf.write("\u0112\3\2\2\2\u0112\u0114\7\7\2\2\u0113\u0115\5,\27\2")
        buf.write("\u0114\u0113\3\2\2\2\u0114\u0115\3\2\2\2\u0115\u011a\3")
        buf.write("\2\2\2\u0116\u0117\7\23\2\2\u0117\u0119\5,\27\2\u0118")
        buf.write("\u0116\3\2\2\2\u0119\u011c\3\2\2\2\u011a\u0118\3\2\2\2")
        buf.write("\u011a\u011b\3\2\2\2\u011b\u011d\3\2\2\2\u011c\u011a\3")
        buf.write("\2\2\2\u011d\u011e\7\b\2\2\u011e\33\3\2\2\2\u011f\u0120")
        buf.write("\7\24\2\2\u0120\u0121\5d\63\2\u0121\35\3\2\2\2\u0122\u0123")
        buf.write("\7\25\2\2\u0123\37\3\2\2\2\u0124\u0125\7\26\2\2\u0125")
        buf.write("\u0126\7\7\2\2\u0126\u012b\5\"\22\2\u0127\u0128\7\5\2")
        buf.write("\2\u0128\u012a\5\"\22\2\u0129\u0127\3\2\2\2\u012a\u012d")
        buf.write("\3\2\2\2\u012b\u0129\3\2\2\2\u012b\u012c\3\2\2\2\u012c")
        buf.write("!\3\2\2\2\u012d\u012b\3\2\2\2\u012e\u012f\5@!\2\u012f")
        buf.write("#\3\2\2\2\u0130\u0131\7\17\2\2\u0131\u0132\5\30\r\2\u0132")
        buf.write("%\3\2\2\2\u0133\u0135\7\27\2\2\u0134\u0136\5(\25\2\u0135")
        buf.write("\u0134\3\2\2\2\u0136\u0137\3\2\2\2\u0137\u0135\3\2\2\2")
        buf.write("\u0137\u0138\3\2\2\2\u0138\'\3\2\2\2\u0139\u013a\5j\66")
        buf.write("\2\u013a\u013b\7\4\2\2\u013b\u0140\5\64\33\2\u013c\u013d")
        buf.write("\7\5\2\2\u013d\u013f\5\64\33\2\u013e\u013c\3\2\2\2\u013f")
        buf.write("\u0142\3\2\2\2\u0140\u013e\3\2\2\2\u0140\u0141\3\2\2\2")
        buf.write("\u0141\u0143\3\2\2\2\u0142\u0140\3\2\2\2\u0143\u0144\7")
        buf.write("\6\2\2\u0144\u0169\3\2\2\2\u0145\u0146\5h\65\2\u0146\u0147")
        buf.write("\7\4\2\2\u0147\u014c\5\64\33\2\u0148\u0149\7\5\2\2\u0149")
        buf.write("\u014b\5\64\33\2\u014a\u0148\3\2\2\2\u014b\u014e\3\2\2")
        buf.write("\2\u014c\u014a\3\2\2\2\u014c\u014d\3\2\2\2\u014d\u014f")
        buf.write("\3\2\2\2\u014e\u014c\3\2\2\2\u014f\u0150\7\6\2\2\u0150")
        buf.write("\u0169\3\2\2\2\u0151\u0152\5*\26\2\u0152\u0153\7\4\2\2")
        buf.write("\u0153\u0158\5\64\33\2\u0154\u0155\7\5\2\2\u0155\u0157")
        buf.write("\5\64\33\2\u0156\u0154\3\2\2\2\u0157\u015a\3\2\2\2\u0158")
        buf.write("\u0156\3\2\2\2\u0158\u0159\3\2\2\2\u0159\u015b\3\2\2\2")
        buf.write("\u015a\u0158\3\2\2\2\u015b\u015c\7\6\2\2\u015c\u0169\3")
        buf.write("\2\2\2\u015d\u015e\7\4\2\2\u015e\u0163\5\64\33\2\u015f")
        buf.write("\u0160\7\5\2\2\u0160\u0162\5\64\33\2\u0161\u015f\3\2\2")
        buf.write("\2\u0162\u0165\3\2\2\2\u0163\u0161\3\2\2\2\u0163\u0164")
        buf.write("\3\2\2\2\u0164\u0166\3\2\2\2\u0165\u0163\3\2\2\2\u0166")
        buf.write("\u0167\7\6\2\2\u0167\u0169\3\2\2\2\u0168\u0139\3\2\2\2")
        buf.write("\u0168\u0145\3\2\2\2\u0168\u0151\3\2\2\2\u0168\u015d\3")
        buf.write("\2\2\2\u0169)\3\2\2\2\u016a\u016b\7\30\2\2\u016b+\3\2")
        buf.write("\2\2\u016c\u0172\5:\36\2\u016d\u0172\5<\37\2\u016e\u0172")
        buf.write("\5&\24\2\u016f\u0172\5 \21\2\u0170\u0172\5$\23\2\u0171")
        buf.write("\u016c\3\2\2\2\u0171\u016d\3\2\2\2\u0171\u016e\3\2\2\2")
        buf.write("\u0171\u016f\3\2\2\2\u0171\u0170\3\2\2\2\u0172-\3\2\2")
        buf.write("\2\u0173\u0174\7\31\2\2\u0174\u0175\5h\65\2\u0175\u0176")
        buf.write("\7\4\2\2\u0176\u017b\5\64\33\2\u0177\u0178\7\5\2\2\u0178")
        buf.write("\u017a\5\64\33\2\u0179\u0177\3\2\2\2\u017a\u017d\3\2\2")
        buf.write("\2\u017b\u0179\3\2\2\2\u017b\u017c\3\2\2\2\u017c\u017e")
        buf.write("\3\2\2\2\u017d\u017b\3\2\2\2\u017e\u0180\7\6\2\2\u017f")
        buf.write("\u0181\5\60\31\2\u0180\u017f\3\2\2\2\u0180\u0181\3\2\2")
        buf.write("\2\u0181\u0182\3\2\2\2\u0182\u0185\7\7\2\2\u0183\u0186")
        buf.write("\5:\36\2\u0184\u0186\5<\37\2\u0185\u0183\3\2\2\2\u0185")
        buf.write("\u0184\3\2\2\2\u0186\u018e\3\2\2\2\u0187\u018a\7\23\2")
        buf.write("\2\u0188\u018b\5:\36\2\u0189\u018b\5<\37\2\u018a\u0188")
        buf.write("\3\2\2\2\u018a\u0189\3\2\2\2\u018b\u018d\3\2\2\2\u018c")
        buf.write("\u0187\3\2\2\2\u018d\u0190\3\2\2\2\u018e\u018c\3\2\2\2")
        buf.write("\u018e\u018f\3\2\2\2\u018f\u0191\3\2\2\2\u0190\u018e\3")
        buf.write("\2\2\2\u0191\u0192\7\b\2\2\u0192/\3\2\2\2\u0193\u0196")
        buf.write("\7\32\2\2\u0194\u0197\5\62\32\2\u0195\u0197\5h\65\2\u0196")
        buf.write("\u0194\3\2\2\2\u0196\u0195\3\2\2\2\u0197\u0198\3\2\2\2")
        buf.write("\u0198\u0199\7\4\2\2\u0199\u019e\5\64\33\2\u019a\u019b")
        buf.write("\7\5\2\2\u019b\u019d\5\64\33\2\u019c\u019a\3\2\2\2\u019d")
        buf.write("\u01a0\3\2\2\2\u019e\u019c\3\2\2\2\u019e\u019f\3\2\2\2")
        buf.write("\u019f\u01a1\3\2\2\2\u01a0\u019e\3\2\2\2\u01a1\u01a2\7")
        buf.write("\6\2\2\u01a2\61\3\2\2\2\u01a3\u01a4\7\33\2\2\u01a4\u01a5")
        buf.write("\5h\65\2\u01a5\63\3\2\2\2\u01a6\u01a8\58\35\2\u01a7\u01a6")
        buf.write("\3\2\2\2\u01a7\u01a8\3\2\2\2\u01a8\u01a9\3\2\2\2\u01a9")
        buf.write("\u01b9\5j\66\2\u01aa\u01ac\58\35\2\u01ab\u01aa\3\2\2\2")
        buf.write("\u01ab\u01ac\3\2\2\2\u01ac\u01ad\3\2\2\2\u01ad\u01ae\5")
        buf.write("j\66\2\u01ae\u01af\5\66\34\2\u01af\u01b0\5h\65\2\u01b0")
        buf.write("\u01b9\3\2\2\2\u01b1\u01b3\58\35\2\u01b2\u01b1\3\2\2\2")
        buf.write("\u01b2\u01b3\3\2\2\2\u01b3\u01b4\3\2\2\2\u01b4\u01b5\5")
        buf.write("j\66\2\u01b5\u01b6\5\66\34\2\u01b6\u01b7\5j\66\2\u01b7")
        buf.write("\u01b9\3\2\2\2\u01b8\u01a7\3\2\2\2\u01b8\u01ab\3\2\2\2")
        buf.write("\u01b8\u01b2\3\2\2\2\u01b9\65\3\2\2\2\u01ba\u01bb\t\3")
        buf.write("\2\2\u01bb\67\3\2\2\2\u01bc\u01bd\t\4\2\2\u01bd9\3\2\2")
        buf.write("\2\u01be\u01bf\7 \2\2\u01bf\u01c0\7\7\2\2\u01c0\u01c5")
        buf.write("\5h\65\2\u01c1\u01c2\7\5\2\2\u01c2\u01c4\5h\65\2\u01c3")
        buf.write("\u01c1\3\2\2\2\u01c4\u01c7\3\2\2\2\u01c5\u01c3\3\2\2\2")
        buf.write("\u01c5\u01c6\3\2\2\2\u01c6;\3\2\2\2\u01c7\u01c5\3\2\2")
        buf.write("\2\u01c8\u01c9\7!\2\2\u01c9\u01ce\5@!\2\u01ca\u01cb\7")
        buf.write("\5\2\2\u01cb\u01cd\5@!\2\u01cc\u01ca\3\2\2\2\u01cd\u01d0")
        buf.write("\3\2\2\2\u01ce\u01cc\3\2\2\2\u01ce\u01cf\3\2\2\2\u01cf")
        buf.write("=\3\2\2\2\u01d0\u01ce\3\2\2\2\u01d1\u01fa\7\"\2\2\u01d2")
        buf.write("\u01fa\7#\2\2\u01d3\u01fa\7$\2\2\u01d4\u01d5\7%\2\2\u01d5")
        buf.write("\u01d6\7&\2\2\u01d6\u01fa\7\'\2\2\u01d7\u01d8\7(\2\2\u01d8")
        buf.write("\u01fa\7\'\2\2\u01d9\u01da\7)\2\2\u01da\u01fa\7\'\2\2")
        buf.write("\u01db\u01dc\7%\2\2\u01dc\u01dd\7&\2\2\u01dd\u01fa\7*")
        buf.write("\2\2\u01de\u01df\7(\2\2\u01df\u01fa\7*\2\2\u01e0\u01e1")
        buf.write("\7)\2\2\u01e1\u01fa\7*\2\2\u01e2\u01e3\7%\2\2\u01e3\u01e4")
        buf.write("\7&\2\2\u01e4\u01fa\7+\2\2\u01e5\u01e6\7(\2\2\u01e6\u01fa")
        buf.write("\7+\2\2\u01e7\u01e8\7)\2\2\u01e8\u01fa\7+\2\2\u01e9\u01ea")
        buf.write("\7%\2\2\u01ea\u01eb\7&\2\2\u01eb\u01fa\7,\2\2\u01ec\u01ed")
        buf.write("\7(\2\2\u01ed\u01fa\7,\2\2\u01ee\u01ef\7)\2\2\u01ef\u01fa")
        buf.write("\7,\2\2\u01f0\u01fa\7-\2\2\u01f1\u01fa\7.\2\2\u01f2\u01fa")
        buf.write("\7/\2\2\u01f3\u01fa\7\60\2\2\u01f4\u01fa\7\61\2\2\u01f5")
        buf.write("\u01fa\7\62\2\2\u01f6\u01fa\7\63\2\2\u01f7\u01fa\7%\2")
        buf.write("\2\u01f8\u01fa\7\64\2\2\u01f9\u01d1\3\2\2\2\u01f9\u01d2")
        buf.write("\3\2\2\2\u01f9\u01d3\3\2\2\2\u01f9\u01d4\3\2\2\2\u01f9")
        buf.write("\u01d7\3\2\2\2\u01f9\u01d9\3\2\2\2\u01f9\u01db\3\2\2\2")
        buf.write("\u01f9\u01de\3\2\2\2\u01f9\u01e0\3\2\2\2\u01f9\u01e2\3")
        buf.write("\2\2\2\u01f9\u01e5\3\2\2\2\u01f9\u01e7\3\2\2\2\u01f9\u01e9")
        buf.write("\3\2\2\2\u01f9\u01ec\3\2\2\2\u01f9\u01ee\3\2\2\2\u01f9")
        buf.write("\u01f0\3\2\2\2\u01f9\u01f1\3\2\2\2\u01f9\u01f2\3\2\2\2")
        buf.write("\u01f9\u01f3\3\2\2\2\u01f9\u01f4\3\2\2\2\u01f9\u01f5\3")
        buf.write("\2\2\2\u01f9\u01f6\3\2\2\2\u01f9\u01f7\3\2\2\2\u01f9\u01f8")
        buf.write("\3\2\2\2\u01fa?\3\2\2\2\u01fb\u0203\5B\"\2\u01fc\u0203")
        buf.write("\5D#\2\u01fd\u0203\5F$\2\u01fe\u0203\5J&\2\u01ff\u0203")
        buf.write("\5L\'\2\u0200\u0203\5N(\2\u0201\u0203\5P)\2\u0202\u01fb")
        buf.write("\3\2\2\2\u0202\u01fc\3\2\2\2\u0202\u01fd\3\2\2\2\u0202")
        buf.write("\u01fe\3\2\2\2\u0202\u01ff\3\2\2\2\u0202\u0200\3\2\2\2")
        buf.write("\u0202\u0201\3\2\2\2\u0203A\3\2\2\2\u0204\u0205\5\64\33")
        buf.write("\2\u0205\u0206\5> \2\u0206\u0207\5\64\33\2\u0207C\3\2")
        buf.write("\2\2\u0208\u0209\5\64\33\2\u0209\u020a\5R*\2\u020a\u020b")
        buf.write("\5h\65\2\u020bE\3\2\2\2\u020c\u020d\5\64\33\2\u020d\u020e")
        buf.write("\t\5\2\2\u020e\u020f\5h\65\2\u020f\u0210\5l\67\2\u0210")
        buf.write("\u0211\5d\63\2\u0211G\3\2\2\2\u0212\u0213\t\6\2\2\u0213")
        buf.write("I\3\2\2\2\u0214\u0215\5\64\33\2\u0215\u0216\7=\2\2\u0216")
        buf.write("\u0218\5\64\33\2\u0217\u0219\5H%\2\u0218\u0217\3\2\2\2")
        buf.write("\u0218\u0219\3\2\2\2\u0219\u021a\3\2\2\2\u021a\u021e\5")
        buf.write("h\65\2\u021b\u021c\7>\2\2\u021c\u021f\7?\2\2\u021d\u021f")
        buf.write("\7@\2\2\u021e\u021b\3\2\2\2\u021e\u021d\3\2\2\2\u021f")
        buf.write("\u0223\3\2\2\2\u0220\u0221\5T+\2\u0221\u0222\5d\63\2\u0222")
        buf.write("\u0224\3\2\2\2\u0223\u0220\3\2\2\2\u0223\u0224\3\2\2\2")
        buf.write("\u0224K\3\2\2\2\u0225\u0227\5\64\33\2\u0226\u0228\5H%")
        buf.write("\2\u0227\u0226\3\2\2\2\u0227\u0228\3\2\2\2\u0228\u022c")
        buf.write("\3\2\2\2\u0229\u022b\t\7\2\2\u022a\u0229\3\2\2\2\u022b")
        buf.write("\u022e\3\2\2\2\u022c\u022a\3\2\2\2\u022c\u022d\3\2\2\2")
        buf.write("\u022d\u022f\3\2\2\2\u022e\u022c\3\2\2\2\u022f\u0233\5")
        buf.write("h\65\2\u0230\u0232\t\b\2\2\u0231\u0230\3\2\2\2\u0232\u0235")
        buf.write("\3\2\2\2\u0233\u0231\3\2\2\2\u0233\u0234\3\2\2\2\u0234")
        buf.write("\u0236\3\2\2\2\u0235\u0233\3\2\2\2\u0236\u023a\5\64\33")
        buf.write("\2\u0237\u0238\5T+\2\u0238\u0239\5d\63\2\u0239\u023b\3")
        buf.write("\2\2\2\u023a\u0237\3\2\2\2\u023a\u023b\3\2\2\2\u023bM")
        buf.write("\3\2\2\2\u023c\u023d\5\64\33\2\u023d\u023e\5h\65\2\u023e")
        buf.write("\u023f\5\64\33\2\u023f\u0240\5l\67\2\u0240\u0241\5d\63")
        buf.write("\2\u0241O\3\2\2\2\u0242\u0243\7\3\2\2\u0243\u0244\7\4")
        buf.write("\2\2\u0244\u0249\5h\65\2\u0245\u0246\7\5\2\2\u0246\u0248")
        buf.write("\5\64\33\2\u0247\u0245\3\2\2\2\u0248\u024b\3\2\2\2\u0249")
        buf.write("\u0247\3\2\2\2\u0249\u024a\3\2\2\2\u024a\u024c\3\2\2\2")
        buf.write("\u024b\u0249\3\2\2\2\u024c\u024d\7\6\2\2\u024dQ\3\2\2")
        buf.write("\2\u024e\u024f\t\t\2\2\u024fS\3\2\2\2\u0250\u0251\t\n")
        buf.write("\2\2\u0251U\3\2\2\2\u0252\u0253\7L\2\2\u0253\u0254\5h")
        buf.write("\65\2\u0254\u025a\7\7\2\2\u0255\u025b\5`\61\2\u0256\u025b")
        buf.write("\5b\62\2\u0257\u025b\5X-\2\u0258\u025b\5Z.\2\u0259\u025b")
        buf.write("\5:\36\2\u025a\u0255\3\2\2\2\u025a\u0256\3\2\2\2\u025a")
        buf.write("\u0257\3\2\2\2\u025a\u0258\3\2\2\2\u025a\u0259\3\2\2\2")
        buf.write("\u025b\u0266\3\2\2\2\u025c\u0262\7\23\2\2\u025d\u0263")
        buf.write("\5`\61\2\u025e\u0263\5b\62\2\u025f\u0263\5X-\2\u0260\u0263")
        buf.write("\5Z.\2\u0261\u0263\5:\36\2\u0262\u025d\3\2\2\2\u0262\u025e")
        buf.write("\3\2\2\2\u0262\u025f\3\2\2\2\u0262\u0260\3\2\2\2\u0262")
        buf.write("\u0261\3\2\2\2\u0263\u0265\3\2\2\2\u0264\u025c\3\2\2\2")
        buf.write("\u0265\u0268\3\2\2\2\u0266\u0264\3\2\2\2\u0266\u0267\3")
        buf.write("\2\2\2\u0267\u0269\3\2\2\2\u0268\u0266\3\2\2\2\u0269\u026a")
        buf.write("\7\b\2\2\u026aW\3\2\2\2\u026b\u026c\7M\2\2\u026c\u026d")
        buf.write("\7\7\2\2\u026d\u0272\5\\/\2\u026e\u026f\7\5\2\2\u026f")
        buf.write("\u0271\5\\/\2\u0270\u026e\3\2\2\2\u0271\u0274\3\2\2\2")
        buf.write("\u0272\u0270\3\2\2\2\u0272\u0273\3\2\2\2\u0273Y\3\2\2")
        buf.write("\2\u0274\u0272\3\2\2\2\u0275\u0276\7N\2\2\u0276\u0277")
        buf.write("\7\7\2\2\u0277\u027c\5\\/\2\u0278\u0279\7\5\2\2\u0279")
        buf.write("\u027b\5\\/\2\u027a\u0278\3\2\2\2\u027b\u027e\3\2\2\2")
        buf.write("\u027c\u027a\3\2\2\2\u027c\u027d\3\2\2\2\u027d[\3\2\2")
        buf.write("\2\u027e\u027c\3\2\2\2\u027f\u0280\7\33\2\2\u0280\u0285")
        buf.write("\5n8\2\u0281\u0282\7\5\2\2\u0282\u0284\5n8\2\u0283\u0281")
        buf.write("\3\2\2\2\u0284\u0287\3\2\2\2\u0285\u0283\3\2\2\2\u0285")
        buf.write("\u0286\3\2\2\2\u0286]\3\2\2\2\u0287\u0285\3\2\2\2\u0288")
        buf.write("\u0289\7[\2\2\u0289_\3\2\2\2\u028a\u028b\7O\2\2\u028b")
        buf.write("\u028c\7\7\2\2\u028c\u028d\5^\60\2\u028da\3\2\2\2\u028e")
        buf.write("\u028f\7P\2\2\u028f\u0290\7\7\2\2\u0290\u0295\5n8\2\u0291")
        buf.write("\u0292\7\5\2\2\u0292\u0294\5n8\2\u0293\u0291\3\2\2\2\u0294")
        buf.write("\u0297\3\2\2\2\u0295\u0293\3\2\2\2\u0295\u0296\3\2\2\2")
        buf.write("\u0296c\3\2\2\2\u0297\u0295\3\2\2\2\u0298\u0299\7^\2\2")
        buf.write("\u0299e\3\2\2\2\u029a\u029b\7_\2\2\u029bg\3\2\2\2\u029c")
        buf.write("\u029d\7a\2\2\u029di\3\2\2\2\u029e\u029f\7b\2\2\u029f")
        buf.write("k\3\2\2\2\u02a0\u02a1\t\13\2\2\u02a1m\3\2\2\2\u02a2\u02a3")
        buf.write("\7V\2\2\u02a3\u02a4\5d\63\2\u02a4\u02a5\7W\2\2\u02a5\u02a6")
        buf.write("\5h\65\2\u02a6\u02b2\3\2\2\2\u02a7\u02a8\7V\2\2\u02a8")
        buf.write("\u02a9\5d\63\2\u02a9\u02aa\7\7\2\2\u02aa\u02ab\5d\63\2")
        buf.write("\u02ab\u02ad\7W\2\2\u02ac\u02ae\5p9\2\u02ad\u02ac\3\2")
        buf.write("\2\2\u02ad\u02ae\3\2\2\2\u02ae\u02af\3\2\2\2\u02af\u02b0")
        buf.write("\5h\65\2\u02b0\u02b2\3\2\2\2\u02b1\u02a2\3\2\2\2\u02b1")
        buf.write("\u02a7\3\2\2\2\u02b2o\3\2\2\2\u02b3\u02b5\t\f\2\2\u02b4")
        buf.write("\u02b3\3\2\2\2\u02b5\u02b6\3\2\2\2\u02b6\u02b4\3\2\2\2")
        buf.write("\u02b6\u02b7\3\2\2\2\u02b7q\3\2\2\2Gwy\u0085\u008a\u0096")
        buf.write("\u009a\u009e\u00a5\u00ae\u00b3\u00b7\u00bd\u00ca\u00ce")
        buf.write("\u00d7\u00db\u00e6\u00ea\u00f1\u00f6\u00f8\u00fb\u0105")
        buf.write("\u010a\u010d\u0110\u0114\u011a\u012b\u0137\u0140\u014c")
        buf.write("\u0158\u0163\u0168\u0171\u017b\u0180\u0185\u018a\u018e")
        buf.write("\u0196\u019e\u01a7\u01ab\u01b2\u01b8\u01c5\u01ce\u01f9")
        buf.write("\u0202\u0218\u021e\u0223\u0227\u022c\u0233\u023a\u0249")
        buf.write("\u025a\u0262\u0266\u0272\u027c\u0285\u0295\u02ad\u02b1")
        buf.write("\u02b6")
        return buf.getvalue()


class kismetParser ( Parser ):

    grammarFileName = "kismet.ebnv"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'pattern'", "'('", "','", "')'", "':'", 
                     "'.'", "'opposes'", "'/'", "'default'", "'trait'", 
                     "'status'", "'scalar'", "'visibility'", "'@'", "'+'", 
                     "'action'", "';'", "'costs'", "'response'", "'result'", 
                     "'location:'", "'?'", "'role'", "'extends'", "'cast'", 
                     "'<'", "'^'", "'*'", "'>'", "'tags'", "'if'", "'does not know'", 
                     "'doesnt know'", "'doesn't know'", "'did'", "'not'", 
                     "'hear'", "'didnt'", "'didn't'", "'see'", "'do'", "'receive'", 
                     "'forgets'", "'forgot'", "'forget'", "'knows'", "'hears'", 
                     "'heard'", "'saw'", "'received'", "''s'", "'s'", "'do not'", 
                     "'dont'", "'don't'", "'does not'", "'doesn't'", "'doesnt'", 
                     "'and'", "'each'", "'other'", "'eachother'", "'have'", 
                     "'has'", "'is'", "'to'", "'with'", "'is missing'", 
                     "'is not'", "'isn't'", "'isnt'", "'aint'", "'missing'", 
                     "'location'", "'initialization'", "'each_turn'", "'name'", 
                     "'supports'", "'='", "'=='", "'<='", "'>='", "'!='", 
                     "'['", "']'", "'_'", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "'-'" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "MINUS", "PLUS", 
                      "RANDOM_TEXT", "WS", "LINE_COMMENT", "NUMBER", "POSITIVE_NUMBER", 
                      "NEG", "NAME", "VAR" ]

    RULE_world = 0
    RULE_pattern = 1
    RULE_opposition = 2
    RULE_trait = 3
    RULE_default = 4
    RULE_trait_type = 5
    RULE_is_num = 6
    RULE_propensity = 7
    RULE_propensity_name = 8
    RULE_modifier = 9
    RULE_goto = 10
    RULE_valence = 11
    RULE_action = 12
    RULE_cost = 13
    RULE_response = 14
    RULE_add = 15
    RULE_change = 16
    RULE_visibility = 17
    RULE_action_location = 18
    RULE_loc = 19
    RULE_locWildCard = 20
    RULE_action_item = 21
    RULE_role = 22
    RULE_extension = 23
    RULE_cast_name = 24
    RULE_arg = 25
    RULE_sub = 26
    RULE_arg_type = 27
    RULE_tags = 28
    RULE_comparison = 29
    RULE_knowledge = 30
    RULE_condition = 31
    RULE_cond3 = 32
    RULE_cond1 = 33
    RULE_cond4 = 34
    RULE_inversion = 35
    RULE_cond5 = 36
    RULE_cond6 = 37
    RULE_cond7 = 38
    RULE_condpattern = 39
    RULE_tag_compare = 40
    RULE_operator = 41
    RULE_location = 42
    RULE_initialization = 43
    RULE_each_turn = 44
    RULE_cast = 45
    RULE_random_text = 46
    RULE_l_name = 47
    RULE_supports = 48
    RULE_num = 49
    RULE_pos_num = 50
    RULE_name = 51
    RULE_var = 52
    RULE_comparator = 53
    RULE_num_choice = 54
    RULE_pdf = 55

    ruleNames =  [ "world", "pattern", "opposition", "trait", "default", 
                   "trait_type", "is_num", "propensity", "propensity_name", 
                   "modifier", "goto", "valence", "action", "cost", "response", 
                   "add", "change", "visibility", "action_location", "loc", 
                   "locWildCard", "action_item", "role", "extension", "cast_name", 
                   "arg", "sub", "arg_type", "tags", "comparison", "knowledge", 
                   "condition", "cond3", "cond1", "cond4", "inversion", 
                   "cond5", "cond6", "cond7", "condpattern", "tag_compare", 
                   "operator", "location", "initialization", "each_turn", 
                   "cast", "random_text", "l_name", "supports", "num", "pos_num", 
                   "name", "var", "comparator", "num_choice", "pdf" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    T__2=3
    T__3=4
    T__4=5
    T__5=6
    T__6=7
    T__7=8
    T__8=9
    T__9=10
    T__10=11
    T__11=12
    T__12=13
    T__13=14
    T__14=15
    T__15=16
    T__16=17
    T__17=18
    T__18=19
    T__19=20
    T__20=21
    T__21=22
    T__22=23
    T__23=24
    T__24=25
    T__25=26
    T__26=27
    T__27=28
    T__28=29
    T__29=30
    T__30=31
    T__31=32
    T__32=33
    T__33=34
    T__34=35
    T__35=36
    T__36=37
    T__37=38
    T__38=39
    T__39=40
    T__40=41
    T__41=42
    T__42=43
    T__43=44
    T__44=45
    T__45=46
    T__46=47
    T__47=48
    T__48=49
    T__49=50
    T__50=51
    T__51=52
    T__52=53
    T__53=54
    T__54=55
    T__55=56
    T__56=57
    T__57=58
    T__58=59
    T__59=60
    T__60=61
    T__61=62
    T__62=63
    T__63=64
    T__64=65
    T__65=66
    T__66=67
    T__67=68
    T__68=69
    T__69=70
    T__70=71
    T__71=72
    T__72=73
    T__73=74
    T__74=75
    T__75=76
    T__76=77
    T__77=78
    T__78=79
    T__79=80
    T__80=81
    T__81=82
    T__82=83
    T__83=84
    T__84=85
    T__85=86
    MINUS=87
    PLUS=88
    RANDOM_TEXT=89
    WS=90
    LINE_COMMENT=91
    NUMBER=92
    POSITIVE_NUMBER=93
    NEG=94
    NAME=95
    VAR=96

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.7.2")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class WorldContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOF(self):
            return self.getToken(kismetParser.EOF, 0)

        def location(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.LocationContext)
            else:
                return self.getTypedRuleContext(kismetParser.LocationContext,i)


        def role(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.RoleContext)
            else:
                return self.getTypedRuleContext(kismetParser.RoleContext,i)


        def action(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.ActionContext)
            else:
                return self.getTypedRuleContext(kismetParser.ActionContext,i)


        def trait(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.TraitContext)
            else:
                return self.getTypedRuleContext(kismetParser.TraitContext,i)


        def pattern(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.PatternContext)
            else:
                return self.getTypedRuleContext(kismetParser.PatternContext,i)


        def getRuleIndex(self):
            return kismetParser.RULE_world

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWorld" ):
                listener.enterWorld(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWorld" ):
                listener.exitWorld(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWorld" ):
                return visitor.visitWorld(self)
            else:
                return visitor.visitChildren(self)




    def world(self):

        localctx = kismetParser.WorldContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_world)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 117 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 117
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [kismetParser.T__73]:
                    self.state = 112
                    self.location()
                    pass
                elif token in [kismetParser.T__22]:
                    self.state = 113
                    self.role()
                    pass
                elif token in [kismetParser.T__15, kismetParser.T__18]:
                    self.state = 114
                    self.action()
                    pass
                elif token in [kismetParser.T__8, kismetParser.T__9, kismetParser.T__10]:
                    self.state = 115
                    self.trait()
                    pass
                elif token in [kismetParser.T__0]:
                    self.state = 116
                    self.pattern()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 119 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << kismetParser.T__0) | (1 << kismetParser.T__8) | (1 << kismetParser.T__9) | (1 << kismetParser.T__10) | (1 << kismetParser.T__15) | (1 << kismetParser.T__18) | (1 << kismetParser.T__22))) != 0) or _la==kismetParser.T__73):
                    break

            self.state = 121
            self.match(kismetParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PatternContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def name(self):
            return self.getTypedRuleContext(kismetParser.NameContext,0)


        def arg(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.ArgContext)
            else:
                return self.getTypedRuleContext(kismetParser.ArgContext,i)


        def comparison(self):
            return self.getTypedRuleContext(kismetParser.ComparisonContext,0)


        def random_text(self):
            return self.getTypedRuleContext(kismetParser.Random_textContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_pattern

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPattern" ):
                listener.enterPattern(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPattern" ):
                listener.exitPattern(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPattern" ):
                return visitor.visitPattern(self)
            else:
                return visitor.visitChildren(self)




    def pattern(self):

        localctx = kismetParser.PatternContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_pattern)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 123
            self.match(kismetParser.T__0)
            self.state = 124
            self.name()
            self.state = 125
            self.match(kismetParser.T__1)
            self.state = 126
            self.arg()
            self.state = 131
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__2:
                self.state = 127
                self.match(kismetParser.T__2)
                self.state = 128
                self.arg()
                self.state = 133
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 134
            self.match(kismetParser.T__3)
            self.state = 136
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==kismetParser.RANDOM_TEXT:
                self.state = 135
                self.random_text()


            self.state = 138
            self.match(kismetParser.T__4)
            self.state = 139
            self.comparison()
            self.state = 140
            self.match(kismetParser.T__5)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OppositionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.NameContext)
            else:
                return self.getTypedRuleContext(kismetParser.NameContext,i)


        def getRuleIndex(self):
            return kismetParser.RULE_opposition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOpposition" ):
                listener.enterOpposition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOpposition" ):
                listener.exitOpposition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOpposition" ):
                return visitor.visitOpposition(self)
            else:
                return visitor.visitChildren(self)




    def opposition(self):

        localctx = kismetParser.OppositionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_opposition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 142
            self.match(kismetParser.T__6)
            self.state = 143
            self.name()
            self.state = 148
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__7:
                self.state = 144
                self.match(kismetParser.T__7)
                self.state = 145
                self.name()
                self.state = 150
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraitContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def trait_type(self):
            return self.getTypedRuleContext(kismetParser.Trait_typeContext,0)


        def name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.NameContext)
            else:
                return self.getTypedRuleContext(kismetParser.NameContext,i)


        def arg(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.ArgContext)
            else:
                return self.getTypedRuleContext(kismetParser.ArgContext,i)


        def default(self):
            return self.getTypedRuleContext(kismetParser.DefaultContext,0)


        def is_num(self):
            return self.getTypedRuleContext(kismetParser.Is_numContext,0)


        def opposition(self):
            return self.getTypedRuleContext(kismetParser.OppositionContext,0)


        def propensity(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.PropensityContext)
            else:
                return self.getTypedRuleContext(kismetParser.PropensityContext,i)


        def getRuleIndex(self):
            return kismetParser.RULE_trait

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTrait" ):
                listener.enterTrait(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTrait" ):
                listener.exitTrait(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTrait" ):
                return visitor.visitTrait(self)
            else:
                return visitor.visitChildren(self)




    def trait(self):

        localctx = kismetParser.TraitContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_trait)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 152
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==kismetParser.T__8:
                self.state = 151
                self.default()


            self.state = 154
            self.trait_type()
            self.state = 156
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==kismetParser.T__11:
                self.state = 155
                self.is_num()


            self.state = 158
            self.name()
            self.state = 163
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__7:
                self.state = 159
                self.match(kismetParser.T__7)
                self.state = 160
                self.name()
                self.state = 165
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 166
            self.match(kismetParser.T__1)
            self.state = 167
            self.arg()
            self.state = 172
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__2:
                self.state = 168
                self.match(kismetParser.T__2)
                self.state = 169
                self.arg()
                self.state = 174
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 175
            self.match(kismetParser.T__3)
            self.state = 177
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==kismetParser.T__6:
                self.state = 176
                self.opposition()


            self.state = 179
            self.match(kismetParser.T__4)
            self.state = 181
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==kismetParser.T__14 or _la==kismetParser.NEG:
                self.state = 180
                self.propensity()


            self.state = 187
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__2:
                self.state = 183
                self.match(kismetParser.T__2)
                self.state = 184
                self.propensity()
                self.state = 189
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 190
            self.match(kismetParser.T__5)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DefaultContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return kismetParser.RULE_default

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDefault" ):
                listener.enterDefault(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDefault" ):
                listener.exitDefault(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDefault" ):
                return visitor.visitDefault(self)
            else:
                return visitor.visitChildren(self)




    def default(self):

        localctx = kismetParser.DefaultContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_default)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 192
            self.match(kismetParser.T__8)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Trait_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return kismetParser.RULE_trait_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTrait_type" ):
                listener.enterTrait_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTrait_type" ):
                listener.exitTrait_type(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTrait_type" ):
                return visitor.visitTrait_type(self)
            else:
                return visitor.visitChildren(self)




    def trait_type(self):

        localctx = kismetParser.Trait_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_trait_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 194
            _la = self._input.LA(1)
            if not(_la==kismetParser.T__9 or _la==kismetParser.T__10):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Is_numContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return kismetParser.RULE_is_num

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIs_num" ):
                listener.enterIs_num(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIs_num" ):
                listener.exitIs_num(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIs_num" ):
                return visitor.visitIs_num(self)
            else:
                return visitor.visitChildren(self)




    def is_num(self):

        localctx = kismetParser.Is_numContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_is_num)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 196
            self.match(kismetParser.T__11)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PropensityContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def modifier(self):
            return self.getTypedRuleContext(kismetParser.ModifierContext,0)


        def goto(self):
            return self.getTypedRuleContext(kismetParser.GotoContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_propensity

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPropensity" ):
                listener.enterPropensity(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPropensity" ):
                listener.exitPropensity(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPropensity" ):
                return visitor.visitPropensity(self)
            else:
                return visitor.visitChildren(self)




    def propensity(self):

        localctx = kismetParser.PropensityContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_propensity)
        try:
            self.state = 200
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,12,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 198
                self.modifier()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 199
                self.goto()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Propensity_nameContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def name(self):
            return self.getTypedRuleContext(kismetParser.NameContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_propensity_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPropensity_name" ):
                listener.enterPropensity_name(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPropensity_name" ):
                listener.exitPropensity_name(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPropensity_name" ):
                return visitor.visitPropensity_name(self)
            else:
                return visitor.visitChildren(self)




    def propensity_name(self):

        localctx = kismetParser.Propensity_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_propensity_name)
        try:
            self.state = 204
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [kismetParser.T__12]:
                self.enterOuterAlt(localctx, 1)
                self.state = 202
                self.match(kismetParser.T__12)
                pass
            elif token in [kismetParser.NAME]:
                self.enterOuterAlt(localctx, 2)
                self.state = 203
                self.name()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ModifierContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def valence(self):
            return self.getTypedRuleContext(kismetParser.ValenceContext,0)


        def propensity_name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.Propensity_nameContext)
            else:
                return self.getTypedRuleContext(kismetParser.Propensity_nameContext,i)


        def comparison(self):
            return self.getTypedRuleContext(kismetParser.ComparisonContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_modifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterModifier" ):
                listener.enterModifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitModifier" ):
                listener.exitModifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitModifier" ):
                return visitor.visitModifier(self)
            else:
                return visitor.visitChildren(self)




    def modifier(self):

        localctx = kismetParser.ModifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_modifier)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 206
            self.valence()
            self.state = 207
            self.match(kismetParser.T__1)
            self.state = 208
            self.propensity_name()
            self.state = 213
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__2:
                self.state = 209
                self.match(kismetParser.T__2)
                self.state = 210
                self.propensity_name()
                self.state = 215
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 217
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==kismetParser.T__30:
                self.state = 216
                self.comparison()


            self.state = 219
            self.match(kismetParser.T__3)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GotoContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def valence(self):
            return self.getTypedRuleContext(kismetParser.ValenceContext,0)


        def name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.NameContext)
            else:
                return self.getTypedRuleContext(kismetParser.NameContext,i)


        def comparison(self):
            return self.getTypedRuleContext(kismetParser.ComparisonContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_goto

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGoto" ):
                listener.enterGoto(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGoto" ):
                listener.exitGoto(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGoto" ):
                return visitor.visitGoto(self)
            else:
                return visitor.visitChildren(self)




    def goto(self):

        localctx = kismetParser.GotoContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_goto)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 221
            self.valence()
            self.state = 222
            self.match(kismetParser.T__13)
            self.state = 223
            self.name()
            self.state = 228
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__2:
                self.state = 224
                self.match(kismetParser.T__2)
                self.state = 225
                self.name()
                self.state = 230
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 232
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==kismetParser.T__30:
                self.state = 231
                self.comparison()


            self.state = 234
            self.match(kismetParser.T__13)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ValenceContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NEG(self, i:int=None):
            if i is None:
                return self.getTokens(kismetParser.NEG)
            else:
                return self.getToken(kismetParser.NEG, i)

        def getRuleIndex(self):
            return kismetParser.RULE_valence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterValence" ):
                listener.enterValence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitValence" ):
                listener.exitValence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitValence" ):
                return visitor.visitValence(self)
            else:
                return visitor.visitChildren(self)




    def valence(self):

        localctx = kismetParser.ValenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_valence)
        self._la = 0 # Token type
        try:
            self.state = 246
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [kismetParser.T__14]:
                self.enterOuterAlt(localctx, 1)
                self.state = 237 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 236
                    self.match(kismetParser.T__14)
                    self.state = 239 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==kismetParser.T__14):
                        break

                pass
            elif token in [kismetParser.NEG]:
                self.enterOuterAlt(localctx, 2)
                self.state = 242 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 241
                    self.match(kismetParser.NEG)
                    self.state = 244 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==kismetParser.NEG):
                        break

                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ActionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def name(self):
            return self.getTypedRuleContext(kismetParser.NameContext,0)


        def arg(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.ArgContext)
            else:
                return self.getTypedRuleContext(kismetParser.ArgContext,i)


        def response(self):
            return self.getTypedRuleContext(kismetParser.ResponseContext,0)


        def cost(self):
            return self.getTypedRuleContext(kismetParser.CostContext,0)


        def extension(self):
            return self.getTypedRuleContext(kismetParser.ExtensionContext,0)


        def random_text(self):
            return self.getTypedRuleContext(kismetParser.Random_textContext,0)


        def action_item(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.Action_itemContext)
            else:
                return self.getTypedRuleContext(kismetParser.Action_itemContext,i)


        def getRuleIndex(self):
            return kismetParser.RULE_action

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAction" ):
                listener.enterAction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAction" ):
                listener.exitAction(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAction" ):
                return visitor.visitAction(self)
            else:
                return visitor.visitChildren(self)




    def action(self):

        localctx = kismetParser.ActionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_action)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 249
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==kismetParser.T__18:
                self.state = 248
                self.response()


            self.state = 251
            self.match(kismetParser.T__15)
            self.state = 252
            self.name()
            self.state = 253
            self.match(kismetParser.T__1)
            self.state = 254
            self.arg()
            self.state = 259
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__2:
                self.state = 255
                self.match(kismetParser.T__2)
                self.state = 256
                self.arg()
                self.state = 261
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 262
            self.match(kismetParser.T__3)
            self.state = 264
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==kismetParser.T__17:
                self.state = 263
                self.cost()


            self.state = 267
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==kismetParser.T__23:
                self.state = 266
                self.extension()


            self.state = 270
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==kismetParser.RANDOM_TEXT:
                self.state = 269
                self.random_text()


            self.state = 272
            self.match(kismetParser.T__4)
            self.state = 274
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << kismetParser.T__12) | (1 << kismetParser.T__19) | (1 << kismetParser.T__20) | (1 << kismetParser.T__29) | (1 << kismetParser.T__30))) != 0):
                self.state = 273
                self.action_item()


            self.state = 280
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__16:
                self.state = 276
                self.match(kismetParser.T__16)

                self.state = 277
                self.action_item()
                self.state = 282
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 283
            self.match(kismetParser.T__5)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CostContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def num(self):
            return self.getTypedRuleContext(kismetParser.NumContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_cost

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCost" ):
                listener.enterCost(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCost" ):
                listener.exitCost(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCost" ):
                return visitor.visitCost(self)
            else:
                return visitor.visitChildren(self)




    def cost(self):

        localctx = kismetParser.CostContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_cost)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 285
            self.match(kismetParser.T__17)
            self.state = 286
            self.num()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ResponseContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return kismetParser.RULE_response

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterResponse" ):
                listener.enterResponse(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitResponse" ):
                listener.exitResponse(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitResponse" ):
                return visitor.visitResponse(self)
            else:
                return visitor.visitChildren(self)




    def response(self):

        localctx = kismetParser.ResponseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_response)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 288
            self.match(kismetParser.T__18)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AddContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def change(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.ChangeContext)
            else:
                return self.getTypedRuleContext(kismetParser.ChangeContext,i)


        def getRuleIndex(self):
            return kismetParser.RULE_add

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAdd" ):
                listener.enterAdd(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAdd" ):
                listener.exitAdd(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAdd" ):
                return visitor.visitAdd(self)
            else:
                return visitor.visitChildren(self)




    def add(self):

        localctx = kismetParser.AddContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_add)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 290
            self.match(kismetParser.T__19)
            self.state = 291
            self.match(kismetParser.T__4)
            self.state = 292
            self.change()
            self.state = 297
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__2:
                self.state = 293
                self.match(kismetParser.T__2)
                self.state = 294
                self.change()
                self.state = 299
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ChangeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def condition(self):
            return self.getTypedRuleContext(kismetParser.ConditionContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_change

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterChange" ):
                listener.enterChange(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitChange" ):
                listener.exitChange(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitChange" ):
                return visitor.visitChange(self)
            else:
                return visitor.visitChildren(self)




    def change(self):

        localctx = kismetParser.ChangeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_change)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 300
            self.condition()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VisibilityContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def valence(self):
            return self.getTypedRuleContext(kismetParser.ValenceContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_visibility

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVisibility" ):
                listener.enterVisibility(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVisibility" ):
                listener.exitVisibility(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVisibility" ):
                return visitor.visitVisibility(self)
            else:
                return visitor.visitChildren(self)




    def visibility(self):

        localctx = kismetParser.VisibilityContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_visibility)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 302
            self.match(kismetParser.T__12)
            self.state = 303
            self.valence()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Action_locationContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def loc(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.LocContext)
            else:
                return self.getTypedRuleContext(kismetParser.LocContext,i)


        def getRuleIndex(self):
            return kismetParser.RULE_action_location

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAction_location" ):
                listener.enterAction_location(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAction_location" ):
                listener.exitAction_location(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAction_location" ):
                return visitor.visitAction_location(self)
            else:
                return visitor.visitChildren(self)




    def action_location(self):

        localctx = kismetParser.Action_locationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_action_location)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 305
            self.match(kismetParser.T__20)
            self.state = 307 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 306
                self.loc()
                self.state = 309 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==kismetParser.T__1 or _la==kismetParser.T__21 or _la==kismetParser.NAME or _la==kismetParser.VAR):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LocContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def var(self):
            return self.getTypedRuleContext(kismetParser.VarContext,0)


        def arg(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.ArgContext)
            else:
                return self.getTypedRuleContext(kismetParser.ArgContext,i)


        def name(self):
            return self.getTypedRuleContext(kismetParser.NameContext,0)


        def locWildCard(self):
            return self.getTypedRuleContext(kismetParser.LocWildCardContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_loc

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLoc" ):
                listener.enterLoc(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLoc" ):
                listener.exitLoc(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLoc" ):
                return visitor.visitLoc(self)
            else:
                return visitor.visitChildren(self)




    def loc(self):

        localctx = kismetParser.LocContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_loc)
        self._la = 0 # Token type
        try:
            self.state = 358
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [kismetParser.VAR]:
                self.enterOuterAlt(localctx, 1)
                self.state = 311
                self.var()
                self.state = 312
                self.match(kismetParser.T__1)
                self.state = 313
                self.arg()
                self.state = 318
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==kismetParser.T__2:
                    self.state = 314
                    self.match(kismetParser.T__2)
                    self.state = 315
                    self.arg()
                    self.state = 320
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 321
                self.match(kismetParser.T__3)
                pass
            elif token in [kismetParser.NAME]:
                self.enterOuterAlt(localctx, 2)
                self.state = 323
                self.name()
                self.state = 324
                self.match(kismetParser.T__1)
                self.state = 325
                self.arg()
                self.state = 330
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==kismetParser.T__2:
                    self.state = 326
                    self.match(kismetParser.T__2)
                    self.state = 327
                    self.arg()
                    self.state = 332
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 333
                self.match(kismetParser.T__3)
                pass
            elif token in [kismetParser.T__21]:
                self.enterOuterAlt(localctx, 3)
                self.state = 335
                self.locWildCard()
                self.state = 336
                self.match(kismetParser.T__1)
                self.state = 337
                self.arg()
                self.state = 342
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==kismetParser.T__2:
                    self.state = 338
                    self.match(kismetParser.T__2)
                    self.state = 339
                    self.arg()
                    self.state = 344
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 345
                self.match(kismetParser.T__3)
                pass
            elif token in [kismetParser.T__1]:
                self.enterOuterAlt(localctx, 4)
                self.state = 347
                self.match(kismetParser.T__1)
                self.state = 348
                self.arg()
                self.state = 353
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==kismetParser.T__2:
                    self.state = 349
                    self.match(kismetParser.T__2)
                    self.state = 350
                    self.arg()
                    self.state = 355
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 356
                self.match(kismetParser.T__3)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LocWildCardContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return kismetParser.RULE_locWildCard

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLocWildCard" ):
                listener.enterLocWildCard(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLocWildCard" ):
                listener.exitLocWildCard(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLocWildCard" ):
                return visitor.visitLocWildCard(self)
            else:
                return visitor.visitChildren(self)




    def locWildCard(self):

        localctx = kismetParser.LocWildCardContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_locWildCard)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 360
            self.match(kismetParser.T__21)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Action_itemContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def tags(self):
            return self.getTypedRuleContext(kismetParser.TagsContext,0)


        def comparison(self):
            return self.getTypedRuleContext(kismetParser.ComparisonContext,0)


        def action_location(self):
            return self.getTypedRuleContext(kismetParser.Action_locationContext,0)


        def add(self):
            return self.getTypedRuleContext(kismetParser.AddContext,0)


        def visibility(self):
            return self.getTypedRuleContext(kismetParser.VisibilityContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_action_item

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAction_item" ):
                listener.enterAction_item(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAction_item" ):
                listener.exitAction_item(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAction_item" ):
                return visitor.visitAction_item(self)
            else:
                return visitor.visitChildren(self)




    def action_item(self):

        localctx = kismetParser.Action_itemContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_action_item)
        try:
            self.state = 367
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [kismetParser.T__29]:
                self.enterOuterAlt(localctx, 1)
                self.state = 362
                self.tags()
                pass
            elif token in [kismetParser.T__30]:
                self.enterOuterAlt(localctx, 2)
                self.state = 363
                self.comparison()
                pass
            elif token in [kismetParser.T__20]:
                self.enterOuterAlt(localctx, 3)
                self.state = 364
                self.action_location()
                pass
            elif token in [kismetParser.T__19]:
                self.enterOuterAlt(localctx, 4)
                self.state = 365
                self.add()
                pass
            elif token in [kismetParser.T__12]:
                self.enterOuterAlt(localctx, 5)
                self.state = 366
                self.visibility()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RoleContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def name(self):
            return self.getTypedRuleContext(kismetParser.NameContext,0)


        def arg(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.ArgContext)
            else:
                return self.getTypedRuleContext(kismetParser.ArgContext,i)


        def tags(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.TagsContext)
            else:
                return self.getTypedRuleContext(kismetParser.TagsContext,i)


        def comparison(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.ComparisonContext)
            else:
                return self.getTypedRuleContext(kismetParser.ComparisonContext,i)


        def extension(self):
            return self.getTypedRuleContext(kismetParser.ExtensionContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_role

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRole" ):
                listener.enterRole(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRole" ):
                listener.exitRole(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRole" ):
                return visitor.visitRole(self)
            else:
                return visitor.visitChildren(self)




    def role(self):

        localctx = kismetParser.RoleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_role)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 369
            self.match(kismetParser.T__22)
            self.state = 370
            self.name()
            self.state = 371
            self.match(kismetParser.T__1)
            self.state = 372
            self.arg()
            self.state = 377
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__2:
                self.state = 373
                self.match(kismetParser.T__2)
                self.state = 374
                self.arg()
                self.state = 379
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 380
            self.match(kismetParser.T__3)
            self.state = 382
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==kismetParser.T__23:
                self.state = 381
                self.extension()


            self.state = 384
            self.match(kismetParser.T__4)
            self.state = 387
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [kismetParser.T__29]:
                self.state = 385
                self.tags()
                pass
            elif token in [kismetParser.T__30]:
                self.state = 386
                self.comparison()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 396
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__16:
                self.state = 389
                self.match(kismetParser.T__16)
                self.state = 392
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [kismetParser.T__29]:
                    self.state = 390
                    self.tags()
                    pass
                elif token in [kismetParser.T__30]:
                    self.state = 391
                    self.comparison()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 398
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 399
            self.match(kismetParser.T__5)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExtensionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def arg(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.ArgContext)
            else:
                return self.getTypedRuleContext(kismetParser.ArgContext,i)


        def cast_name(self):
            return self.getTypedRuleContext(kismetParser.Cast_nameContext,0)


        def name(self):
            return self.getTypedRuleContext(kismetParser.NameContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_extension

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExtension" ):
                listener.enterExtension(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExtension" ):
                listener.exitExtension(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExtension" ):
                return visitor.visitExtension(self)
            else:
                return visitor.visitChildren(self)




    def extension(self):

        localctx = kismetParser.ExtensionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_extension)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 401
            self.match(kismetParser.T__23)
            self.state = 404
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [kismetParser.T__24]:
                self.state = 402
                self.cast_name()
                pass
            elif token in [kismetParser.NAME]:
                self.state = 403
                self.name()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 406
            self.match(kismetParser.T__1)
            self.state = 407
            self.arg()
            self.state = 412
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__2:
                self.state = 408
                self.match(kismetParser.T__2)
                self.state = 409
                self.arg()
                self.state = 414
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 415
            self.match(kismetParser.T__3)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Cast_nameContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def name(self):
            return self.getTypedRuleContext(kismetParser.NameContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_cast_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCast_name" ):
                listener.enterCast_name(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCast_name" ):
                listener.exitCast_name(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCast_name" ):
                return visitor.visitCast_name(self)
            else:
                return visitor.visitChildren(self)




    def cast_name(self):

        localctx = kismetParser.Cast_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_cast_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 417
            self.match(kismetParser.T__24)
            self.state = 418
            self.name()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ArgContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def var(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.VarContext)
            else:
                return self.getTypedRuleContext(kismetParser.VarContext,i)


        def arg_type(self):
            return self.getTypedRuleContext(kismetParser.Arg_typeContext,0)


        def sub(self):
            return self.getTypedRuleContext(kismetParser.SubContext,0)


        def name(self):
            return self.getTypedRuleContext(kismetParser.NameContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_arg

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArg" ):
                listener.enterArg(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArg" ):
                listener.exitArg(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitArg" ):
                return visitor.visitArg(self)
            else:
                return visitor.visitChildren(self)




    def arg(self):

        localctx = kismetParser.ArgContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_arg)
        self._la = 0 # Token type
        try:
            self.state = 438
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,46,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 421
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << kismetParser.T__13) | (1 << kismetParser.T__25) | (1 << kismetParser.T__26) | (1 << kismetParser.T__27) | (1 << kismetParser.T__28))) != 0):
                    self.state = 420
                    self.arg_type()


                self.state = 423
                self.var()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 425
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << kismetParser.T__13) | (1 << kismetParser.T__25) | (1 << kismetParser.T__26) | (1 << kismetParser.T__27) | (1 << kismetParser.T__28))) != 0):
                    self.state = 424
                    self.arg_type()


                self.state = 427
                self.var()
                self.state = 428
                self.sub()
                self.state = 429
                self.name()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 432
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << kismetParser.T__13) | (1 << kismetParser.T__25) | (1 << kismetParser.T__26) | (1 << kismetParser.T__27) | (1 << kismetParser.T__28))) != 0):
                    self.state = 431
                    self.arg_type()


                self.state = 434
                self.var()
                self.state = 435
                self.sub()
                self.state = 436
                self.var()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SubContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return kismetParser.RULE_sub

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSub" ):
                listener.enterSub(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSub" ):
                listener.exitSub(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSub" ):
                return visitor.visitSub(self)
            else:
                return visitor.visitChildren(self)




    def sub(self):

        localctx = kismetParser.SubContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_sub)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 440
            _la = self._input.LA(1)
            if not(_la==kismetParser.T__4 or _la==kismetParser.T__5):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Arg_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return kismetParser.RULE_arg_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArg_type" ):
                listener.enterArg_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArg_type" ):
                listener.exitArg_type(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitArg_type" ):
                return visitor.visitArg_type(self)
            else:
                return visitor.visitChildren(self)




    def arg_type(self):

        localctx = kismetParser.Arg_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_arg_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 442
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << kismetParser.T__13) | (1 << kismetParser.T__25) | (1 << kismetParser.T__26) | (1 << kismetParser.T__27) | (1 << kismetParser.T__28))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TagsContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.NameContext)
            else:
                return self.getTypedRuleContext(kismetParser.NameContext,i)


        def getRuleIndex(self):
            return kismetParser.RULE_tags

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTags" ):
                listener.enterTags(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTags" ):
                listener.exitTags(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTags" ):
                return visitor.visitTags(self)
            else:
                return visitor.visitChildren(self)




    def tags(self):

        localctx = kismetParser.TagsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_tags)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 444
            self.match(kismetParser.T__29)
            self.state = 445
            self.match(kismetParser.T__4)
            self.state = 446
            self.name()
            self.state = 451
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__2:
                self.state = 447
                self.match(kismetParser.T__2)
                self.state = 448
                self.name()
                self.state = 453
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ComparisonContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def condition(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.ConditionContext)
            else:
                return self.getTypedRuleContext(kismetParser.ConditionContext,i)


        def getRuleIndex(self):
            return kismetParser.RULE_comparison

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterComparison" ):
                listener.enterComparison(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitComparison" ):
                listener.exitComparison(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitComparison" ):
                return visitor.visitComparison(self)
            else:
                return visitor.visitChildren(self)




    def comparison(self):

        localctx = kismetParser.ComparisonContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_comparison)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 454
            self.match(kismetParser.T__30)
            self.state = 455
            self.condition()
            self.state = 460
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__2:
                self.state = 456
                self.match(kismetParser.T__2)
                self.state = 457
                self.condition()
                self.state = 462
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class KnowledgeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return kismetParser.RULE_knowledge

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterKnowledge" ):
                listener.enterKnowledge(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitKnowledge" ):
                listener.exitKnowledge(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitKnowledge" ):
                return visitor.visitKnowledge(self)
            else:
                return visitor.visitChildren(self)




    def knowledge(self):

        localctx = kismetParser.KnowledgeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_knowledge)
        try:
            self.state = 503
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,49,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 463
                self.match(kismetParser.T__31)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 464
                self.match(kismetParser.T__32)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 465
                self.match(kismetParser.T__33)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 466
                self.match(kismetParser.T__34)
                self.state = 467
                self.match(kismetParser.T__35)
                self.state = 468
                self.match(kismetParser.T__36)
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 469
                self.match(kismetParser.T__37)
                self.state = 470
                self.match(kismetParser.T__36)
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 471
                self.match(kismetParser.T__38)
                self.state = 472
                self.match(kismetParser.T__36)
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 473
                self.match(kismetParser.T__34)
                self.state = 474
                self.match(kismetParser.T__35)
                self.state = 475
                self.match(kismetParser.T__39)
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 476
                self.match(kismetParser.T__37)
                self.state = 477
                self.match(kismetParser.T__39)
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 478
                self.match(kismetParser.T__38)
                self.state = 479
                self.match(kismetParser.T__39)
                pass

            elif la_ == 10:
                self.enterOuterAlt(localctx, 10)
                self.state = 480
                self.match(kismetParser.T__34)
                self.state = 481
                self.match(kismetParser.T__35)
                self.state = 482
                self.match(kismetParser.T__40)
                pass

            elif la_ == 11:
                self.enterOuterAlt(localctx, 11)
                self.state = 483
                self.match(kismetParser.T__37)
                self.state = 484
                self.match(kismetParser.T__40)
                pass

            elif la_ == 12:
                self.enterOuterAlt(localctx, 12)
                self.state = 485
                self.match(kismetParser.T__38)
                self.state = 486
                self.match(kismetParser.T__40)
                pass

            elif la_ == 13:
                self.enterOuterAlt(localctx, 13)
                self.state = 487
                self.match(kismetParser.T__34)
                self.state = 488
                self.match(kismetParser.T__35)
                self.state = 489
                self.match(kismetParser.T__41)
                pass

            elif la_ == 14:
                self.enterOuterAlt(localctx, 14)
                self.state = 490
                self.match(kismetParser.T__37)
                self.state = 491
                self.match(kismetParser.T__41)
                pass

            elif la_ == 15:
                self.enterOuterAlt(localctx, 15)
                self.state = 492
                self.match(kismetParser.T__38)
                self.state = 493
                self.match(kismetParser.T__41)
                pass

            elif la_ == 16:
                self.enterOuterAlt(localctx, 16)
                self.state = 494
                self.match(kismetParser.T__42)
                pass

            elif la_ == 17:
                self.enterOuterAlt(localctx, 17)
                self.state = 495
                self.match(kismetParser.T__43)
                pass

            elif la_ == 18:
                self.enterOuterAlt(localctx, 18)
                self.state = 496
                self.match(kismetParser.T__44)
                pass

            elif la_ == 19:
                self.enterOuterAlt(localctx, 19)
                self.state = 497
                self.match(kismetParser.T__45)
                pass

            elif la_ == 20:
                self.enterOuterAlt(localctx, 20)
                self.state = 498
                self.match(kismetParser.T__46)
                pass

            elif la_ == 21:
                self.enterOuterAlt(localctx, 21)
                self.state = 499
                self.match(kismetParser.T__47)
                pass

            elif la_ == 22:
                self.enterOuterAlt(localctx, 22)
                self.state = 500
                self.match(kismetParser.T__48)
                pass

            elif la_ == 23:
                self.enterOuterAlt(localctx, 23)
                self.state = 501
                self.match(kismetParser.T__34)
                pass

            elif la_ == 24:
                self.enterOuterAlt(localctx, 24)
                self.state = 502
                self.match(kismetParser.T__49)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConditionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def cond3(self):
            return self.getTypedRuleContext(kismetParser.Cond3Context,0)


        def cond1(self):
            return self.getTypedRuleContext(kismetParser.Cond1Context,0)


        def cond4(self):
            return self.getTypedRuleContext(kismetParser.Cond4Context,0)


        def cond5(self):
            return self.getTypedRuleContext(kismetParser.Cond5Context,0)


        def cond6(self):
            return self.getTypedRuleContext(kismetParser.Cond6Context,0)


        def cond7(self):
            return self.getTypedRuleContext(kismetParser.Cond7Context,0)


        def condpattern(self):
            return self.getTypedRuleContext(kismetParser.CondpatternContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_condition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCondition" ):
                listener.enterCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCondition" ):
                listener.exitCondition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCondition" ):
                return visitor.visitCondition(self)
            else:
                return visitor.visitChildren(self)




    def condition(self):

        localctx = kismetParser.ConditionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_condition)
        try:
            self.state = 512
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,50,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 505
                self.cond3()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 506
                self.cond1()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 507
                self.cond4()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 508
                self.cond5()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 509
                self.cond6()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 510
                self.cond7()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 511
                self.condpattern()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Cond3Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def arg(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.ArgContext)
            else:
                return self.getTypedRuleContext(kismetParser.ArgContext,i)


        def knowledge(self):
            return self.getTypedRuleContext(kismetParser.KnowledgeContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_cond3

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCond3" ):
                listener.enterCond3(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCond3" ):
                listener.exitCond3(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCond3" ):
                return visitor.visitCond3(self)
            else:
                return visitor.visitChildren(self)




    def cond3(self):

        localctx = kismetParser.Cond3Context(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_cond3)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 514
            self.arg()
            self.state = 515
            self.knowledge()
            self.state = 516
            self.arg()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Cond1Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def arg(self):
            return self.getTypedRuleContext(kismetParser.ArgContext,0)


        def tag_compare(self):
            return self.getTypedRuleContext(kismetParser.Tag_compareContext,0)


        def name(self):
            return self.getTypedRuleContext(kismetParser.NameContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_cond1

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCond1" ):
                listener.enterCond1(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCond1" ):
                listener.exitCond1(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCond1" ):
                return visitor.visitCond1(self)
            else:
                return visitor.visitChildren(self)




    def cond1(self):

        localctx = kismetParser.Cond1Context(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_cond1)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 518
            self.arg()
            self.state = 519
            self.tag_compare()
            self.state = 520
            self.name()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Cond4Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def arg(self):
            return self.getTypedRuleContext(kismetParser.ArgContext,0)


        def name(self):
            return self.getTypedRuleContext(kismetParser.NameContext,0)


        def comparator(self):
            return self.getTypedRuleContext(kismetParser.ComparatorContext,0)


        def num(self):
            return self.getTypedRuleContext(kismetParser.NumContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_cond4

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCond4" ):
                listener.enterCond4(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCond4" ):
                listener.exitCond4(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCond4" ):
                return visitor.visitCond4(self)
            else:
                return visitor.visitChildren(self)




    def cond4(self):

        localctx = kismetParser.Cond4Context(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_cond4)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 522
            self.arg()
            self.state = 523
            _la = self._input.LA(1)
            if not(_la==kismetParser.T__50 or _la==kismetParser.T__51):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 524
            self.name()
            self.state = 525
            self.comparator()
            self.state = 526
            self.num()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InversionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return kismetParser.RULE_inversion

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInversion" ):
                listener.enterInversion(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInversion" ):
                listener.exitInversion(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInversion" ):
                return visitor.visitInversion(self)
            else:
                return visitor.visitChildren(self)




    def inversion(self):

        localctx = kismetParser.InversionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_inversion)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 528
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << kismetParser.T__52) | (1 << kismetParser.T__53) | (1 << kismetParser.T__54) | (1 << kismetParser.T__55) | (1 << kismetParser.T__56) | (1 << kismetParser.T__57))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Cond5Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def arg(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.ArgContext)
            else:
                return self.getTypedRuleContext(kismetParser.ArgContext,i)


        def name(self):
            return self.getTypedRuleContext(kismetParser.NameContext,0)


        def inversion(self):
            return self.getTypedRuleContext(kismetParser.InversionContext,0)


        def operator(self):
            return self.getTypedRuleContext(kismetParser.OperatorContext,0)


        def num(self):
            return self.getTypedRuleContext(kismetParser.NumContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_cond5

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCond5" ):
                listener.enterCond5(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCond5" ):
                listener.exitCond5(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCond5" ):
                return visitor.visitCond5(self)
            else:
                return visitor.visitChildren(self)




    def cond5(self):

        localctx = kismetParser.Cond5Context(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_cond5)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 530
            self.arg()
            self.state = 531
            self.match(kismetParser.T__58)
            self.state = 532
            self.arg()
            self.state = 534
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << kismetParser.T__52) | (1 << kismetParser.T__53) | (1 << kismetParser.T__54) | (1 << kismetParser.T__55) | (1 << kismetParser.T__56) | (1 << kismetParser.T__57))) != 0):
                self.state = 533
                self.inversion()


            self.state = 536
            self.name()
            self.state = 540
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [kismetParser.T__59]:
                self.state = 537
                self.match(kismetParser.T__59)
                self.state = 538
                self.match(kismetParser.T__60)
                pass
            elif token in [kismetParser.T__61]:
                self.state = 539
                self.match(kismetParser.T__61)
                pass
            else:
                raise NoViableAltException(self)

            self.state = 545
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==kismetParser.MINUS or _la==kismetParser.PLUS:
                self.state = 542
                self.operator()
                self.state = 543
                self.num()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Cond6Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def arg(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.ArgContext)
            else:
                return self.getTypedRuleContext(kismetParser.ArgContext,i)


        def name(self):
            return self.getTypedRuleContext(kismetParser.NameContext,0)


        def inversion(self):
            return self.getTypedRuleContext(kismetParser.InversionContext,0)


        def operator(self):
            return self.getTypedRuleContext(kismetParser.OperatorContext,0)


        def num(self):
            return self.getTypedRuleContext(kismetParser.NumContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_cond6

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCond6" ):
                listener.enterCond6(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCond6" ):
                listener.exitCond6(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCond6" ):
                return visitor.visitCond6(self)
            else:
                return visitor.visitChildren(self)




    def cond6(self):

        localctx = kismetParser.Cond6Context(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_cond6)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 547
            self.arg()
            self.state = 549
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << kismetParser.T__52) | (1 << kismetParser.T__53) | (1 << kismetParser.T__54) | (1 << kismetParser.T__55) | (1 << kismetParser.T__56) | (1 << kismetParser.T__57))) != 0):
                self.state = 548
                self.inversion()


            self.state = 554
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((((_la - 63)) & ~0x3f) == 0 and ((1 << (_la - 63)) & ((1 << (kismetParser.T__62 - 63)) | (1 << (kismetParser.T__63 - 63)) | (1 << (kismetParser.T__64 - 63)))) != 0):
                self.state = 551
                _la = self._input.LA(1)
                if not(((((_la - 63)) & ~0x3f) == 0 and ((1 << (_la - 63)) & ((1 << (kismetParser.T__62 - 63)) | (1 << (kismetParser.T__63 - 63)) | (1 << (kismetParser.T__64 - 63)))) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 556
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 557
            self.name()
            self.state = 561
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__65 or _la==kismetParser.T__66:
                self.state = 558
                _la = self._input.LA(1)
                if not(_la==kismetParser.T__65 or _la==kismetParser.T__66):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 563
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 564
            self.arg()
            self.state = 568
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==kismetParser.MINUS or _la==kismetParser.PLUS:
                self.state = 565
                self.operator()
                self.state = 566
                self.num()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Cond7Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def arg(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.ArgContext)
            else:
                return self.getTypedRuleContext(kismetParser.ArgContext,i)


        def name(self):
            return self.getTypedRuleContext(kismetParser.NameContext,0)


        def comparator(self):
            return self.getTypedRuleContext(kismetParser.ComparatorContext,0)


        def num(self):
            return self.getTypedRuleContext(kismetParser.NumContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_cond7

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCond7" ):
                listener.enterCond7(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCond7" ):
                listener.exitCond7(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCond7" ):
                return visitor.visitCond7(self)
            else:
                return visitor.visitChildren(self)




    def cond7(self):

        localctx = kismetParser.Cond7Context(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_cond7)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 570
            self.arg()
            self.state = 571
            self.name()
            self.state = 572
            self.arg()
            self.state = 573
            self.comparator()
            self.state = 574
            self.num()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CondpatternContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def name(self):
            return self.getTypedRuleContext(kismetParser.NameContext,0)


        def arg(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.ArgContext)
            else:
                return self.getTypedRuleContext(kismetParser.ArgContext,i)


        def getRuleIndex(self):
            return kismetParser.RULE_condpattern

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCondpattern" ):
                listener.enterCondpattern(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCondpattern" ):
                listener.exitCondpattern(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCondpattern" ):
                return visitor.visitCondpattern(self)
            else:
                return visitor.visitChildren(self)




    def condpattern(self):

        localctx = kismetParser.CondpatternContext(self, self._ctx, self.state)
        self.enterRule(localctx, 78, self.RULE_condpattern)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 576
            self.match(kismetParser.T__0)
            self.state = 577
            self.match(kismetParser.T__1)
            self.state = 578
            self.name()
            self.state = 583
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__2:
                self.state = 579
                self.match(kismetParser.T__2)
                self.state = 580
                self.arg()
                self.state = 585
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 586
            self.match(kismetParser.T__3)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Tag_compareContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return kismetParser.RULE_tag_compare

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTag_compare" ):
                listener.enterTag_compare(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTag_compare" ):
                listener.exitTag_compare(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTag_compare" ):
                return visitor.visitTag_compare(self)
            else:
                return visitor.visitChildren(self)




    def tag_compare(self):

        localctx = kismetParser.Tag_compareContext(self, self._ctx, self.state)
        self.enterRule(localctx, 80, self.RULE_tag_compare)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 588
            _la = self._input.LA(1)
            if not(((((_la - 65)) & ~0x3f) == 0 and ((1 << (_la - 65)) & ((1 << (kismetParser.T__64 - 65)) | (1 << (kismetParser.T__67 - 65)) | (1 << (kismetParser.T__68 - 65)) | (1 << (kismetParser.T__69 - 65)) | (1 << (kismetParser.T__70 - 65)) | (1 << (kismetParser.T__71 - 65)) | (1 << (kismetParser.T__72 - 65)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OperatorContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MINUS(self):
            return self.getToken(kismetParser.MINUS, 0)

        def PLUS(self):
            return self.getToken(kismetParser.PLUS, 0)

        def getRuleIndex(self):
            return kismetParser.RULE_operator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOperator" ):
                listener.enterOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOperator" ):
                listener.exitOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOperator" ):
                return visitor.visitOperator(self)
            else:
                return visitor.visitChildren(self)




    def operator(self):

        localctx = kismetParser.OperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 82, self.RULE_operator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 590
            _la = self._input.LA(1)
            if not(_la==kismetParser.MINUS or _la==kismetParser.PLUS):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LocationContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def name(self):
            return self.getTypedRuleContext(kismetParser.NameContext,0)


        def l_name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.L_nameContext)
            else:
                return self.getTypedRuleContext(kismetParser.L_nameContext,i)


        def supports(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.SupportsContext)
            else:
                return self.getTypedRuleContext(kismetParser.SupportsContext,i)


        def initialization(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.InitializationContext)
            else:
                return self.getTypedRuleContext(kismetParser.InitializationContext,i)


        def each_turn(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.Each_turnContext)
            else:
                return self.getTypedRuleContext(kismetParser.Each_turnContext,i)


        def tags(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.TagsContext)
            else:
                return self.getTypedRuleContext(kismetParser.TagsContext,i)


        def getRuleIndex(self):
            return kismetParser.RULE_location

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLocation" ):
                listener.enterLocation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLocation" ):
                listener.exitLocation(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLocation" ):
                return visitor.visitLocation(self)
            else:
                return visitor.visitChildren(self)




    def location(self):

        localctx = kismetParser.LocationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 84, self.RULE_location)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 592
            self.match(kismetParser.T__73)
            self.state = 593
            self.name()
            self.state = 594
            self.match(kismetParser.T__4)
            self.state = 600
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [kismetParser.T__76]:
                self.state = 595
                self.l_name()
                pass
            elif token in [kismetParser.T__77]:
                self.state = 596
                self.supports()
                pass
            elif token in [kismetParser.T__74]:
                self.state = 597
                self.initialization()
                pass
            elif token in [kismetParser.T__75]:
                self.state = 598
                self.each_turn()
                pass
            elif token in [kismetParser.T__29]:
                self.state = 599
                self.tags()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 612
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__16:
                self.state = 602
                self.match(kismetParser.T__16)
                self.state = 608
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [kismetParser.T__76]:
                    self.state = 603
                    self.l_name()
                    pass
                elif token in [kismetParser.T__77]:
                    self.state = 604
                    self.supports()
                    pass
                elif token in [kismetParser.T__74]:
                    self.state = 605
                    self.initialization()
                    pass
                elif token in [kismetParser.T__75]:
                    self.state = 606
                    self.each_turn()
                    pass
                elif token in [kismetParser.T__29]:
                    self.state = 607
                    self.tags()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 614
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 615
            self.match(kismetParser.T__5)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InitializationContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def cast(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.CastContext)
            else:
                return self.getTypedRuleContext(kismetParser.CastContext,i)


        def getRuleIndex(self):
            return kismetParser.RULE_initialization

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInitialization" ):
                listener.enterInitialization(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInitialization" ):
                listener.exitInitialization(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInitialization" ):
                return visitor.visitInitialization(self)
            else:
                return visitor.visitChildren(self)




    def initialization(self):

        localctx = kismetParser.InitializationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 86, self.RULE_initialization)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 617
            self.match(kismetParser.T__74)
            self.state = 618
            self.match(kismetParser.T__4)
            self.state = 619
            self.cast()
            self.state = 624
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__2:
                self.state = 620
                self.match(kismetParser.T__2)
                self.state = 621
                self.cast()
                self.state = 626
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Each_turnContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def cast(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.CastContext)
            else:
                return self.getTypedRuleContext(kismetParser.CastContext,i)


        def getRuleIndex(self):
            return kismetParser.RULE_each_turn

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEach_turn" ):
                listener.enterEach_turn(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEach_turn" ):
                listener.exitEach_turn(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEach_turn" ):
                return visitor.visitEach_turn(self)
            else:
                return visitor.visitChildren(self)




    def each_turn(self):

        localctx = kismetParser.Each_turnContext(self, self._ctx, self.state)
        self.enterRule(localctx, 88, self.RULE_each_turn)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 627
            self.match(kismetParser.T__75)
            self.state = 628
            self.match(kismetParser.T__4)
            self.state = 629
            self.cast()
            self.state = 634
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__2:
                self.state = 630
                self.match(kismetParser.T__2)
                self.state = 631
                self.cast()
                self.state = 636
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CastContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def num_choice(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.Num_choiceContext)
            else:
                return self.getTypedRuleContext(kismetParser.Num_choiceContext,i)


        def getRuleIndex(self):
            return kismetParser.RULE_cast

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCast" ):
                listener.enterCast(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCast" ):
                listener.exitCast(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCast" ):
                return visitor.visitCast(self)
            else:
                return visitor.visitChildren(self)




    def cast(self):

        localctx = kismetParser.CastContext(self, self._ctx, self.state)
        self.enterRule(localctx, 90, self.RULE_cast)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 637
            self.match(kismetParser.T__24)
            self.state = 638
            self.num_choice()
            self.state = 643
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,64,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 639
                    self.match(kismetParser.T__2)
                    self.state = 640
                    self.num_choice() 
                self.state = 645
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,64,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Random_textContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RANDOM_TEXT(self):
            return self.getToken(kismetParser.RANDOM_TEXT, 0)

        def getRuleIndex(self):
            return kismetParser.RULE_random_text

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRandom_text" ):
                listener.enterRandom_text(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRandom_text" ):
                listener.exitRandom_text(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRandom_text" ):
                return visitor.visitRandom_text(self)
            else:
                return visitor.visitChildren(self)




    def random_text(self):

        localctx = kismetParser.Random_textContext(self, self._ctx, self.state)
        self.enterRule(localctx, 92, self.RULE_random_text)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 646
            self.match(kismetParser.RANDOM_TEXT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class L_nameContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def random_text(self):
            return self.getTypedRuleContext(kismetParser.Random_textContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_l_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterL_name" ):
                listener.enterL_name(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitL_name" ):
                listener.exitL_name(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitL_name" ):
                return visitor.visitL_name(self)
            else:
                return visitor.visitChildren(self)




    def l_name(self):

        localctx = kismetParser.L_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 94, self.RULE_l_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 648
            self.match(kismetParser.T__76)
            self.state = 649
            self.match(kismetParser.T__4)
            self.state = 650
            self.random_text()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SupportsContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def num_choice(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.Num_choiceContext)
            else:
                return self.getTypedRuleContext(kismetParser.Num_choiceContext,i)


        def getRuleIndex(self):
            return kismetParser.RULE_supports

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSupports" ):
                listener.enterSupports(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSupports" ):
                listener.exitSupports(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSupports" ):
                return visitor.visitSupports(self)
            else:
                return visitor.visitChildren(self)




    def supports(self):

        localctx = kismetParser.SupportsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 96, self.RULE_supports)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 652
            self.match(kismetParser.T__77)
            self.state = 653
            self.match(kismetParser.T__4)
            self.state = 654
            self.num_choice()
            self.state = 659
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__2:
                self.state = 655
                self.match(kismetParser.T__2)
                self.state = 656
                self.num_choice()
                self.state = 661
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NumContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NUMBER(self):
            return self.getToken(kismetParser.NUMBER, 0)

        def getRuleIndex(self):
            return kismetParser.RULE_num

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNum" ):
                listener.enterNum(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNum" ):
                listener.exitNum(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNum" ):
                return visitor.visitNum(self)
            else:
                return visitor.visitChildren(self)




    def num(self):

        localctx = kismetParser.NumContext(self, self._ctx, self.state)
        self.enterRule(localctx, 98, self.RULE_num)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 662
            self.match(kismetParser.NUMBER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Pos_numContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def POSITIVE_NUMBER(self):
            return self.getToken(kismetParser.POSITIVE_NUMBER, 0)

        def getRuleIndex(self):
            return kismetParser.RULE_pos_num

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPos_num" ):
                listener.enterPos_num(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPos_num" ):
                listener.exitPos_num(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPos_num" ):
                return visitor.visitPos_num(self)
            else:
                return visitor.visitChildren(self)




    def pos_num(self):

        localctx = kismetParser.Pos_numContext(self, self._ctx, self.state)
        self.enterRule(localctx, 100, self.RULE_pos_num)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 664
            self.match(kismetParser.POSITIVE_NUMBER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NameContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NAME(self):
            return self.getToken(kismetParser.NAME, 0)

        def getRuleIndex(self):
            return kismetParser.RULE_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterName" ):
                listener.enterName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitName" ):
                listener.exitName(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitName" ):
                return visitor.visitName(self)
            else:
                return visitor.visitChildren(self)




    def name(self):

        localctx = kismetParser.NameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 102, self.RULE_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 666
            self.match(kismetParser.NAME)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VarContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def VAR(self):
            return self.getToken(kismetParser.VAR, 0)

        def getRuleIndex(self):
            return kismetParser.RULE_var

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVar" ):
                listener.enterVar(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVar" ):
                listener.exitVar(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVar" ):
                return visitor.visitVar(self)
            else:
                return visitor.visitChildren(self)




    def var(self):

        localctx = kismetParser.VarContext(self, self._ctx, self.state)
        self.enterRule(localctx, 104, self.RULE_var)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 668
            self.match(kismetParser.VAR)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ComparatorContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return kismetParser.RULE_comparator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterComparator" ):
                listener.enterComparator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitComparator" ):
                listener.exitComparator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitComparator" ):
                return visitor.visitComparator(self)
            else:
                return visitor.visitChildren(self)




    def comparator(self):

        localctx = kismetParser.ComparatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 106, self.RULE_comparator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 670
            _la = self._input.LA(1)
            if not(((((_la - 26)) & ~0x3f) == 0 and ((1 << (_la - 26)) & ((1 << (kismetParser.T__25 - 26)) | (1 << (kismetParser.T__28 - 26)) | (1 << (kismetParser.T__78 - 26)) | (1 << (kismetParser.T__79 - 26)) | (1 << (kismetParser.T__80 - 26)) | (1 << (kismetParser.T__81 - 26)) | (1 << (kismetParser.T__82 - 26)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Num_choiceContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def num(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.NumContext)
            else:
                return self.getTypedRuleContext(kismetParser.NumContext,i)


        def name(self):
            return self.getTypedRuleContext(kismetParser.NameContext,0)


        def pdf(self):
            return self.getTypedRuleContext(kismetParser.PdfContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_num_choice

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNum_choice" ):
                listener.enterNum_choice(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNum_choice" ):
                listener.exitNum_choice(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNum_choice" ):
                return visitor.visitNum_choice(self)
            else:
                return visitor.visitChildren(self)




    def num_choice(self):

        localctx = kismetParser.Num_choiceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 108, self.RULE_num_choice)
        self._la = 0 # Token type
        try:
            self.state = 687
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,67,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 672
                self.match(kismetParser.T__83)
                self.state = 673
                self.num()
                self.state = 674
                self.match(kismetParser.T__84)
                self.state = 675
                self.name()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 677
                self.match(kismetParser.T__83)
                self.state = 678
                self.num()
                self.state = 679
                self.match(kismetParser.T__4)
                self.state = 680
                self.num()
                self.state = 681
                self.match(kismetParser.T__84)
                self.state = 683
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==kismetParser.T__5 or _la==kismetParser.T__26 or _la==kismetParser.T__85 or _la==kismetParser.NEG:
                    self.state = 682
                    self.pdf()


                self.state = 685
                self.name()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PdfContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NEG(self, i:int=None):
            if i is None:
                return self.getTokens(kismetParser.NEG)
            else:
                return self.getToken(kismetParser.NEG, i)

        def getRuleIndex(self):
            return kismetParser.RULE_pdf

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPdf" ):
                listener.enterPdf(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPdf" ):
                listener.exitPdf(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPdf" ):
                return visitor.visitPdf(self)
            else:
                return visitor.visitChildren(self)




    def pdf(self):

        localctx = kismetParser.PdfContext(self, self._ctx, self.state)
        self.enterRule(localctx, 110, self.RULE_pdf)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 690 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 689
                _la = self._input.LA(1)
                if not(_la==kismetParser.T__5 or _la==kismetParser.T__26 or _la==kismetParser.T__85 or _la==kismetParser.NEG):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 692 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==kismetParser.T__5 or _la==kismetParser.T__26 or _la==kismetParser.T__85 or _la==kismetParser.NEG):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





