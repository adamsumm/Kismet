# Generated from kismet.ebnv by ANTLR 4.7.2
# encoding: utf-8
from antlr4 import *
from io import StringIO
from typing.io import TextIO
import sys


def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3Z")
        buf.write("\u026e\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\4\23\t\23")
        buf.write("\4\24\t\24\4\25\t\25\4\26\t\26\4\27\t\27\4\30\t\30\4\31")
        buf.write("\t\31\4\32\t\32\4\33\t\33\4\34\t\34\4\35\t\35\4\36\t\36")
        buf.write("\4\37\t\37\4 \t \4!\t!\4\"\t\"\4#\t#\4$\t$\4%\t%\4&\t")
        buf.write("&\4\'\t\'\4(\t(\4)\t)\4*\t*\4+\t+\4,\t,\4-\t-\4.\t.\4")
        buf.write("/\t/\4\60\t\60\4\61\t\61\4\62\t\62\4\63\t\63\4\64\t\64")
        buf.write("\4\65\t\65\3\2\3\2\3\2\3\2\6\2o\n\2\r\2\16\2p\3\2\3\2")
        buf.write("\3\3\3\3\3\3\3\3\7\3y\n\3\f\3\16\3|\13\3\3\4\3\4\3\4\3")
        buf.write("\4\7\4\u0082\n\4\f\4\16\4\u0085\13\4\3\4\3\4\3\4\3\4\7")
        buf.write("\4\u008b\n\4\f\4\16\4\u008e\13\4\3\4\3\4\5\4\u0092\n\4")
        buf.write("\3\4\3\4\5\4\u0096\n\4\3\4\3\4\7\4\u009a\n\4\f\4\16\4")
        buf.write("\u009d\13\4\3\4\3\4\3\5\3\5\3\6\3\6\5\6\u00a5\n\6\3\7")
        buf.write("\3\7\5\7\u00a9\n\7\3\b\3\b\3\b\3\b\3\b\7\b\u00b0\n\b\f")
        buf.write("\b\16\b\u00b3\13\b\3\b\5\b\u00b6\n\b\3\b\3\b\3\t\3\t\3")
        buf.write("\t\3\t\3\t\7\t\u00bf\n\t\f\t\16\t\u00c2\13\t\3\t\5\t\u00c5")
        buf.write("\n\t\3\t\3\t\3\n\6\n\u00ca\n\n\r\n\16\n\u00cb\3\n\6\n")
        buf.write("\u00cf\n\n\r\n\16\n\u00d0\5\n\u00d3\n\n\3\13\3\13\5\13")
        buf.write("\u00d7\n\13\3\13\3\13\3\13\3\13\3\13\3\13\7\13\u00df\n")
        buf.write("\13\f\13\16\13\u00e2\13\13\3\13\3\13\5\13\u00e6\n\13\3")
        buf.write("\13\5\13\u00e9\n\13\3\13\3\13\5\13\u00ed\n\13\3\13\3\13")
        buf.write("\7\13\u00f1\n\13\f\13\16\13\u00f4\13\13\3\13\3\13\3\f")
        buf.write("\3\f\3\r\3\r\3\16\3\16\3\16\3\16\3\16\7\16\u0101\n\16")
        buf.write("\f\16\16\16\u0104\13\16\3\17\3\17\3\20\3\20\3\20\3\21")
        buf.write("\3\21\6\21\u010d\n\21\r\21\16\21\u010e\3\22\3\22\3\22")
        buf.write("\3\22\3\22\7\22\u0116\n\22\f\22\16\22\u0119\13\22\3\22")
        buf.write("\3\22\3\22\3\22\3\22\3\22\3\22\7\22\u0122\n\22\f\22\16")
        buf.write("\22\u0125\13\22\3\22\3\22\3\22\3\22\3\22\3\22\3\22\7\22")
        buf.write("\u012e\n\22\f\22\16\22\u0131\13\22\3\22\3\22\3\22\3\22")
        buf.write("\3\22\3\22\7\22\u0139\n\22\f\22\16\22\u013c\13\22\3\22")
        buf.write("\3\22\5\22\u0140\n\22\3\23\3\23\3\24\3\24\3\24\3\24\3")
        buf.write("\24\5\24\u0149\n\24\3\25\3\25\3\25\3\25\3\25\3\25\7\25")
        buf.write("\u0151\n\25\f\25\16\25\u0154\13\25\3\25\3\25\5\25\u0158")
        buf.write("\n\25\3\25\3\25\3\25\5\25\u015d\n\25\3\25\3\25\3\25\5")
        buf.write("\25\u0162\n\25\7\25\u0164\n\25\f\25\16\25\u0167\13\25")
        buf.write("\3\25\3\25\3\26\3\26\3\26\5\26\u016e\n\26\3\26\3\26\3")
        buf.write("\26\3\26\7\26\u0174\n\26\f\26\16\26\u0177\13\26\3\26\3")
        buf.write("\26\3\27\3\27\3\27\3\30\5\30\u017f\n\30\3\30\3\30\5\30")
        buf.write("\u0183\n\30\3\30\3\30\3\30\3\30\3\30\5\30\u018a\n\30\3")
        buf.write("\30\3\30\3\30\3\30\5\30\u0190\n\30\3\31\3\31\3\32\3\32")
        buf.write("\3\33\3\33\3\33\3\33\3\33\7\33\u019b\n\33\f\33\16\33\u019e")
        buf.write("\13\33\3\34\3\34\3\34\3\34\7\34\u01a4\n\34\f\34\16\34")
        buf.write("\u01a7\13\34\3\35\3\35\3\35\3\35\3\35\3\35\3\35\3\35\3")
        buf.write("\35\3\35\3\35\3\35\3\35\3\35\3\35\3\35\3\35\3\35\3\35")
        buf.write("\3\35\3\35\3\35\3\35\3\35\3\35\3\35\3\35\3\35\3\35\3\35")
        buf.write("\3\35\3\35\3\35\3\35\3\35\3\35\3\35\3\35\3\35\3\35\5\35")
        buf.write("\u01d1\n\35\3\36\3\36\3\36\3\36\3\36\3\36\5\36\u01d9\n")
        buf.write("\36\3\37\3\37\3\37\3\37\3 \3 \3 \3 \3!\3!\3!\3!\3!\3!")
        buf.write("\3\"\3\"\3#\3#\3#\3#\5#\u01ef\n#\3#\3#\3#\3#\5#\u01f5")
        buf.write("\n#\3#\3#\3#\5#\u01fa\n#\3$\3$\5$\u01fe\n$\3$\3$\3$\3")
        buf.write("$\3$\5$\u0205\n$\3%\3%\3%\3%\3%\3%\3&\3&\3\'\3\'\3(\3")
        buf.write("(\3(\3(\3(\3(\3(\5(\u0218\n(\3(\3(\3(\3(\3(\5(\u021f\n")
        buf.write("(\7(\u0221\n(\f(\16(\u0224\13(\3(\3(\3)\3)\3)\3)\3)\7")
        buf.write(")\u022d\n)\f)\16)\u0230\13)\3*\3*\3*\3*\3*\7*\u0237\n")
        buf.write("*\f*\16*\u023a\13*\3+\3+\3+\3,\3,\3-\3-\3-\3-\3.\3.\3")
        buf.write(".\3.\3.\5.\u024a\n.\3/\3/\3/\3/\3\60\3\60\3\61\3\61\3")
        buf.write("\62\3\62\3\63\3\63\3\64\3\64\3\64\3\64\3\64\3\64\3\64")
        buf.write("\3\64\3\64\3\64\3\64\5\64\u0263\n\64\3\64\3\64\5\64\u0267")
        buf.write("\n\64\3\65\6\65\u026a\n\65\r\65\16\65\u026b\3\65\2\2\66")
        buf.write("\2\4\6\b\n\f\16\20\22\24\26\30\32\34\36 \"$&(*,.\60\62")
        buf.write("\64\668:<>@BDFHJLNPRTVXZ\\^`bdfh\2\13\3\2\n\13\3\2\b\t")
        buf.write("\4\2\r\r\32\35\3\2\63\64\3\2\65:\3\2?E\3\2ST\5\2\32\32")
        buf.write("\35\35KO\6\2\t\t\17\17\33\33RR\2\u029c\2n\3\2\2\2\4t\3")
        buf.write("\2\2\2\6}\3\2\2\2\b\u00a0\3\2\2\2\n\u00a4\3\2\2\2\f\u00a8")
        buf.write("\3\2\2\2\16\u00aa\3\2\2\2\20\u00b9\3\2\2\2\22\u00d2\3")
        buf.write("\2\2\2\24\u00d6\3\2\2\2\26\u00f7\3\2\2\2\30\u00f9\3\2")
        buf.write("\2\2\32\u00fb\3\2\2\2\34\u0105\3\2\2\2\36\u0107\3\2\2")
        buf.write("\2 \u010a\3\2\2\2\"\u013f\3\2\2\2$\u0141\3\2\2\2&\u0148")
        buf.write("\3\2\2\2(\u014a\3\2\2\2*\u016a\3\2\2\2,\u017a\3\2\2\2")
        buf.write(".\u018f\3\2\2\2\60\u0191\3\2\2\2\62\u0193\3\2\2\2\64\u0195")
        buf.write("\3\2\2\2\66\u019f\3\2\2\28\u01d0\3\2\2\2:\u01d8\3\2\2")
        buf.write("\2<\u01da\3\2\2\2>\u01de\3\2\2\2@\u01e2\3\2\2\2B\u01e8")
        buf.write("\3\2\2\2D\u01ea\3\2\2\2F\u01fb\3\2\2\2H\u0206\3\2\2\2")
        buf.write("J\u020c\3\2\2\2L\u020e\3\2\2\2N\u0210\3\2\2\2P\u0227\3")
        buf.write("\2\2\2R\u0231\3\2\2\2T\u023b\3\2\2\2V\u023e\3\2\2\2X\u0240")
        buf.write("\3\2\2\2Z\u0249\3\2\2\2\\\u024b\3\2\2\2^\u024f\3\2\2\2")
        buf.write("`\u0251\3\2\2\2b\u0253\3\2\2\2d\u0255\3\2\2\2f\u0266\3")
        buf.write("\2\2\2h\u0269\3\2\2\2jo\5N(\2ko\5(\25\2lo\5\24\13\2mo")
        buf.write("\5\6\4\2nj\3\2\2\2nk\3\2\2\2nl\3\2\2\2nm\3\2\2\2op\3\2")
        buf.write("\2\2pn\3\2\2\2pq\3\2\2\2qr\3\2\2\2rs\7\2\2\3s\3\3\2\2")
        buf.write("\2tu\7\3\2\2uz\5`\61\2vw\7\4\2\2wy\5`\61\2xv\3\2\2\2y")
        buf.write("|\3\2\2\2zx\3\2\2\2z{\3\2\2\2{\5\3\2\2\2|z\3\2\2\2}~\5")
        buf.write("\b\5\2~\u0083\5`\61\2\177\u0080\7\4\2\2\u0080\u0082\5")
        buf.write("`\61\2\u0081\177\3\2\2\2\u0082\u0085\3\2\2\2\u0083\u0081")
        buf.write("\3\2\2\2\u0083\u0084\3\2\2\2\u0084\u0086\3\2\2\2\u0085")
        buf.write("\u0083\3\2\2\2\u0086\u0087\7\5\2\2\u0087\u008c\5.\30\2")
        buf.write("\u0088\u0089\7\6\2\2\u0089\u008b\5.\30\2\u008a\u0088\3")
        buf.write("\2\2\2\u008b\u008e\3\2\2\2\u008c\u008a\3\2\2\2\u008c\u008d")
        buf.write("\3\2\2\2\u008d\u008f\3\2\2\2\u008e\u008c\3\2\2\2\u008f")
        buf.write("\u0091\7\7\2\2\u0090\u0092\5\4\3\2\u0091\u0090\3\2\2\2")
        buf.write("\u0091\u0092\3\2\2\2\u0092\u0093\3\2\2\2\u0093\u0095\7")
        buf.write("\b\2\2\u0094\u0096\5\n\6\2\u0095\u0094\3\2\2\2\u0095\u0096")
        buf.write("\3\2\2\2\u0096\u009b\3\2\2\2\u0097\u0098\7\6\2\2\u0098")
        buf.write("\u009a\5\n\6\2\u0099\u0097\3\2\2\2\u009a\u009d\3\2\2\2")
        buf.write("\u009b\u0099\3\2\2\2\u009b\u009c\3\2\2\2\u009c\u009e\3")
        buf.write("\2\2\2\u009d\u009b\3\2\2\2\u009e\u009f\7\t\2\2\u009f\7")
        buf.write("\3\2\2\2\u00a0\u00a1\t\2\2\2\u00a1\t\3\2\2\2\u00a2\u00a5")
        buf.write("\5\16\b\2\u00a3\u00a5\5\20\t\2\u00a4\u00a2\3\2\2\2\u00a4")
        buf.write("\u00a3\3\2\2\2\u00a5\13\3\2\2\2\u00a6\u00a9\7\f\2\2\u00a7")
        buf.write("\u00a9\5`\61\2\u00a8\u00a6\3\2\2\2\u00a8\u00a7\3\2\2\2")
        buf.write("\u00a9\r\3\2\2\2\u00aa\u00ab\5\22\n\2\u00ab\u00ac\7\5")
        buf.write("\2\2\u00ac\u00b1\5\f\7\2\u00ad\u00ae\7\6\2\2\u00ae\u00b0")
        buf.write("\5\f\7\2\u00af\u00ad\3\2\2\2\u00b0\u00b3\3\2\2\2\u00b1")
        buf.write("\u00af\3\2\2\2\u00b1\u00b2\3\2\2\2\u00b2\u00b5\3\2\2\2")
        buf.write("\u00b3\u00b1\3\2\2\2\u00b4\u00b6\5\66\34\2\u00b5\u00b4")
        buf.write("\3\2\2\2\u00b5\u00b6\3\2\2\2\u00b6\u00b7\3\2\2\2\u00b7")
        buf.write("\u00b8\7\7\2\2\u00b8\17\3\2\2\2\u00b9\u00ba\5\22\n\2\u00ba")
        buf.write("\u00bb\7\r\2\2\u00bb\u00c0\5`\61\2\u00bc\u00bd\7\6\2\2")
        buf.write("\u00bd\u00bf\5`\61\2\u00be\u00bc\3\2\2\2\u00bf\u00c2\3")
        buf.write("\2\2\2\u00c0\u00be\3\2\2\2\u00c0\u00c1\3\2\2\2\u00c1\u00c4")
        buf.write("\3\2\2\2\u00c2\u00c0\3\2\2\2\u00c3\u00c5\5\66\34\2\u00c4")
        buf.write("\u00c3\3\2\2\2\u00c4\u00c5\3\2\2\2\u00c5\u00c6\3\2\2\2")
        buf.write("\u00c6\u00c7\7\r\2\2\u00c7\21\3\2\2\2\u00c8\u00ca\7\16")
        buf.write("\2\2\u00c9\u00c8\3\2\2\2\u00ca\u00cb\3\2\2\2\u00cb\u00c9")
        buf.write("\3\2\2\2\u00cb\u00cc\3\2\2\2\u00cc\u00d3\3\2\2\2\u00cd")
        buf.write("\u00cf\7\17\2\2\u00ce\u00cd\3\2\2\2\u00cf\u00d0\3\2\2")
        buf.write("\2\u00d0\u00ce\3\2\2\2\u00d0\u00d1\3\2\2\2\u00d1\u00d3")
        buf.write("\3\2\2\2\u00d2\u00c9\3\2\2\2\u00d2\u00ce\3\2\2\2\u00d3")
        buf.write("\23\3\2\2\2\u00d4\u00d7\5\26\f\2\u00d5\u00d7\5\30\r\2")
        buf.write("\u00d6\u00d4\3\2\2\2\u00d6\u00d5\3\2\2\2\u00d6\u00d7\3")
        buf.write("\2\2\2\u00d7\u00d8\3\2\2\2\u00d8\u00d9\7\20\2\2\u00d9")
        buf.write("\u00da\5`\61\2\u00da\u00db\7\5\2\2\u00db\u00e0\5.\30\2")
        buf.write("\u00dc\u00dd\7\6\2\2\u00dd\u00df\5.\30\2\u00de\u00dc\3")
        buf.write("\2\2\2\u00df\u00e2\3\2\2\2\u00e0\u00de\3\2\2\2\u00e0\u00e1")
        buf.write("\3\2\2\2\u00e1\u00e3\3\2\2\2\u00e2\u00e0\3\2\2\2\u00e3")
        buf.write("\u00e5\7\7\2\2\u00e4\u00e6\5*\26\2\u00e5\u00e4\3\2\2\2")
        buf.write("\u00e5\u00e6\3\2\2\2\u00e6\u00e8\3\2\2\2\u00e7\u00e9\5")
        buf.write("V,\2\u00e8\u00e7\3\2\2\2\u00e8\u00e9\3\2\2\2\u00e9\u00ea")
        buf.write("\3\2\2\2\u00ea\u00ec\7\b\2\2\u00eb\u00ed\5&\24\2\u00ec")
        buf.write("\u00eb\3\2\2\2\u00ec\u00ed\3\2\2\2\u00ed\u00f2\3\2\2\2")
        buf.write("\u00ee\u00ef\7\21\2\2\u00ef\u00f1\5&\24\2\u00f0\u00ee")
        buf.write("\3\2\2\2\u00f1\u00f4\3\2\2\2\u00f2\u00f0\3\2\2\2\u00f2")
        buf.write("\u00f3\3\2\2\2\u00f3\u00f5\3\2\2\2\u00f4\u00f2\3\2\2\2")
        buf.write("\u00f5\u00f6\7\t\2\2\u00f6\25\3\2\2\2\u00f7\u00f8\7\22")
        buf.write("\2\2\u00f8\27\3\2\2\2\u00f9\u00fa\7\23\2\2\u00fa\31\3")
        buf.write("\2\2\2\u00fb\u00fc\7\24\2\2\u00fc\u00fd\7\b\2\2\u00fd")
        buf.write("\u0102\5\34\17\2\u00fe\u00ff\7\6\2\2\u00ff\u0101\5\34")
        buf.write("\17\2\u0100\u00fe\3\2\2\2\u0101\u0104\3\2\2\2\u0102\u0100")
        buf.write("\3\2\2\2\u0102\u0103\3\2\2\2\u0103\33\3\2\2\2\u0104\u0102")
        buf.write("\3\2\2\2\u0105\u0106\5:\36\2\u0106\35\3\2\2\2\u0107\u0108")
        buf.write("\7\f\2\2\u0108\u0109\5\22\n\2\u0109\37\3\2\2\2\u010a\u010c")
        buf.write("\7\25\2\2\u010b\u010d\5\"\22\2\u010c\u010b\3\2\2\2\u010d")
        buf.write("\u010e\3\2\2\2\u010e\u010c\3\2\2\2\u010e\u010f\3\2\2\2")
        buf.write("\u010f!\3\2\2\2\u0110\u0111\5b\62\2\u0111\u0112\7\5\2")
        buf.write("\2\u0112\u0117\5.\30\2\u0113\u0114\7\6\2\2\u0114\u0116")
        buf.write("\5.\30\2\u0115\u0113\3\2\2\2\u0116\u0119\3\2\2\2\u0117")
        buf.write("\u0115\3\2\2\2\u0117\u0118\3\2\2\2\u0118\u011a\3\2\2\2")
        buf.write("\u0119\u0117\3\2\2\2\u011a\u011b\7\7\2\2\u011b\u0140\3")
        buf.write("\2\2\2\u011c\u011d\5`\61\2\u011d\u011e\7\5\2\2\u011e\u0123")
        buf.write("\5.\30\2\u011f\u0120\7\6\2\2\u0120\u0122\5.\30\2\u0121")
        buf.write("\u011f\3\2\2\2\u0122\u0125\3\2\2\2\u0123\u0121\3\2\2\2")
        buf.write("\u0123\u0124\3\2\2\2\u0124\u0126\3\2\2\2\u0125\u0123\3")
        buf.write("\2\2\2\u0126\u0127\7\7\2\2\u0127\u0140\3\2\2\2\u0128\u0129")
        buf.write("\5$\23\2\u0129\u012a\7\5\2\2\u012a\u012f\5.\30\2\u012b")
        buf.write("\u012c\7\6\2\2\u012c\u012e\5.\30\2\u012d\u012b\3\2\2\2")
        buf.write("\u012e\u0131\3\2\2\2\u012f\u012d\3\2\2\2\u012f\u0130\3")
        buf.write("\2\2\2\u0130\u0132\3\2\2\2\u0131\u012f\3\2\2\2\u0132\u0133")
        buf.write("\7\7\2\2\u0133\u0140\3\2\2\2\u0134\u0135\7\5\2\2\u0135")
        buf.write("\u013a\5.\30\2\u0136\u0137\7\6\2\2\u0137\u0139\5.\30\2")
        buf.write("\u0138\u0136\3\2\2\2\u0139\u013c\3\2\2\2\u013a\u0138\3")
        buf.write("\2\2\2\u013a\u013b\3\2\2\2\u013b\u013d\3\2\2\2\u013c\u013a")
        buf.write("\3\2\2\2\u013d\u013e\7\7\2\2\u013e\u0140\3\2\2\2\u013f")
        buf.write("\u0110\3\2\2\2\u013f\u011c\3\2\2\2\u013f\u0128\3\2\2\2")
        buf.write("\u013f\u0134\3\2\2\2\u0140#\3\2\2\2\u0141\u0142\7\26\2")
        buf.write("\2\u0142%\3\2\2\2\u0143\u0149\5\64\33\2\u0144\u0149\5")
        buf.write("\66\34\2\u0145\u0149\5 \21\2\u0146\u0149\5\32\16\2\u0147")
        buf.write("\u0149\5\36\20\2\u0148\u0143\3\2\2\2\u0148\u0144\3\2\2")
        buf.write("\2\u0148\u0145\3\2\2\2\u0148\u0146\3\2\2\2\u0148\u0147")
        buf.write("\3\2\2\2\u0149\'\3\2\2\2\u014a\u014b\7\27\2\2\u014b\u014c")
        buf.write("\5`\61\2\u014c\u014d\7\5\2\2\u014d\u0152\5.\30\2\u014e")
        buf.write("\u014f\7\6\2\2\u014f\u0151\5.\30\2\u0150\u014e\3\2\2\2")
        buf.write("\u0151\u0154\3\2\2\2\u0152\u0150\3\2\2\2\u0152\u0153\3")
        buf.write("\2\2\2\u0153\u0155\3\2\2\2\u0154\u0152\3\2\2\2\u0155\u0157")
        buf.write("\7\7\2\2\u0156\u0158\5*\26\2\u0157\u0156\3\2\2\2\u0157")
        buf.write("\u0158\3\2\2\2\u0158\u0159\3\2\2\2\u0159\u015c\7\b\2\2")
        buf.write("\u015a\u015d\5\64\33\2\u015b\u015d\5\66\34\2\u015c\u015a")
        buf.write("\3\2\2\2\u015c\u015b\3\2\2\2\u015d\u0165\3\2\2\2\u015e")
        buf.write("\u0161\7\21\2\2\u015f\u0162\5\64\33\2\u0160\u0162\5\66")
        buf.write("\34\2\u0161\u015f\3\2\2\2\u0161\u0160\3\2\2\2\u0162\u0164")
        buf.write("\3\2\2\2\u0163\u015e\3\2\2\2\u0164\u0167\3\2\2\2\u0165")
        buf.write("\u0163\3\2\2\2\u0165\u0166\3\2\2\2\u0166\u0168\3\2\2\2")
        buf.write("\u0167\u0165\3\2\2\2\u0168\u0169\7\t\2\2\u0169)\3\2\2")
        buf.write("\2\u016a\u016d\7\30\2\2\u016b\u016e\5,\27\2\u016c\u016e")
        buf.write("\5`\61\2\u016d\u016b\3\2\2\2\u016d\u016c\3\2\2\2\u016e")
        buf.write("\u016f\3\2\2\2\u016f\u0170\7\5\2\2\u0170\u0175\5.\30\2")
        buf.write("\u0171\u0172\7\6\2\2\u0172\u0174\5.\30\2\u0173\u0171\3")
        buf.write("\2\2\2\u0174\u0177\3\2\2\2\u0175\u0173\3\2\2\2\u0175\u0176")
        buf.write("\3\2\2\2\u0176\u0178\3\2\2\2\u0177\u0175\3\2\2\2\u0178")
        buf.write("\u0179\7\7\2\2\u0179+\3\2\2\2\u017a\u017b\7\31\2\2\u017b")
        buf.write("\u017c\5`\61\2\u017c-\3\2\2\2\u017d\u017f\5\62\32\2\u017e")
        buf.write("\u017d\3\2\2\2\u017e\u017f\3\2\2\2\u017f\u0180\3\2\2\2")
        buf.write("\u0180\u0190\5b\62\2\u0181\u0183\5\62\32\2\u0182\u0181")
        buf.write("\3\2\2\2\u0182\u0183\3\2\2\2\u0183\u0184\3\2\2\2\u0184")
        buf.write("\u0185\5b\62\2\u0185\u0186\5\60\31\2\u0186\u0187\5`\61")
        buf.write("\2\u0187\u0190\3\2\2\2\u0188\u018a\5\62\32\2\u0189\u0188")
        buf.write("\3\2\2\2\u0189\u018a\3\2\2\2\u018a\u018b\3\2\2\2\u018b")
        buf.write("\u018c\5b\62\2\u018c\u018d\5\60\31\2\u018d\u018e\5b\62")
        buf.write("\2\u018e\u0190\3\2\2\2\u018f\u017e\3\2\2\2\u018f\u0182")
        buf.write("\3\2\2\2\u018f\u0189\3\2\2\2\u0190/\3\2\2\2\u0191\u0192")
        buf.write("\t\3\2\2\u0192\61\3\2\2\2\u0193\u0194\t\4\2\2\u0194\63")
        buf.write("\3\2\2\2\u0195\u0196\7\36\2\2\u0196\u0197\7\b\2\2\u0197")
        buf.write("\u019c\5`\61\2\u0198\u0199\7\6\2\2\u0199\u019b\5`\61\2")
        buf.write("\u019a\u0198\3\2\2\2\u019b\u019e\3\2\2\2\u019c\u019a\3")
        buf.write("\2\2\2\u019c\u019d\3\2\2\2\u019d\65\3\2\2\2\u019e\u019c")
        buf.write("\3\2\2\2\u019f\u01a0\7\37\2\2\u01a0\u01a5\5:\36\2\u01a1")
        buf.write("\u01a2\7\6\2\2\u01a2\u01a4\5:\36\2\u01a3\u01a1\3\2\2\2")
        buf.write("\u01a4\u01a7\3\2\2\2\u01a5\u01a3\3\2\2\2\u01a5\u01a6\3")
        buf.write("\2\2\2\u01a6\67\3\2\2\2\u01a7\u01a5\3\2\2\2\u01a8\u01d1")
        buf.write("\7 \2\2\u01a9\u01d1\7!\2\2\u01aa\u01d1\7\"\2\2\u01ab\u01ac")
        buf.write("\7#\2\2\u01ac\u01ad\7$\2\2\u01ad\u01d1\7%\2\2\u01ae\u01af")
        buf.write("\7&\2\2\u01af\u01d1\7%\2\2\u01b0\u01b1\7\'\2\2\u01b1\u01d1")
        buf.write("\7%\2\2\u01b2\u01b3\7#\2\2\u01b3\u01b4\7$\2\2\u01b4\u01d1")
        buf.write("\7(\2\2\u01b5\u01b6\7&\2\2\u01b6\u01d1\7(\2\2\u01b7\u01b8")
        buf.write("\7\'\2\2\u01b8\u01d1\7(\2\2\u01b9\u01ba\7#\2\2\u01ba\u01bb")
        buf.write("\7$\2\2\u01bb\u01d1\7)\2\2\u01bc\u01bd\7&\2\2\u01bd\u01d1")
        buf.write("\7)\2\2\u01be\u01bf\7\'\2\2\u01bf\u01d1\7)\2\2\u01c0\u01c1")
        buf.write("\7#\2\2\u01c1\u01c2\7$\2\2\u01c2\u01d1\7*\2\2\u01c3\u01c4")
        buf.write("\7&\2\2\u01c4\u01d1\7*\2\2\u01c5\u01c6\7\'\2\2\u01c6\u01d1")
        buf.write("\7*\2\2\u01c7\u01d1\7+\2\2\u01c8\u01d1\7,\2\2\u01c9\u01d1")
        buf.write("\7-\2\2\u01ca\u01d1\7.\2\2\u01cb\u01d1\7/\2\2\u01cc\u01d1")
        buf.write("\7\60\2\2\u01cd\u01d1\7\61\2\2\u01ce\u01d1\7#\2\2\u01cf")
        buf.write("\u01d1\7\62\2\2\u01d0\u01a8\3\2\2\2\u01d0\u01a9\3\2\2")
        buf.write("\2\u01d0\u01aa\3\2\2\2\u01d0\u01ab\3\2\2\2\u01d0\u01ae")
        buf.write("\3\2\2\2\u01d0\u01b0\3\2\2\2\u01d0\u01b2\3\2\2\2\u01d0")
        buf.write("\u01b5\3\2\2\2\u01d0\u01b7\3\2\2\2\u01d0\u01b9\3\2\2\2")
        buf.write("\u01d0\u01bc\3\2\2\2\u01d0\u01be\3\2\2\2\u01d0\u01c0\3")
        buf.write("\2\2\2\u01d0\u01c3\3\2\2\2\u01d0\u01c5\3\2\2\2\u01d0\u01c7")
        buf.write("\3\2\2\2\u01d0\u01c8\3\2\2\2\u01d0\u01c9\3\2\2\2\u01d0")
        buf.write("\u01ca\3\2\2\2\u01d0\u01cb\3\2\2\2\u01d0\u01cc\3\2\2\2")
        buf.write("\u01d0\u01cd\3\2\2\2\u01d0\u01ce\3\2\2\2\u01d0\u01cf\3")
        buf.write("\2\2\2\u01d19\3\2\2\2\u01d2\u01d9\5<\37\2\u01d3\u01d9")
        buf.write("\5> \2\u01d4\u01d9\5@!\2\u01d5\u01d9\5D#\2\u01d6\u01d9")
        buf.write("\5F$\2\u01d7\u01d9\5H%\2\u01d8\u01d2\3\2\2\2\u01d8\u01d3")
        buf.write("\3\2\2\2\u01d8\u01d4\3\2\2\2\u01d8\u01d5\3\2\2\2\u01d8")
        buf.write("\u01d6\3\2\2\2\u01d8\u01d7\3\2\2\2\u01d9;\3\2\2\2\u01da")
        buf.write("\u01db\5.\30\2\u01db\u01dc\58\35\2\u01dc\u01dd\5.\30\2")
        buf.write("\u01dd=\3\2\2\2\u01de\u01df\5.\30\2\u01df\u01e0\5J&\2")
        buf.write("\u01e0\u01e1\5`\61\2\u01e1?\3\2\2\2\u01e2\u01e3\5.\30")
        buf.write("\2\u01e3\u01e4\t\5\2\2\u01e4\u01e5\5`\61\2\u01e5\u01e6")
        buf.write("\5d\63\2\u01e6\u01e7\5^\60\2\u01e7A\3\2\2\2\u01e8\u01e9")
        buf.write("\t\6\2\2\u01e9C\3\2\2\2\u01ea\u01eb\5.\30\2\u01eb\u01ec")
        buf.write("\7;\2\2\u01ec\u01ee\5.\30\2\u01ed\u01ef\5B\"\2\u01ee\u01ed")
        buf.write("\3\2\2\2\u01ee\u01ef\3\2\2\2\u01ef\u01f0\3\2\2\2\u01f0")
        buf.write("\u01f4\5`\61\2\u01f1\u01f2\7<\2\2\u01f2\u01f5\7=\2\2\u01f3")
        buf.write("\u01f5\7>\2\2\u01f4\u01f1\3\2\2\2\u01f4\u01f3\3\2\2\2")
        buf.write("\u01f5\u01f9\3\2\2\2\u01f6\u01f7\5L\'\2\u01f7\u01f8\5")
        buf.write("^\60\2\u01f8\u01fa\3\2\2\2\u01f9\u01f6\3\2\2\2\u01f9\u01fa")
        buf.write("\3\2\2\2\u01faE\3\2\2\2\u01fb\u01fd\5.\30\2\u01fc\u01fe")
        buf.write("\5B\"\2\u01fd\u01fc\3\2\2\2\u01fd\u01fe\3\2\2\2\u01fe")
        buf.write("\u01ff\3\2\2\2\u01ff\u0200\5`\61\2\u0200\u0204\5.\30\2")
        buf.write("\u0201\u0202\5L\'\2\u0202\u0203\5^\60\2\u0203\u0205\3")
        buf.write("\2\2\2\u0204\u0201\3\2\2\2\u0204\u0205\3\2\2\2\u0205G")
        buf.write("\3\2\2\2\u0206\u0207\5.\30\2\u0207\u0208\5`\61\2\u0208")
        buf.write("\u0209\5.\30\2\u0209\u020a\5d\63\2\u020a\u020b\5^\60\2")
        buf.write("\u020bI\3\2\2\2\u020c\u020d\t\7\2\2\u020dK\3\2\2\2\u020e")
        buf.write("\u020f\t\b\2\2\u020fM\3\2\2\2\u0210\u0211\7F\2\2\u0211")
        buf.write("\u0212\5`\61\2\u0212\u0217\7\b\2\2\u0213\u0218\5X-\2\u0214")
        buf.write("\u0218\5\\/\2\u0215\u0218\5P)\2\u0216\u0218\5R*\2\u0217")
        buf.write("\u0213\3\2\2\2\u0217\u0214\3\2\2\2\u0217\u0215\3\2\2\2")
        buf.write("\u0217\u0216\3\2\2\2\u0218\u0222\3\2\2\2\u0219\u021e\7")
        buf.write("\21\2\2\u021a\u021f\5X-\2\u021b\u021f\5\\/\2\u021c\u021f")
        buf.write("\5P)\2\u021d\u021f\5R*\2\u021e\u021a\3\2\2\2\u021e\u021b")
        buf.write("\3\2\2\2\u021e\u021c\3\2\2\2\u021e\u021d\3\2\2\2\u021f")
        buf.write("\u0221\3\2\2\2\u0220\u0219\3\2\2\2\u0221\u0224\3\2\2\2")
        buf.write("\u0222\u0220\3\2\2\2\u0222\u0223\3\2\2\2\u0223\u0225\3")
        buf.write("\2\2\2\u0224\u0222\3\2\2\2\u0225\u0226\7\t\2\2\u0226O")
        buf.write("\3\2\2\2\u0227\u0228\7G\2\2\u0228\u0229\7\b\2\2\u0229")
        buf.write("\u022e\5T+\2\u022a\u022b\7\6\2\2\u022b\u022d\5T+\2\u022c")
        buf.write("\u022a\3\2\2\2\u022d\u0230\3\2\2\2\u022e\u022c\3\2\2\2")
        buf.write("\u022e\u022f\3\2\2\2\u022fQ\3\2\2\2\u0230\u022e\3\2\2")
        buf.write("\2\u0231\u0232\7H\2\2\u0232\u0233\7\b\2\2\u0233\u0238")
        buf.write("\5T+\2\u0234\u0235\7\6\2\2\u0235\u0237\5T+\2\u0236\u0234")
        buf.write("\3\2\2\2\u0237\u023a\3\2\2\2\u0238\u0236\3\2\2\2\u0238")
        buf.write("\u0239\3\2\2\2\u0239S\3\2\2\2\u023a\u0238\3\2\2\2\u023b")
        buf.write("\u023c\7\31\2\2\u023c\u023d\5f\64\2\u023dU\3\2\2\2\u023e")
        buf.write("\u023f\7U\2\2\u023fW\3\2\2\2\u0240\u0241\7I\2\2\u0241")
        buf.write("\u0242\7\b\2\2\u0242\u0243\5V,\2\u0243Y\3\2\2\2\u0244")
        buf.write("\u024a\5f\64\2\u0245\u0246\5f\64\2\u0246\u0247\7\6\2\2")
        buf.write("\u0247\u0248\5Z.\2\u0248\u024a\3\2\2\2\u0249\u0244\3\2")
        buf.write("\2\2\u0249\u0245\3\2\2\2\u024a[\3\2\2\2\u024b\u024c\7")
        buf.write("J\2\2\u024c\u024d\7\b\2\2\u024d\u024e\5Z.\2\u024e]\3\2")
        buf.write("\2\2\u024f\u0250\7X\2\2\u0250_\3\2\2\2\u0251\u0252\7Y")
        buf.write("\2\2\u0252a\3\2\2\2\u0253\u0254\7Z\2\2\u0254c\3\2\2\2")
        buf.write("\u0255\u0256\t\t\2\2\u0256e\3\2\2\2\u0257\u0258\7P\2\2")
        buf.write("\u0258\u0259\5^\60\2\u0259\u025a\7Q\2\2\u025a\u025b\5")
        buf.write("`\61\2\u025b\u0267\3\2\2\2\u025c\u025d\7P\2\2\u025d\u025e")
        buf.write("\5^\60\2\u025e\u025f\7\17\2\2\u025f\u0260\5^\60\2\u0260")
        buf.write("\u0262\7Q\2\2\u0261\u0263\5h\65\2\u0262\u0261\3\2\2\2")
        buf.write("\u0262\u0263\3\2\2\2\u0263\u0264\3\2\2\2\u0264\u0265\5")
        buf.write("`\61\2\u0265\u0267\3\2\2\2\u0266\u0257\3\2\2\2\u0266\u025c")
        buf.write("\3\2\2\2\u0267g\3\2\2\2\u0268\u026a\t\n\2\2\u0269\u0268")
        buf.write("\3\2\2\2\u026a\u026b\3\2\2\2\u026b\u0269\3\2\2\2\u026b")
        buf.write("\u026c\3\2\2\2\u026ci\3\2\2\2>npz\u0083\u008c\u0091\u0095")
        buf.write("\u009b\u00a4\u00a8\u00b1\u00b5\u00c0\u00c4\u00cb\u00d0")
        buf.write("\u00d2\u00d6\u00e0\u00e5\u00e8\u00ec\u00f2\u0102\u010e")
        buf.write("\u0117\u0123\u012f\u013a\u013f\u0148\u0152\u0157\u015c")
        buf.write("\u0161\u0165\u016d\u0175\u017e\u0182\u0189\u018f\u019c")
        buf.write("\u01a5\u01d0\u01d8\u01ee\u01f4\u01f9\u01fd\u0204\u0217")
        buf.write("\u021e\u0222\u022e\u0238\u0249\u0262\u0266\u026b")
        return buf.getvalue()


class kismetParser ( Parser ):

    grammarFileName = "kismet.ebnv"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'opposes'", "'/'", "'('", "','", "')'", 
                     "':'", "'.'", "'trait'", "'status'", "'visibility'", 
                     "'@'", "'+'", "'-'", "'action'", "';'", "'free'", "'response'", 
                     "'result'", "'location:'", "'?'", "'role'", "'extends'", 
                     "'cast'", "'<'", "'^'", "'*'", "'>'", "'tags'", "'if'", 
                     "'does not know'", "'doesnt know'", "'doesn't know'", 
                     "'did'", "'not'", "'hear'", "'didnt'", "'didn't'", 
                     "'see'", "'do'", "'receive'", "'forgets'", "'forgot'", 
                     "'forget'", "'knows'", "'hears'", "'heard'", "'saw'", 
                     "'received'", "''s'", "'s'", "'do not'", "'dont'", 
                     "'don't'", "'does not'", "'doesn't'", "'doesnt'", "'and'", 
                     "'each'", "'other'", "'eachother'", "'is missing'", 
                     "'is not'", "'is'", "'isn't'", "'isnt'", "'aint'", 
                     "'missing'", "'location'", "'initialization'", "'each_turn'", 
                     "'name'", "'supports'", "'='", "'=='", "'<='", "'>='", 
                     "'!='", "'['", "']'", "'_'" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "MINUS", "PLUS", "RANDOM_TEXT", "WS", 
                      "LINE_COMMENT", "NUMBER", "NAME", "VAR" ]

    RULE_world = 0
    RULE_opposition = 1
    RULE_trait = 2
    RULE_trait_type = 3
    RULE_propensity = 4
    RULE_propensity_name = 5
    RULE_modifier = 6
    RULE_goto = 7
    RULE_valence = 8
    RULE_action = 9
    RULE_free = 10
    RULE_response = 11
    RULE_add = 12
    RULE_change = 13
    RULE_visibility = 14
    RULE_action_location = 15
    RULE_loc = 16
    RULE_locWildCard = 17
    RULE_action_item = 18
    RULE_role = 19
    RULE_extension = 20
    RULE_cast_name = 21
    RULE_arg = 22
    RULE_sub = 23
    RULE_arg_type = 24
    RULE_tags = 25
    RULE_comparison = 26
    RULE_knowledge = 27
    RULE_condition = 28
    RULE_cond3 = 29
    RULE_cond1 = 30
    RULE_cond4 = 31
    RULE_inversion = 32
    RULE_cond5 = 33
    RULE_cond6 = 34
    RULE_cond7 = 35
    RULE_tag_compare = 36
    RULE_operator = 37
    RULE_location = 38
    RULE_initialization = 39
    RULE_each_turn = 40
    RULE_cast = 41
    RULE_random_text = 42
    RULE_l_name = 43
    RULE_supported_entities = 44
    RULE_supports = 45
    RULE_num = 46
    RULE_name = 47
    RULE_var = 48
    RULE_comparator = 49
    RULE_num_choice = 50
    RULE_pdf = 51

    ruleNames =  [ "world", "opposition", "trait", "trait_type", "propensity", 
                   "propensity_name", "modifier", "goto", "valence", "action", 
                   "free", "response", "add", "change", "visibility", "action_location", 
                   "loc", "locWildCard", "action_item", "role", "extension", 
                   "cast_name", "arg", "sub", "arg_type", "tags", "comparison", 
                   "knowledge", "condition", "cond3", "cond1", "cond4", 
                   "inversion", "cond5", "cond6", "cond7", "tag_compare", 
                   "operator", "location", "initialization", "each_turn", 
                   "cast", "random_text", "l_name", "supported_entities", 
                   "supports", "num", "name", "var", "comparator", "num_choice", 
                   "pdf" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    T__2=3
    T__3=4
    T__4=5
    T__5=6
    T__6=7
    T__7=8
    T__8=9
    T__9=10
    T__10=11
    T__11=12
    T__12=13
    T__13=14
    T__14=15
    T__15=16
    T__16=17
    T__17=18
    T__18=19
    T__19=20
    T__20=21
    T__21=22
    T__22=23
    T__23=24
    T__24=25
    T__25=26
    T__26=27
    T__27=28
    T__28=29
    T__29=30
    T__30=31
    T__31=32
    T__32=33
    T__33=34
    T__34=35
    T__35=36
    T__36=37
    T__37=38
    T__38=39
    T__39=40
    T__40=41
    T__41=42
    T__42=43
    T__43=44
    T__44=45
    T__45=46
    T__46=47
    T__47=48
    T__48=49
    T__49=50
    T__50=51
    T__51=52
    T__52=53
    T__53=54
    T__54=55
    T__55=56
    T__56=57
    T__57=58
    T__58=59
    T__59=60
    T__60=61
    T__61=62
    T__62=63
    T__63=64
    T__64=65
    T__65=66
    T__66=67
    T__67=68
    T__68=69
    T__69=70
    T__70=71
    T__71=72
    T__72=73
    T__73=74
    T__74=75
    T__75=76
    T__76=77
    T__77=78
    T__78=79
    T__79=80
    MINUS=81
    PLUS=82
    RANDOM_TEXT=83
    WS=84
    LINE_COMMENT=85
    NUMBER=86
    NAME=87
    VAR=88

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.7.2")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class WorldContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOF(self):
            return self.getToken(kismetParser.EOF, 0)

        def location(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.LocationContext)
            else:
                return self.getTypedRuleContext(kismetParser.LocationContext,i)


        def role(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.RoleContext)
            else:
                return self.getTypedRuleContext(kismetParser.RoleContext,i)


        def action(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.ActionContext)
            else:
                return self.getTypedRuleContext(kismetParser.ActionContext,i)


        def trait(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.TraitContext)
            else:
                return self.getTypedRuleContext(kismetParser.TraitContext,i)


        def getRuleIndex(self):
            return kismetParser.RULE_world

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWorld" ):
                listener.enterWorld(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWorld" ):
                listener.exitWorld(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWorld" ):
                return visitor.visitWorld(self)
            else:
                return visitor.visitChildren(self)




    def world(self):

        localctx = kismetParser.WorldContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_world)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 108 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 108
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [kismetParser.T__67]:
                    self.state = 104
                    self.location()
                    pass
                elif token in [kismetParser.T__20]:
                    self.state = 105
                    self.role()
                    pass
                elif token in [kismetParser.T__13, kismetParser.T__15, kismetParser.T__16]:
                    self.state = 106
                    self.action()
                    pass
                elif token in [kismetParser.T__7, kismetParser.T__8]:
                    self.state = 107
                    self.trait()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 110 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (((((_la - 8)) & ~0x3f) == 0 and ((1 << (_la - 8)) & ((1 << (kismetParser.T__7 - 8)) | (1 << (kismetParser.T__8 - 8)) | (1 << (kismetParser.T__13 - 8)) | (1 << (kismetParser.T__15 - 8)) | (1 << (kismetParser.T__16 - 8)) | (1 << (kismetParser.T__20 - 8)) | (1 << (kismetParser.T__67 - 8)))) != 0)):
                    break

            self.state = 112
            self.match(kismetParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OppositionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.NameContext)
            else:
                return self.getTypedRuleContext(kismetParser.NameContext,i)


        def getRuleIndex(self):
            return kismetParser.RULE_opposition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOpposition" ):
                listener.enterOpposition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOpposition" ):
                listener.exitOpposition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOpposition" ):
                return visitor.visitOpposition(self)
            else:
                return visitor.visitChildren(self)




    def opposition(self):

        localctx = kismetParser.OppositionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_opposition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 114
            self.match(kismetParser.T__0)
            self.state = 115
            self.name()
            self.state = 120
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__1:
                self.state = 116
                self.match(kismetParser.T__1)
                self.state = 117
                self.name()
                self.state = 122
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraitContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def trait_type(self):
            return self.getTypedRuleContext(kismetParser.Trait_typeContext,0)


        def name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.NameContext)
            else:
                return self.getTypedRuleContext(kismetParser.NameContext,i)


        def arg(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.ArgContext)
            else:
                return self.getTypedRuleContext(kismetParser.ArgContext,i)


        def opposition(self):
            return self.getTypedRuleContext(kismetParser.OppositionContext,0)


        def propensity(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.PropensityContext)
            else:
                return self.getTypedRuleContext(kismetParser.PropensityContext,i)


        def getRuleIndex(self):
            return kismetParser.RULE_trait

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTrait" ):
                listener.enterTrait(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTrait" ):
                listener.exitTrait(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTrait" ):
                return visitor.visitTrait(self)
            else:
                return visitor.visitChildren(self)




    def trait(self):

        localctx = kismetParser.TraitContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_trait)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 123
            self.trait_type()
            self.state = 124
            self.name()
            self.state = 129
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__1:
                self.state = 125
                self.match(kismetParser.T__1)
                self.state = 126
                self.name()
                self.state = 131
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 132
            self.match(kismetParser.T__2)
            self.state = 133
            self.arg()
            self.state = 138
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__3:
                self.state = 134
                self.match(kismetParser.T__3)
                self.state = 135
                self.arg()
                self.state = 140
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 141
            self.match(kismetParser.T__4)
            self.state = 143
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==kismetParser.T__0:
                self.state = 142
                self.opposition()


            self.state = 145
            self.match(kismetParser.T__5)
            self.state = 147
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==kismetParser.T__11 or _la==kismetParser.T__12:
                self.state = 146
                self.propensity()


            self.state = 153
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__3:
                self.state = 149
                self.match(kismetParser.T__3)
                self.state = 150
                self.propensity()
                self.state = 155
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 156
            self.match(kismetParser.T__6)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Trait_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return kismetParser.RULE_trait_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTrait_type" ):
                listener.enterTrait_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTrait_type" ):
                listener.exitTrait_type(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTrait_type" ):
                return visitor.visitTrait_type(self)
            else:
                return visitor.visitChildren(self)




    def trait_type(self):

        localctx = kismetParser.Trait_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_trait_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 158
            _la = self._input.LA(1)
            if not(_la==kismetParser.T__7 or _la==kismetParser.T__8):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PropensityContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def modifier(self):
            return self.getTypedRuleContext(kismetParser.ModifierContext,0)


        def goto(self):
            return self.getTypedRuleContext(kismetParser.GotoContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_propensity

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPropensity" ):
                listener.enterPropensity(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPropensity" ):
                listener.exitPropensity(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPropensity" ):
                return visitor.visitPropensity(self)
            else:
                return visitor.visitChildren(self)




    def propensity(self):

        localctx = kismetParser.PropensityContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_propensity)
        try:
            self.state = 162
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,8,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 160
                self.modifier()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 161
                self.goto()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Propensity_nameContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def name(self):
            return self.getTypedRuleContext(kismetParser.NameContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_propensity_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPropensity_name" ):
                listener.enterPropensity_name(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPropensity_name" ):
                listener.exitPropensity_name(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPropensity_name" ):
                return visitor.visitPropensity_name(self)
            else:
                return visitor.visitChildren(self)




    def propensity_name(self):

        localctx = kismetParser.Propensity_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_propensity_name)
        try:
            self.state = 166
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [kismetParser.T__9]:
                self.enterOuterAlt(localctx, 1)
                self.state = 164
                self.match(kismetParser.T__9)
                pass
            elif token in [kismetParser.NAME]:
                self.enterOuterAlt(localctx, 2)
                self.state = 165
                self.name()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ModifierContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def valence(self):
            return self.getTypedRuleContext(kismetParser.ValenceContext,0)


        def propensity_name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.Propensity_nameContext)
            else:
                return self.getTypedRuleContext(kismetParser.Propensity_nameContext,i)


        def comparison(self):
            return self.getTypedRuleContext(kismetParser.ComparisonContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_modifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterModifier" ):
                listener.enterModifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitModifier" ):
                listener.exitModifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitModifier" ):
                return visitor.visitModifier(self)
            else:
                return visitor.visitChildren(self)




    def modifier(self):

        localctx = kismetParser.ModifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_modifier)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 168
            self.valence()
            self.state = 169
            self.match(kismetParser.T__2)
            self.state = 170
            self.propensity_name()
            self.state = 175
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__3:
                self.state = 171
                self.match(kismetParser.T__3)
                self.state = 172
                self.propensity_name()
                self.state = 177
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 179
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==kismetParser.T__28:
                self.state = 178
                self.comparison()


            self.state = 181
            self.match(kismetParser.T__4)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GotoContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def valence(self):
            return self.getTypedRuleContext(kismetParser.ValenceContext,0)


        def name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.NameContext)
            else:
                return self.getTypedRuleContext(kismetParser.NameContext,i)


        def comparison(self):
            return self.getTypedRuleContext(kismetParser.ComparisonContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_goto

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGoto" ):
                listener.enterGoto(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGoto" ):
                listener.exitGoto(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGoto" ):
                return visitor.visitGoto(self)
            else:
                return visitor.visitChildren(self)




    def goto(self):

        localctx = kismetParser.GotoContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_goto)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 183
            self.valence()
            self.state = 184
            self.match(kismetParser.T__10)
            self.state = 185
            self.name()
            self.state = 190
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__3:
                self.state = 186
                self.match(kismetParser.T__3)
                self.state = 187
                self.name()
                self.state = 192
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 194
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==kismetParser.T__28:
                self.state = 193
                self.comparison()


            self.state = 196
            self.match(kismetParser.T__10)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ValenceContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return kismetParser.RULE_valence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterValence" ):
                listener.enterValence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitValence" ):
                listener.exitValence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitValence" ):
                return visitor.visitValence(self)
            else:
                return visitor.visitChildren(self)




    def valence(self):

        localctx = kismetParser.ValenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_valence)
        self._la = 0 # Token type
        try:
            self.state = 208
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [kismetParser.T__11]:
                self.enterOuterAlt(localctx, 1)
                self.state = 199 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 198
                    self.match(kismetParser.T__11)
                    self.state = 201 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==kismetParser.T__11):
                        break

                pass
            elif token in [kismetParser.T__12]:
                self.enterOuterAlt(localctx, 2)
                self.state = 204 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 203
                    self.match(kismetParser.T__12)
                    self.state = 206 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==kismetParser.T__12):
                        break

                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ActionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def name(self):
            return self.getTypedRuleContext(kismetParser.NameContext,0)


        def arg(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.ArgContext)
            else:
                return self.getTypedRuleContext(kismetParser.ArgContext,i)


        def free(self):
            return self.getTypedRuleContext(kismetParser.FreeContext,0)


        def response(self):
            return self.getTypedRuleContext(kismetParser.ResponseContext,0)


        def extension(self):
            return self.getTypedRuleContext(kismetParser.ExtensionContext,0)


        def random_text(self):
            return self.getTypedRuleContext(kismetParser.Random_textContext,0)


        def action_item(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.Action_itemContext)
            else:
                return self.getTypedRuleContext(kismetParser.Action_itemContext,i)


        def getRuleIndex(self):
            return kismetParser.RULE_action

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAction" ):
                listener.enterAction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAction" ):
                listener.exitAction(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAction" ):
                return visitor.visitAction(self)
            else:
                return visitor.visitChildren(self)




    def action(self):

        localctx = kismetParser.ActionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_action)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 212
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [kismetParser.T__15]:
                self.state = 210
                self.free()
                pass
            elif token in [kismetParser.T__16]:
                self.state = 211
                self.response()
                pass
            elif token in [kismetParser.T__13]:
                pass
            else:
                pass
            self.state = 214
            self.match(kismetParser.T__13)
            self.state = 215
            self.name()
            self.state = 216
            self.match(kismetParser.T__2)
            self.state = 217
            self.arg()
            self.state = 222
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__3:
                self.state = 218
                self.match(kismetParser.T__3)
                self.state = 219
                self.arg()
                self.state = 224
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 225
            self.match(kismetParser.T__4)
            self.state = 227
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==kismetParser.T__21:
                self.state = 226
                self.extension()


            self.state = 230
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==kismetParser.RANDOM_TEXT:
                self.state = 229
                self.random_text()


            self.state = 232
            self.match(kismetParser.T__5)
            self.state = 234
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << kismetParser.T__9) | (1 << kismetParser.T__17) | (1 << kismetParser.T__18) | (1 << kismetParser.T__27) | (1 << kismetParser.T__28))) != 0):
                self.state = 233
                self.action_item()


            self.state = 240
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__14:
                self.state = 236
                self.match(kismetParser.T__14)

                self.state = 237
                self.action_item()
                self.state = 242
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 243
            self.match(kismetParser.T__6)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FreeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return kismetParser.RULE_free

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFree" ):
                listener.enterFree(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFree" ):
                listener.exitFree(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFree" ):
                return visitor.visitFree(self)
            else:
                return visitor.visitChildren(self)




    def free(self):

        localctx = kismetParser.FreeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_free)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 245
            self.match(kismetParser.T__15)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ResponseContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return kismetParser.RULE_response

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterResponse" ):
                listener.enterResponse(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitResponse" ):
                listener.exitResponse(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitResponse" ):
                return visitor.visitResponse(self)
            else:
                return visitor.visitChildren(self)




    def response(self):

        localctx = kismetParser.ResponseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_response)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 247
            self.match(kismetParser.T__16)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AddContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def change(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.ChangeContext)
            else:
                return self.getTypedRuleContext(kismetParser.ChangeContext,i)


        def getRuleIndex(self):
            return kismetParser.RULE_add

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAdd" ):
                listener.enterAdd(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAdd" ):
                listener.exitAdd(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAdd" ):
                return visitor.visitAdd(self)
            else:
                return visitor.visitChildren(self)




    def add(self):

        localctx = kismetParser.AddContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_add)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 249
            self.match(kismetParser.T__17)
            self.state = 250
            self.match(kismetParser.T__5)
            self.state = 251
            self.change()
            self.state = 256
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__3:
                self.state = 252
                self.match(kismetParser.T__3)
                self.state = 253
                self.change()
                self.state = 258
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ChangeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def condition(self):
            return self.getTypedRuleContext(kismetParser.ConditionContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_change

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterChange" ):
                listener.enterChange(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitChange" ):
                listener.exitChange(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitChange" ):
                return visitor.visitChange(self)
            else:
                return visitor.visitChildren(self)




    def change(self):

        localctx = kismetParser.ChangeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_change)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 259
            self.condition()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VisibilityContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def valence(self):
            return self.getTypedRuleContext(kismetParser.ValenceContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_visibility

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVisibility" ):
                listener.enterVisibility(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVisibility" ):
                listener.exitVisibility(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVisibility" ):
                return visitor.visitVisibility(self)
            else:
                return visitor.visitChildren(self)




    def visibility(self):

        localctx = kismetParser.VisibilityContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_visibility)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 261
            self.match(kismetParser.T__9)
            self.state = 262
            self.valence()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Action_locationContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def loc(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.LocContext)
            else:
                return self.getTypedRuleContext(kismetParser.LocContext,i)


        def getRuleIndex(self):
            return kismetParser.RULE_action_location

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAction_location" ):
                listener.enterAction_location(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAction_location" ):
                listener.exitAction_location(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAction_location" ):
                return visitor.visitAction_location(self)
            else:
                return visitor.visitChildren(self)




    def action_location(self):

        localctx = kismetParser.Action_locationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_action_location)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 264
            self.match(kismetParser.T__18)
            self.state = 266 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 265
                self.loc()
                self.state = 268 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==kismetParser.T__2 or _la==kismetParser.T__19 or _la==kismetParser.NAME or _la==kismetParser.VAR):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LocContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def var(self):
            return self.getTypedRuleContext(kismetParser.VarContext,0)


        def arg(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.ArgContext)
            else:
                return self.getTypedRuleContext(kismetParser.ArgContext,i)


        def name(self):
            return self.getTypedRuleContext(kismetParser.NameContext,0)


        def locWildCard(self):
            return self.getTypedRuleContext(kismetParser.LocWildCardContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_loc

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLoc" ):
                listener.enterLoc(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLoc" ):
                listener.exitLoc(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLoc" ):
                return visitor.visitLoc(self)
            else:
                return visitor.visitChildren(self)




    def loc(self):

        localctx = kismetParser.LocContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_loc)
        self._la = 0 # Token type
        try:
            self.state = 317
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [kismetParser.VAR]:
                self.enterOuterAlt(localctx, 1)
                self.state = 270
                self.var()
                self.state = 271
                self.match(kismetParser.T__2)
                self.state = 272
                self.arg()
                self.state = 277
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==kismetParser.T__3:
                    self.state = 273
                    self.match(kismetParser.T__3)
                    self.state = 274
                    self.arg()
                    self.state = 279
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 280
                self.match(kismetParser.T__4)
                pass
            elif token in [kismetParser.NAME]:
                self.enterOuterAlt(localctx, 2)
                self.state = 282
                self.name()
                self.state = 283
                self.match(kismetParser.T__2)
                self.state = 284
                self.arg()
                self.state = 289
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==kismetParser.T__3:
                    self.state = 285
                    self.match(kismetParser.T__3)
                    self.state = 286
                    self.arg()
                    self.state = 291
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 292
                self.match(kismetParser.T__4)
                pass
            elif token in [kismetParser.T__19]:
                self.enterOuterAlt(localctx, 3)
                self.state = 294
                self.locWildCard()
                self.state = 295
                self.match(kismetParser.T__2)
                self.state = 296
                self.arg()
                self.state = 301
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==kismetParser.T__3:
                    self.state = 297
                    self.match(kismetParser.T__3)
                    self.state = 298
                    self.arg()
                    self.state = 303
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 304
                self.match(kismetParser.T__4)
                pass
            elif token in [kismetParser.T__2]:
                self.enterOuterAlt(localctx, 4)
                self.state = 306
                self.match(kismetParser.T__2)
                self.state = 307
                self.arg()
                self.state = 312
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==kismetParser.T__3:
                    self.state = 308
                    self.match(kismetParser.T__3)
                    self.state = 309
                    self.arg()
                    self.state = 314
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 315
                self.match(kismetParser.T__4)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LocWildCardContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return kismetParser.RULE_locWildCard

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLocWildCard" ):
                listener.enterLocWildCard(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLocWildCard" ):
                listener.exitLocWildCard(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLocWildCard" ):
                return visitor.visitLocWildCard(self)
            else:
                return visitor.visitChildren(self)




    def locWildCard(self):

        localctx = kismetParser.LocWildCardContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_locWildCard)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 319
            self.match(kismetParser.T__19)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Action_itemContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def tags(self):
            return self.getTypedRuleContext(kismetParser.TagsContext,0)


        def comparison(self):
            return self.getTypedRuleContext(kismetParser.ComparisonContext,0)


        def action_location(self):
            return self.getTypedRuleContext(kismetParser.Action_locationContext,0)


        def add(self):
            return self.getTypedRuleContext(kismetParser.AddContext,0)


        def visibility(self):
            return self.getTypedRuleContext(kismetParser.VisibilityContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_action_item

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAction_item" ):
                listener.enterAction_item(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAction_item" ):
                listener.exitAction_item(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAction_item" ):
                return visitor.visitAction_item(self)
            else:
                return visitor.visitChildren(self)




    def action_item(self):

        localctx = kismetParser.Action_itemContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_action_item)
        try:
            self.state = 326
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [kismetParser.T__27]:
                self.enterOuterAlt(localctx, 1)
                self.state = 321
                self.tags()
                pass
            elif token in [kismetParser.T__28]:
                self.enterOuterAlt(localctx, 2)
                self.state = 322
                self.comparison()
                pass
            elif token in [kismetParser.T__18]:
                self.enterOuterAlt(localctx, 3)
                self.state = 323
                self.action_location()
                pass
            elif token in [kismetParser.T__17]:
                self.enterOuterAlt(localctx, 4)
                self.state = 324
                self.add()
                pass
            elif token in [kismetParser.T__9]:
                self.enterOuterAlt(localctx, 5)
                self.state = 325
                self.visibility()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RoleContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def name(self):
            return self.getTypedRuleContext(kismetParser.NameContext,0)


        def arg(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.ArgContext)
            else:
                return self.getTypedRuleContext(kismetParser.ArgContext,i)


        def tags(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.TagsContext)
            else:
                return self.getTypedRuleContext(kismetParser.TagsContext,i)


        def comparison(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.ComparisonContext)
            else:
                return self.getTypedRuleContext(kismetParser.ComparisonContext,i)


        def extension(self):
            return self.getTypedRuleContext(kismetParser.ExtensionContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_role

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRole" ):
                listener.enterRole(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRole" ):
                listener.exitRole(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRole" ):
                return visitor.visitRole(self)
            else:
                return visitor.visitChildren(self)




    def role(self):

        localctx = kismetParser.RoleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_role)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 328
            self.match(kismetParser.T__20)
            self.state = 329
            self.name()
            self.state = 330
            self.match(kismetParser.T__2)
            self.state = 331
            self.arg()
            self.state = 336
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__3:
                self.state = 332
                self.match(kismetParser.T__3)
                self.state = 333
                self.arg()
                self.state = 338
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 339
            self.match(kismetParser.T__4)
            self.state = 341
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==kismetParser.T__21:
                self.state = 340
                self.extension()


            self.state = 343
            self.match(kismetParser.T__5)
            self.state = 346
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [kismetParser.T__27]:
                self.state = 344
                self.tags()
                pass
            elif token in [kismetParser.T__28]:
                self.state = 345
                self.comparison()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 355
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__14:
                self.state = 348
                self.match(kismetParser.T__14)
                self.state = 351
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [kismetParser.T__27]:
                    self.state = 349
                    self.tags()
                    pass
                elif token in [kismetParser.T__28]:
                    self.state = 350
                    self.comparison()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 357
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 358
            self.match(kismetParser.T__6)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExtensionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def arg(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.ArgContext)
            else:
                return self.getTypedRuleContext(kismetParser.ArgContext,i)


        def cast_name(self):
            return self.getTypedRuleContext(kismetParser.Cast_nameContext,0)


        def name(self):
            return self.getTypedRuleContext(kismetParser.NameContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_extension

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExtension" ):
                listener.enterExtension(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExtension" ):
                listener.exitExtension(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExtension" ):
                return visitor.visitExtension(self)
            else:
                return visitor.visitChildren(self)




    def extension(self):

        localctx = kismetParser.ExtensionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_extension)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 360
            self.match(kismetParser.T__21)
            self.state = 363
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [kismetParser.T__22]:
                self.state = 361
                self.cast_name()
                pass
            elif token in [kismetParser.NAME]:
                self.state = 362
                self.name()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 365
            self.match(kismetParser.T__2)
            self.state = 366
            self.arg()
            self.state = 371
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__3:
                self.state = 367
                self.match(kismetParser.T__3)
                self.state = 368
                self.arg()
                self.state = 373
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 374
            self.match(kismetParser.T__4)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Cast_nameContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def name(self):
            return self.getTypedRuleContext(kismetParser.NameContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_cast_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCast_name" ):
                listener.enterCast_name(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCast_name" ):
                listener.exitCast_name(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCast_name" ):
                return visitor.visitCast_name(self)
            else:
                return visitor.visitChildren(self)




    def cast_name(self):

        localctx = kismetParser.Cast_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_cast_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 376
            self.match(kismetParser.T__22)
            self.state = 377
            self.name()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ArgContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def var(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.VarContext)
            else:
                return self.getTypedRuleContext(kismetParser.VarContext,i)


        def arg_type(self):
            return self.getTypedRuleContext(kismetParser.Arg_typeContext,0)


        def sub(self):
            return self.getTypedRuleContext(kismetParser.SubContext,0)


        def name(self):
            return self.getTypedRuleContext(kismetParser.NameContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_arg

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArg" ):
                listener.enterArg(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArg" ):
                listener.exitArg(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitArg" ):
                return visitor.visitArg(self)
            else:
                return visitor.visitChildren(self)




    def arg(self):

        localctx = kismetParser.ArgContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_arg)
        self._la = 0 # Token type
        try:
            self.state = 397
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,41,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 380
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << kismetParser.T__10) | (1 << kismetParser.T__23) | (1 << kismetParser.T__24) | (1 << kismetParser.T__25) | (1 << kismetParser.T__26))) != 0):
                    self.state = 379
                    self.arg_type()


                self.state = 382
                self.var()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 384
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << kismetParser.T__10) | (1 << kismetParser.T__23) | (1 << kismetParser.T__24) | (1 << kismetParser.T__25) | (1 << kismetParser.T__26))) != 0):
                    self.state = 383
                    self.arg_type()


                self.state = 386
                self.var()
                self.state = 387
                self.sub()
                self.state = 388
                self.name()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 391
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << kismetParser.T__10) | (1 << kismetParser.T__23) | (1 << kismetParser.T__24) | (1 << kismetParser.T__25) | (1 << kismetParser.T__26))) != 0):
                    self.state = 390
                    self.arg_type()


                self.state = 393
                self.var()
                self.state = 394
                self.sub()
                self.state = 395
                self.var()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SubContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return kismetParser.RULE_sub

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSub" ):
                listener.enterSub(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSub" ):
                listener.exitSub(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSub" ):
                return visitor.visitSub(self)
            else:
                return visitor.visitChildren(self)




    def sub(self):

        localctx = kismetParser.SubContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_sub)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 399
            _la = self._input.LA(1)
            if not(_la==kismetParser.T__5 or _la==kismetParser.T__6):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Arg_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return kismetParser.RULE_arg_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArg_type" ):
                listener.enterArg_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArg_type" ):
                listener.exitArg_type(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitArg_type" ):
                return visitor.visitArg_type(self)
            else:
                return visitor.visitChildren(self)




    def arg_type(self):

        localctx = kismetParser.Arg_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_arg_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 401
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << kismetParser.T__10) | (1 << kismetParser.T__23) | (1 << kismetParser.T__24) | (1 << kismetParser.T__25) | (1 << kismetParser.T__26))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TagsContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.NameContext)
            else:
                return self.getTypedRuleContext(kismetParser.NameContext,i)


        def getRuleIndex(self):
            return kismetParser.RULE_tags

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTags" ):
                listener.enterTags(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTags" ):
                listener.exitTags(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTags" ):
                return visitor.visitTags(self)
            else:
                return visitor.visitChildren(self)




    def tags(self):

        localctx = kismetParser.TagsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_tags)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 403
            self.match(kismetParser.T__27)
            self.state = 404
            self.match(kismetParser.T__5)
            self.state = 405
            self.name()
            self.state = 410
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__3:
                self.state = 406
                self.match(kismetParser.T__3)
                self.state = 407
                self.name()
                self.state = 412
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ComparisonContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def condition(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.ConditionContext)
            else:
                return self.getTypedRuleContext(kismetParser.ConditionContext,i)


        def getRuleIndex(self):
            return kismetParser.RULE_comparison

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterComparison" ):
                listener.enterComparison(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitComparison" ):
                listener.exitComparison(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitComparison" ):
                return visitor.visitComparison(self)
            else:
                return visitor.visitChildren(self)




    def comparison(self):

        localctx = kismetParser.ComparisonContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_comparison)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 413
            self.match(kismetParser.T__28)
            self.state = 414
            self.condition()
            self.state = 419
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__3:
                self.state = 415
                self.match(kismetParser.T__3)
                self.state = 416
                self.condition()
                self.state = 421
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class KnowledgeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return kismetParser.RULE_knowledge

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterKnowledge" ):
                listener.enterKnowledge(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitKnowledge" ):
                listener.exitKnowledge(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitKnowledge" ):
                return visitor.visitKnowledge(self)
            else:
                return visitor.visitChildren(self)




    def knowledge(self):

        localctx = kismetParser.KnowledgeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_knowledge)
        try:
            self.state = 462
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,44,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 422
                self.match(kismetParser.T__29)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 423
                self.match(kismetParser.T__30)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 424
                self.match(kismetParser.T__31)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 425
                self.match(kismetParser.T__32)
                self.state = 426
                self.match(kismetParser.T__33)
                self.state = 427
                self.match(kismetParser.T__34)
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 428
                self.match(kismetParser.T__35)
                self.state = 429
                self.match(kismetParser.T__34)
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 430
                self.match(kismetParser.T__36)
                self.state = 431
                self.match(kismetParser.T__34)
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 432
                self.match(kismetParser.T__32)
                self.state = 433
                self.match(kismetParser.T__33)
                self.state = 434
                self.match(kismetParser.T__37)
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 435
                self.match(kismetParser.T__35)
                self.state = 436
                self.match(kismetParser.T__37)
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 437
                self.match(kismetParser.T__36)
                self.state = 438
                self.match(kismetParser.T__37)
                pass

            elif la_ == 10:
                self.enterOuterAlt(localctx, 10)
                self.state = 439
                self.match(kismetParser.T__32)
                self.state = 440
                self.match(kismetParser.T__33)
                self.state = 441
                self.match(kismetParser.T__38)
                pass

            elif la_ == 11:
                self.enterOuterAlt(localctx, 11)
                self.state = 442
                self.match(kismetParser.T__35)
                self.state = 443
                self.match(kismetParser.T__38)
                pass

            elif la_ == 12:
                self.enterOuterAlt(localctx, 12)
                self.state = 444
                self.match(kismetParser.T__36)
                self.state = 445
                self.match(kismetParser.T__38)
                pass

            elif la_ == 13:
                self.enterOuterAlt(localctx, 13)
                self.state = 446
                self.match(kismetParser.T__32)
                self.state = 447
                self.match(kismetParser.T__33)
                self.state = 448
                self.match(kismetParser.T__39)
                pass

            elif la_ == 14:
                self.enterOuterAlt(localctx, 14)
                self.state = 449
                self.match(kismetParser.T__35)
                self.state = 450
                self.match(kismetParser.T__39)
                pass

            elif la_ == 15:
                self.enterOuterAlt(localctx, 15)
                self.state = 451
                self.match(kismetParser.T__36)
                self.state = 452
                self.match(kismetParser.T__39)
                pass

            elif la_ == 16:
                self.enterOuterAlt(localctx, 16)
                self.state = 453
                self.match(kismetParser.T__40)
                pass

            elif la_ == 17:
                self.enterOuterAlt(localctx, 17)
                self.state = 454
                self.match(kismetParser.T__41)
                pass

            elif la_ == 18:
                self.enterOuterAlt(localctx, 18)
                self.state = 455
                self.match(kismetParser.T__42)
                pass

            elif la_ == 19:
                self.enterOuterAlt(localctx, 19)
                self.state = 456
                self.match(kismetParser.T__43)
                pass

            elif la_ == 20:
                self.enterOuterAlt(localctx, 20)
                self.state = 457
                self.match(kismetParser.T__44)
                pass

            elif la_ == 21:
                self.enterOuterAlt(localctx, 21)
                self.state = 458
                self.match(kismetParser.T__45)
                pass

            elif la_ == 22:
                self.enterOuterAlt(localctx, 22)
                self.state = 459
                self.match(kismetParser.T__46)
                pass

            elif la_ == 23:
                self.enterOuterAlt(localctx, 23)
                self.state = 460
                self.match(kismetParser.T__32)
                pass

            elif la_ == 24:
                self.enterOuterAlt(localctx, 24)
                self.state = 461
                self.match(kismetParser.T__47)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConditionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def cond3(self):
            return self.getTypedRuleContext(kismetParser.Cond3Context,0)


        def cond1(self):
            return self.getTypedRuleContext(kismetParser.Cond1Context,0)


        def cond4(self):
            return self.getTypedRuleContext(kismetParser.Cond4Context,0)


        def cond5(self):
            return self.getTypedRuleContext(kismetParser.Cond5Context,0)


        def cond6(self):
            return self.getTypedRuleContext(kismetParser.Cond6Context,0)


        def cond7(self):
            return self.getTypedRuleContext(kismetParser.Cond7Context,0)


        def getRuleIndex(self):
            return kismetParser.RULE_condition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCondition" ):
                listener.enterCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCondition" ):
                listener.exitCondition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCondition" ):
                return visitor.visitCondition(self)
            else:
                return visitor.visitChildren(self)




    def condition(self):

        localctx = kismetParser.ConditionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_condition)
        try:
            self.state = 470
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,45,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 464
                self.cond3()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 465
                self.cond1()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 466
                self.cond4()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 467
                self.cond5()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 468
                self.cond6()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 469
                self.cond7()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Cond3Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def arg(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.ArgContext)
            else:
                return self.getTypedRuleContext(kismetParser.ArgContext,i)


        def knowledge(self):
            return self.getTypedRuleContext(kismetParser.KnowledgeContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_cond3

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCond3" ):
                listener.enterCond3(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCond3" ):
                listener.exitCond3(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCond3" ):
                return visitor.visitCond3(self)
            else:
                return visitor.visitChildren(self)




    def cond3(self):

        localctx = kismetParser.Cond3Context(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_cond3)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 472
            self.arg()
            self.state = 473
            self.knowledge()
            self.state = 474
            self.arg()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Cond1Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def arg(self):
            return self.getTypedRuleContext(kismetParser.ArgContext,0)


        def tag_compare(self):
            return self.getTypedRuleContext(kismetParser.Tag_compareContext,0)


        def name(self):
            return self.getTypedRuleContext(kismetParser.NameContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_cond1

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCond1" ):
                listener.enterCond1(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCond1" ):
                listener.exitCond1(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCond1" ):
                return visitor.visitCond1(self)
            else:
                return visitor.visitChildren(self)




    def cond1(self):

        localctx = kismetParser.Cond1Context(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_cond1)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 476
            self.arg()
            self.state = 477
            self.tag_compare()
            self.state = 478
            self.name()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Cond4Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def arg(self):
            return self.getTypedRuleContext(kismetParser.ArgContext,0)


        def name(self):
            return self.getTypedRuleContext(kismetParser.NameContext,0)


        def comparator(self):
            return self.getTypedRuleContext(kismetParser.ComparatorContext,0)


        def num(self):
            return self.getTypedRuleContext(kismetParser.NumContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_cond4

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCond4" ):
                listener.enterCond4(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCond4" ):
                listener.exitCond4(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCond4" ):
                return visitor.visitCond4(self)
            else:
                return visitor.visitChildren(self)




    def cond4(self):

        localctx = kismetParser.Cond4Context(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_cond4)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 480
            self.arg()
            self.state = 481
            _la = self._input.LA(1)
            if not(_la==kismetParser.T__48 or _la==kismetParser.T__49):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 482
            self.name()
            self.state = 483
            self.comparator()
            self.state = 484
            self.num()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InversionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return kismetParser.RULE_inversion

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInversion" ):
                listener.enterInversion(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInversion" ):
                listener.exitInversion(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInversion" ):
                return visitor.visitInversion(self)
            else:
                return visitor.visitChildren(self)




    def inversion(self):

        localctx = kismetParser.InversionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_inversion)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 486
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << kismetParser.T__50) | (1 << kismetParser.T__51) | (1 << kismetParser.T__52) | (1 << kismetParser.T__53) | (1 << kismetParser.T__54) | (1 << kismetParser.T__55))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Cond5Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def arg(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.ArgContext)
            else:
                return self.getTypedRuleContext(kismetParser.ArgContext,i)


        def name(self):
            return self.getTypedRuleContext(kismetParser.NameContext,0)


        def inversion(self):
            return self.getTypedRuleContext(kismetParser.InversionContext,0)


        def operator(self):
            return self.getTypedRuleContext(kismetParser.OperatorContext,0)


        def num(self):
            return self.getTypedRuleContext(kismetParser.NumContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_cond5

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCond5" ):
                listener.enterCond5(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCond5" ):
                listener.exitCond5(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCond5" ):
                return visitor.visitCond5(self)
            else:
                return visitor.visitChildren(self)




    def cond5(self):

        localctx = kismetParser.Cond5Context(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_cond5)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 488
            self.arg()
            self.state = 489
            self.match(kismetParser.T__56)
            self.state = 490
            self.arg()
            self.state = 492
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << kismetParser.T__50) | (1 << kismetParser.T__51) | (1 << kismetParser.T__52) | (1 << kismetParser.T__53) | (1 << kismetParser.T__54) | (1 << kismetParser.T__55))) != 0):
                self.state = 491
                self.inversion()


            self.state = 494
            self.name()
            self.state = 498
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [kismetParser.T__57]:
                self.state = 495
                self.match(kismetParser.T__57)
                self.state = 496
                self.match(kismetParser.T__58)
                pass
            elif token in [kismetParser.T__59]:
                self.state = 497
                self.match(kismetParser.T__59)
                pass
            else:
                raise NoViableAltException(self)

            self.state = 503
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==kismetParser.MINUS or _la==kismetParser.PLUS:
                self.state = 500
                self.operator()
                self.state = 501
                self.num()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Cond6Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def arg(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.ArgContext)
            else:
                return self.getTypedRuleContext(kismetParser.ArgContext,i)


        def name(self):
            return self.getTypedRuleContext(kismetParser.NameContext,0)


        def inversion(self):
            return self.getTypedRuleContext(kismetParser.InversionContext,0)


        def operator(self):
            return self.getTypedRuleContext(kismetParser.OperatorContext,0)


        def num(self):
            return self.getTypedRuleContext(kismetParser.NumContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_cond6

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCond6" ):
                listener.enterCond6(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCond6" ):
                listener.exitCond6(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCond6" ):
                return visitor.visitCond6(self)
            else:
                return visitor.visitChildren(self)




    def cond6(self):

        localctx = kismetParser.Cond6Context(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_cond6)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 505
            self.arg()
            self.state = 507
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << kismetParser.T__50) | (1 << kismetParser.T__51) | (1 << kismetParser.T__52) | (1 << kismetParser.T__53) | (1 << kismetParser.T__54) | (1 << kismetParser.T__55))) != 0):
                self.state = 506
                self.inversion()


            self.state = 509
            self.name()
            self.state = 510
            self.arg()
            self.state = 514
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==kismetParser.MINUS or _la==kismetParser.PLUS:
                self.state = 511
                self.operator()
                self.state = 512
                self.num()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Cond7Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def arg(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.ArgContext)
            else:
                return self.getTypedRuleContext(kismetParser.ArgContext,i)


        def name(self):
            return self.getTypedRuleContext(kismetParser.NameContext,0)


        def comparator(self):
            return self.getTypedRuleContext(kismetParser.ComparatorContext,0)


        def num(self):
            return self.getTypedRuleContext(kismetParser.NumContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_cond7

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCond7" ):
                listener.enterCond7(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCond7" ):
                listener.exitCond7(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCond7" ):
                return visitor.visitCond7(self)
            else:
                return visitor.visitChildren(self)




    def cond7(self):

        localctx = kismetParser.Cond7Context(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_cond7)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 516
            self.arg()
            self.state = 517
            self.name()
            self.state = 518
            self.arg()
            self.state = 519
            self.comparator()
            self.state = 520
            self.num()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Tag_compareContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return kismetParser.RULE_tag_compare

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTag_compare" ):
                listener.enterTag_compare(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTag_compare" ):
                listener.exitTag_compare(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTag_compare" ):
                return visitor.visitTag_compare(self)
            else:
                return visitor.visitChildren(self)




    def tag_compare(self):

        localctx = kismetParser.Tag_compareContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_tag_compare)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 522
            _la = self._input.LA(1)
            if not(((((_la - 61)) & ~0x3f) == 0 and ((1 << (_la - 61)) & ((1 << (kismetParser.T__60 - 61)) | (1 << (kismetParser.T__61 - 61)) | (1 << (kismetParser.T__62 - 61)) | (1 << (kismetParser.T__63 - 61)) | (1 << (kismetParser.T__64 - 61)) | (1 << (kismetParser.T__65 - 61)) | (1 << (kismetParser.T__66 - 61)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OperatorContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MINUS(self):
            return self.getToken(kismetParser.MINUS, 0)

        def PLUS(self):
            return self.getToken(kismetParser.PLUS, 0)

        def getRuleIndex(self):
            return kismetParser.RULE_operator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOperator" ):
                listener.enterOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOperator" ):
                listener.exitOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOperator" ):
                return visitor.visitOperator(self)
            else:
                return visitor.visitChildren(self)




    def operator(self):

        localctx = kismetParser.OperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_operator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 524
            _la = self._input.LA(1)
            if not(_la==kismetParser.MINUS or _la==kismetParser.PLUS):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LocationContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def name(self):
            return self.getTypedRuleContext(kismetParser.NameContext,0)


        def l_name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.L_nameContext)
            else:
                return self.getTypedRuleContext(kismetParser.L_nameContext,i)


        def supports(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.SupportsContext)
            else:
                return self.getTypedRuleContext(kismetParser.SupportsContext,i)


        def initialization(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.InitializationContext)
            else:
                return self.getTypedRuleContext(kismetParser.InitializationContext,i)


        def each_turn(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.Each_turnContext)
            else:
                return self.getTypedRuleContext(kismetParser.Each_turnContext,i)


        def getRuleIndex(self):
            return kismetParser.RULE_location

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLocation" ):
                listener.enterLocation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLocation" ):
                listener.exitLocation(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLocation" ):
                return visitor.visitLocation(self)
            else:
                return visitor.visitChildren(self)




    def location(self):

        localctx = kismetParser.LocationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_location)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 526
            self.match(kismetParser.T__67)
            self.state = 527
            self.name()
            self.state = 528
            self.match(kismetParser.T__5)
            self.state = 533
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [kismetParser.T__70]:
                self.state = 529
                self.l_name()
                pass
            elif token in [kismetParser.T__71]:
                self.state = 530
                self.supports()
                pass
            elif token in [kismetParser.T__68]:
                self.state = 531
                self.initialization()
                pass
            elif token in [kismetParser.T__69]:
                self.state = 532
                self.each_turn()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 544
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__14:
                self.state = 535
                self.match(kismetParser.T__14)
                self.state = 540
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [kismetParser.T__70]:
                    self.state = 536
                    self.l_name()
                    pass
                elif token in [kismetParser.T__71]:
                    self.state = 537
                    self.supports()
                    pass
                elif token in [kismetParser.T__68]:
                    self.state = 538
                    self.initialization()
                    pass
                elif token in [kismetParser.T__69]:
                    self.state = 539
                    self.each_turn()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 546
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 547
            self.match(kismetParser.T__6)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InitializationContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def cast(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.CastContext)
            else:
                return self.getTypedRuleContext(kismetParser.CastContext,i)


        def getRuleIndex(self):
            return kismetParser.RULE_initialization

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInitialization" ):
                listener.enterInitialization(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInitialization" ):
                listener.exitInitialization(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInitialization" ):
                return visitor.visitInitialization(self)
            else:
                return visitor.visitChildren(self)




    def initialization(self):

        localctx = kismetParser.InitializationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 78, self.RULE_initialization)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 549
            self.match(kismetParser.T__68)
            self.state = 550
            self.match(kismetParser.T__5)
            self.state = 551
            self.cast()
            self.state = 556
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__3:
                self.state = 552
                self.match(kismetParser.T__3)
                self.state = 553
                self.cast()
                self.state = 558
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Each_turnContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def cast(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.CastContext)
            else:
                return self.getTypedRuleContext(kismetParser.CastContext,i)


        def getRuleIndex(self):
            return kismetParser.RULE_each_turn

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEach_turn" ):
                listener.enterEach_turn(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEach_turn" ):
                listener.exitEach_turn(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEach_turn" ):
                return visitor.visitEach_turn(self)
            else:
                return visitor.visitChildren(self)




    def each_turn(self):

        localctx = kismetParser.Each_turnContext(self, self._ctx, self.state)
        self.enterRule(localctx, 80, self.RULE_each_turn)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 559
            self.match(kismetParser.T__69)
            self.state = 560
            self.match(kismetParser.T__5)
            self.state = 561
            self.cast()
            self.state = 566
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==kismetParser.T__3:
                self.state = 562
                self.match(kismetParser.T__3)
                self.state = 563
                self.cast()
                self.state = 568
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CastContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def num_choice(self):
            return self.getTypedRuleContext(kismetParser.Num_choiceContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_cast

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCast" ):
                listener.enterCast(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCast" ):
                listener.exitCast(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCast" ):
                return visitor.visitCast(self)
            else:
                return visitor.visitChildren(self)




    def cast(self):

        localctx = kismetParser.CastContext(self, self._ctx, self.state)
        self.enterRule(localctx, 82, self.RULE_cast)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 569
            self.match(kismetParser.T__22)
            self.state = 570
            self.num_choice()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Random_textContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RANDOM_TEXT(self):
            return self.getToken(kismetParser.RANDOM_TEXT, 0)

        def getRuleIndex(self):
            return kismetParser.RULE_random_text

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRandom_text" ):
                listener.enterRandom_text(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRandom_text" ):
                listener.exitRandom_text(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRandom_text" ):
                return visitor.visitRandom_text(self)
            else:
                return visitor.visitChildren(self)




    def random_text(self):

        localctx = kismetParser.Random_textContext(self, self._ctx, self.state)
        self.enterRule(localctx, 84, self.RULE_random_text)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 572
            self.match(kismetParser.RANDOM_TEXT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class L_nameContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def random_text(self):
            return self.getTypedRuleContext(kismetParser.Random_textContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_l_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterL_name" ):
                listener.enterL_name(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitL_name" ):
                listener.exitL_name(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitL_name" ):
                return visitor.visitL_name(self)
            else:
                return visitor.visitChildren(self)




    def l_name(self):

        localctx = kismetParser.L_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 86, self.RULE_l_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 574
            self.match(kismetParser.T__70)
            self.state = 575
            self.match(kismetParser.T__5)
            self.state = 576
            self.random_text()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Supported_entitiesContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def num_choice(self):
            return self.getTypedRuleContext(kismetParser.Num_choiceContext,0)


        def supported_entities(self):
            return self.getTypedRuleContext(kismetParser.Supported_entitiesContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_supported_entities

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSupported_entities" ):
                listener.enterSupported_entities(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSupported_entities" ):
                listener.exitSupported_entities(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSupported_entities" ):
                return visitor.visitSupported_entities(self)
            else:
                return visitor.visitChildren(self)




    def supported_entities(self):

        localctx = kismetParser.Supported_entitiesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 88, self.RULE_supported_entities)
        try:
            self.state = 583
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,56,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 578
                self.num_choice()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 579
                self.num_choice()
                self.state = 580
                self.match(kismetParser.T__3)
                self.state = 581
                self.supported_entities()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SupportsContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def supported_entities(self):
            return self.getTypedRuleContext(kismetParser.Supported_entitiesContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_supports

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSupports" ):
                listener.enterSupports(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSupports" ):
                listener.exitSupports(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSupports" ):
                return visitor.visitSupports(self)
            else:
                return visitor.visitChildren(self)




    def supports(self):

        localctx = kismetParser.SupportsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 90, self.RULE_supports)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 585
            self.match(kismetParser.T__71)
            self.state = 586
            self.match(kismetParser.T__5)
            self.state = 587
            self.supported_entities()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NumContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NUMBER(self):
            return self.getToken(kismetParser.NUMBER, 0)

        def getRuleIndex(self):
            return kismetParser.RULE_num

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNum" ):
                listener.enterNum(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNum" ):
                listener.exitNum(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNum" ):
                return visitor.visitNum(self)
            else:
                return visitor.visitChildren(self)




    def num(self):

        localctx = kismetParser.NumContext(self, self._ctx, self.state)
        self.enterRule(localctx, 92, self.RULE_num)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 589
            self.match(kismetParser.NUMBER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NameContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NAME(self):
            return self.getToken(kismetParser.NAME, 0)

        def getRuleIndex(self):
            return kismetParser.RULE_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterName" ):
                listener.enterName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitName" ):
                listener.exitName(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitName" ):
                return visitor.visitName(self)
            else:
                return visitor.visitChildren(self)




    def name(self):

        localctx = kismetParser.NameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 94, self.RULE_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 591
            self.match(kismetParser.NAME)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VarContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def VAR(self):
            return self.getToken(kismetParser.VAR, 0)

        def getRuleIndex(self):
            return kismetParser.RULE_var

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVar" ):
                listener.enterVar(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVar" ):
                listener.exitVar(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVar" ):
                return visitor.visitVar(self)
            else:
                return visitor.visitChildren(self)




    def var(self):

        localctx = kismetParser.VarContext(self, self._ctx, self.state)
        self.enterRule(localctx, 96, self.RULE_var)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 593
            self.match(kismetParser.VAR)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ComparatorContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return kismetParser.RULE_comparator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterComparator" ):
                listener.enterComparator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitComparator" ):
                listener.exitComparator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitComparator" ):
                return visitor.visitComparator(self)
            else:
                return visitor.visitChildren(self)




    def comparator(self):

        localctx = kismetParser.ComparatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 98, self.RULE_comparator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 595
            _la = self._input.LA(1)
            if not(((((_la - 24)) & ~0x3f) == 0 and ((1 << (_la - 24)) & ((1 << (kismetParser.T__23 - 24)) | (1 << (kismetParser.T__26 - 24)) | (1 << (kismetParser.T__72 - 24)) | (1 << (kismetParser.T__73 - 24)) | (1 << (kismetParser.T__74 - 24)) | (1 << (kismetParser.T__75 - 24)) | (1 << (kismetParser.T__76 - 24)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Num_choiceContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def num(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(kismetParser.NumContext)
            else:
                return self.getTypedRuleContext(kismetParser.NumContext,i)


        def name(self):
            return self.getTypedRuleContext(kismetParser.NameContext,0)


        def pdf(self):
            return self.getTypedRuleContext(kismetParser.PdfContext,0)


        def getRuleIndex(self):
            return kismetParser.RULE_num_choice

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNum_choice" ):
                listener.enterNum_choice(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNum_choice" ):
                listener.exitNum_choice(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNum_choice" ):
                return visitor.visitNum_choice(self)
            else:
                return visitor.visitChildren(self)




    def num_choice(self):

        localctx = kismetParser.Num_choiceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 100, self.RULE_num_choice)
        self._la = 0 # Token type
        try:
            self.state = 612
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,58,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 597
                self.match(kismetParser.T__77)
                self.state = 598
                self.num()
                self.state = 599
                self.match(kismetParser.T__78)
                self.state = 600
                self.name()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 602
                self.match(kismetParser.T__77)
                self.state = 603
                self.num()
                self.state = 604
                self.match(kismetParser.T__12)
                self.state = 605
                self.num()
                self.state = 606
                self.match(kismetParser.T__78)
                self.state = 608
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << kismetParser.T__6) | (1 << kismetParser.T__12) | (1 << kismetParser.T__24))) != 0) or _la==kismetParser.T__79:
                    self.state = 607
                    self.pdf()


                self.state = 610
                self.name()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PdfContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return kismetParser.RULE_pdf

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPdf" ):
                listener.enterPdf(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPdf" ):
                listener.exitPdf(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPdf" ):
                return visitor.visitPdf(self)
            else:
                return visitor.visitChildren(self)




    def pdf(self):

        localctx = kismetParser.PdfContext(self, self._ctx, self.state)
        self.enterRule(localctx, 102, self.RULE_pdf)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 615 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 614
                _la = self._input.LA(1)
                if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << kismetParser.T__6) | (1 << kismetParser.T__12) | (1 << kismetParser.T__24))) != 0) or _la==kismetParser.T__79):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 617 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << kismetParser.T__6) | (1 << kismetParser.T__12) | (1 << kismetParser.T__24))) != 0) or _la==kismetParser.T__79):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





